<!DOCTYPE html>

<HTML><head><TITLE>Manpage of MDADM</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>MDADM</H1>
Section: Maintenance Commands (8)<BR>Updated: <BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

mdadm - manage MD devices
<I>aka</I>

Linux Software RAID
<P>
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<P>
<B>mdadm</B><I> [mode] &lt;raiddevice&gt; [options] &lt;component-devices&gt;</I>

<P>
<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

RAID devices are virtual devices created from two or more
real block devices.  This allows multiple devices (typically disk
drives or partitions thereof) to be combined into a single device to
hold (for example) a single filesystem.
Some RAID levels include redundancy and so can survive some degree of
device failure.
<P>
Linux Software RAID devices are implemented through the md (Multiple
Devices) device driver.
<P>
Currently, Linux supports
<B>LINEAR</B>

md devices,
<B>RAID0</B>

(striping),
<B>RAID1</B>

(mirroring),
<B>RAID4</B>,

<B>RAID5</B>,

<B>RAID6</B>,

<B>RAID10</B>,

<B>MULTIPATH</B>,

<B>FAULTY</B>,

and
<B>CONTAINER</B>.

<P>
<B>MULTIPATH</B>

is not a Software RAID mechanism, but does involve
multiple devices:
each device is a path to one common physical storage device.
New installations should not use md/multipath as it is not well
supported and has no ongoing development.  Use the Device Mapper based
multipath-tools instead.
<P>
<B>FAULTY</B>

is also not true RAID, and it only involves one device.  It
provides a layer over a true device that can be used to inject faults.
<P>
<B>CONTAINER</B>

is different again.  A
<B>CONTAINER</B>

is a collection of devices that are
managed as a set.  This is similar to the set of devices connected to
a hardware RAID controller.  The set of devices may contain a number
of different RAID arrays each utilising some (or all) of the blocks from a
number of the devices in the set.  For example, two devices in a 5-device set
might form a RAID1 using the whole devices.  The remaining three might
have a RAID5 over the first half of each device, and a RAID0 over the
second half.
<P>
With a
<B>CONTAINER</B>,

there is one set of metadata that describes all of
the arrays in the container.  So when
<I>mdadm</I>

creates a
<B>CONTAINER</B>

device, the device just represents the metadata.  Other normal arrays (RAID1
etc) can be created inside the container.
<P>
<A NAME="lbAE">&nbsp;</A>
<H2>MODES</H2>

mdadm has several major modes of operation:
<DL COMPACT>
<DT><B>Assemble</B>

<DD>
Assemble the components of a previously created
array into an active array.  Components can be explicitly given
or can be searched for.
<I>mdadm</I>

checks that the components
do form a bona fide array, and can, on request, fiddle superblock
information so as to assemble a faulty array.
<P>
<DT><B>Build</B>

<DD>
Build an array that doesn't have per-device metadata (superblocks).  For these
sorts of arrays,
<I>mdadm</I>

cannot differentiate between initial creation and subsequent assembly
of an array.  It also cannot perform any checks that appropriate
components have been requested.  Because of this, the
<B>Build</B>

mode should only be used together with a complete understanding of
what you are doing.
<P>
<DT><B>Create</B>

<DD>
Create a new array with per-device metadata (superblocks).
Appropriate metadata is written to each device, and then the array
comprising those devices is activated.  A 'resync' process is started
to make sure that the array is consistent (e.g. both sides of a mirror
contain the same data) but the content of the device is left otherwise
untouched.
The array can be used as soon as it has been created.  There is no
need to wait for the initial resync to finish.
<P>
<DT><B>Follow or Monitor</B>

<DD>
Monitor one or more md devices and act on any state changes.  This is
only meaningful for RAID1, 4, 5, 6, 10 or multipath arrays, as
only these have interesting state.  RAID0 or Linear never have
missing, spare, or failed drives, so there is nothing to monitor.
<P>
<DT><B>Grow</B>

<DD>
Grow (or shrink) an array, or otherwise reshape it in some way.
Currently supported growth options including changing the active size
of component devices and changing the number of active devices in
Linear and RAID levels 0/1/4/5/6,
changing the RAID level between 0, 1, 5, and 6, and between 0 and 10,
changing the chunk size and layout for RAID 0,4,5,6, as well as adding or
removing a write-intent bitmap.
<P>
<DT><B>Incremental Assembly</B>

<DD>
Add a single device to an appropriate array.  If the addition of the
device makes the array runnable, the array will be started.
This provides a convenient interface to a
<I>hot-plug</I>

system.  As each device is detected,
<I>mdadm</I>

has a chance to include it in some array as appropriate.
Optionally, when the
<I>--fail</I>

flag is passed in we will remove the device from any active array
instead of adding it.
<P>
If a
<B>CONTAINER</B>

is passed to
<I>mdadm</I>

in this mode, then any arrays within that container will be assembled
and started.
<P>
<DT><B>Manage</B>

<DD>
This is for doing things to specific components of an array such as
adding new spares and removing faulty devices.
<P>
<DT><B>Misc</B>

<DD>
This is an 'everything else' mode that supports operations on active
arrays, operations on component devices such as erasing old superblocks, and
information gathering operations.


<P>
<DT><B>Auto-detect</B>

<DD>
This mode does not act on a specific device or array, but rather it
requests the Linux Kernel to activate any auto-detected arrays.
</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>OPTIONS</H2>

<P>
<A NAME="lbAG">&nbsp;</A>
<H2>Options for selecting a mode are:</H2>

<P>
<DL COMPACT>
<DT><B>-A</B>, <B>--assemble</B>

<DD>
Assemble a pre-existing array.
<P>
<DT><B>-B</B>, <B>--build</B>

<DD>
Build a legacy array without superblocks.
<P>
<DT><B>-C</B>, <B>--create</B>

<DD>
Create a new array.
<P>
<DT><B>-F</B>, <B>--follow</B>, <B>--monitor</B>

<DD>
Select
<B>Monitor</B>

mode.
<P>
<DT><B>-G</B>, <B>--grow</B>

<DD>
Change the size or shape of an active array.
<P>
<DT><B>-I</B>, <B>--incremental</B>

<DD>
Add/remove a single device to/from an appropriate array, and possibly start the array.
<P>
<DT><B>--auto-detect</B>

<DD>
Request that the kernel starts any auto-detected arrays.  This can only
work if
<I>md</I>

is compiled into the kernel --- not if it is a module.
Arrays can be auto-detected by the kernel if all the components are in
primary MS-DOS partitions with partition type
<B>FD</B>,

and all use v0.90 metadata.
In-kernel autodetect is not recommended for new installations.  Using
<I>mdadm</I>

to detect and assemble arrays --- possibly in an
<I>initrd</I>

--- is substantially more flexible and should be preferred.
<P>

If a device is given before any options, or if the first option is
<B>--add</B>,

<B>--fail</B>,

or
<B>--remove</B>,

then the MANAGE mode is assumed.
Anything other than these will cause the
<B>Misc</B>

mode to be assumed.
<P>
</DL>
<A NAME="lbAH">&nbsp;</A>
<H2>Options that are not mode-specific are:</H2>

<P>
<DL COMPACT>
<DT><B>-h</B>, <B>--help</B>

<DD>
Display general help message or, after one of the above options, a
mode-specific help message.
<P>
<DT><B>--help-options</B>

<DD>
Display more detailed help about command line parsing and some commonly
used options.
<P>
<DT><B>-V</B>, <B>--version</B>

<DD>
Print version information for mdadm.
<P>
<DT><B>-v</B>, <B>--verbose</B>

<DD>
Be more verbose about what is happening.  This can be used twice to be
extra-verbose.
The extra verbosity currently only affects
<B>--detail --scan</B>

and
<B>--examine --scan</B>.

<P>
<DT><B>-q</B>, <B>--quiet</B>

<DD>
Avoid printing purely informative messages.  With this,
<I>mdadm</I>

will be silent unless there is something really important to report.
<P>
<DT><B>-f</B>, <B>--force</B>

<DD>
Be more forceful about certain operations.  See the various modes for
the exact meaning of this option in different contexts.
<P>
<DT><B>-c</B>, <B>--config=</B>

<DD>
Specify the config file.  Default is to use
<B>/etc/mdadm.conf</B>,

or if that is missing then
<B>/etc/mdadm/mdadm.conf</B>.

If the config file given is
<B>partitions</B>

then nothing will be read, but
<I>mdadm</I>

will act as though the config file contained exactly
<B>DEVICE partitions containers</B>

and will read
<B>/proc/partitions</B>

to find a list of devices to scan, and
<B>/proc/mdstat</B>

to find a list of containers to examine.
If the word
<B>none</B>

is given for the config file, then
<I>mdadm</I>

will act as though the config file were empty.
<P>
<DT><B>-s</B>, <B>--scan</B>

<DD>
Scan config file or
<B>/proc/mdstat</B>

for missing information.
In general, this option gives
<I>mdadm</I>

permission to get any missing information (like component devices,
array devices, array identities, and alert destination) from the
configuration file (see previous option);
one exception is MISC mode when using
<B>--detail</B>

or
<B>--stop,</B>

in which case
<B>--scan</B>

says to get a list of array devices from
<B>/proc/mdstat</B>.

<P>
<DT><B>-e</B>, <B>--metadata=</B>

<DD>
Declare the style of RAID metadata (superblock) to be used.  The
default is 1.2 for
<B>--create</B>,

and to guess for other operations.
The default can be overridden by setting the
<B>metadata</B>

value for the
<B>CREATE</B>

keyword in
<B>mdadm.conf</B>.

<P>
Options are:
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>0, 0.90, default<DD>

<DT>0, 0.90<DD>

Use the original 0.90 format superblock.  This format limits arrays to
28 component devices and limits component devices of levels 1 and
greater to 2 terabytes.  It is also possible for there to be confusion
about whether the superblock applies to a whole device or just the
last partition, if that partition starts on a 64K boundary.

<DT>1, 1.0, 1.1, 1.2<DD>

<DT>1, 1.0, 1.1, 1.2 default<DD>

Use the new version-1 format superblock.  This has fewer restrictions.
It can easily be moved between hosts with different endian-ness, and a
recovery operation can be checkpointed and restarted.  The different
sub-versions store the superblock at different locations on the
device, either at the end (for 1.0), at the start (for 1.1) or 4K from
the start (for 1.2).  &quot;1&quot; is equivalent to &quot;1.2&quot; (the commonly
preferred 1.x format).
<BR>&nbsp;&quot;default&quot;&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;&quot;1.2&quot;.
<DT>ddf<DD>
Use the &quot;Industry Standard&quot; DDF (Disk Data Format) format defined by
SNIA.
When creating a DDF array a
<B>CONTAINER</B>

will be created, and normal arrays can be created in that container.
<DT>imsm<DD>
Use the Intel(R) Matrix Storage Manager metadata format.  This creates a
<B>CONTAINER</B>

which is managed in a similar manner to DDF, and is supported by an
option-rom on some platforms:
<DT><DD>
<B><A HREF="http://www.intel.com/design/chipsets/matrixstorage_sb.htm">http://www.intel.com/design/chipsets/matrixstorage_sb.htm</A></B>

</DL>
<P>

</DL>

<P>
<DT><B>--homehost=</B>

<DD>
This will override any
<B>HOMEHOST</B>

setting in the config file and provides the identity of the host which
should be considered the home for any arrays.
<P>
When creating an array, the
<B>homehost</B>

will be recorded in the metadata.  For version-1 superblocks, it will
be prefixed to the array name.  For version-0.90 superblocks, part of
the SHA1 hash of the hostname will be stored in the later half of the
UUID.
<P>
When reporting information about an array, any array which is tagged
for the given homehost will be reported as such.
<P>
When using Auto-Assemble, only arrays tagged for the given homehost
will be allowed to use 'local' names (i.e. not ending in '_' followed
by a digit string).  See below under
<B>Auto Assembly</B>.

<P>
</DL>
<A NAME="lbAI">&nbsp;</A>
<H2>For create, build, or grow:</H2>

<P>
<DL COMPACT>
<DT><B>-n</B>, <B>--raid-devices=</B>

<DD>
Specify the number of active devices in the array.  This, plus the
number of spare devices (see below) must equal the number of
<I>component-devices</I>

(including &quot;<B>missing</B>&quot; devices)
that are listed on the command line for
<B>--create</B>.

Setting a value of 1 is probably
a mistake and so requires that
<B>--force</B>

be specified first.  A value of 1 will then be allowed for linear,
multipath, RAID0 and RAID1.  It is never allowed for RAID4, RAID5 or RAID6.
<BR>

This number can only be changed using
<B>--grow</B>

for RAID1, RAID4, RAID5 and RAID6 arrays, and only on kernels which provide
the necessary support.
<P>
<DT><B>-x</B>, <B>--spare-devices=</B>

<DD>
Specify the number of spare (eXtra) devices in the initial array.
Spares can also be added
and removed later.  The number of component devices listed
on the command line must equal the number of RAID devices plus the
number of spare devices.
<P>
<DT><B>-z</B>, <B>--size=</B>

<DD>
Amount (in Kibibytes) of space to use from each drive in RAID levels 1/4/5/6.
This must be a multiple of the chunk size, and must leave about 128Kb
of space at the end of the drive for the RAID superblock.
If this is not specified
(as it normally is not) the smallest drive (or partition) sets the
size, though if there is a variance among the drives of greater than 1%, a warning is
issued.
<P>
A suffix of 'M' or 'G' can be given to indicate Megabytes or
Gigabytes respectively.
<P>
Sometimes a replacement drive can be a little smaller than the
original drives though this should be minimised by IDEMA standards.
Such a replacement drive will be rejected by
<I>md</I>.

To guard against this it can be useful to set the initial size
slightly smaller than the smaller device with the aim that it will
still be larger than any replacement.
<P>
This value can be set with
<B>--grow</B>

for RAID level 1/4/5/6 though
<B>CONTAINER</B>

based arrays such as those with IMSM metadata may not be able to
support this.
If the array was created with a size smaller than the currently
active drives, the extra space can be accessed using
<B>--grow</B>.

The size can be given as
<B>max</B>

which means to choose the largest size that fits on all current drives.
<P>
Before reducing the size of the array (with
<B>--grow --size=</B>)

you should make sure that space isn't needed.  If the device holds a
filesystem, you would need to resize the filesystem to use less space.
<P>
After reducing the array size you should check that the data stored in
the device is still available.  If the device holds a filesystem, then
an 'fsck' of the filesystem is a minimum requirement.  If there are
problems the array can be made bigger again with no loss with another
<B>--grow --size=</B>

command.
<P>
This value cannot be used when creating a
<B>CONTAINER</B>

such as with DDF and IMSM metadata, though it perfectly valid when
creating an array inside a container.
<P>
<DT><B>-Z</B>, <B>--array-size=</B>

<DD>
This is only meaningful with
<B>--grow</B>

and its effect is not persistent: when the array is stopped and
restarted the default array size will be restored.
<P>
Setting the array-size causes the array to appear smaller to programs
that access the data.  This is particularly needed before reshaping an
array so that it will be smaller.  As the reshape is not reversible,
but setting the size with
<B>--array-size</B>

is, it is required that the array size is reduced as appropriate
before the number of devices in the array is reduced.
<P>
Before reducing the size of the array you should make sure that space
isn't needed.  If the device holds a filesystem, you would need to
resize the filesystem to use less space.
<P>
After reducing the array size you should check that the data stored in
the device is still available.  If the device holds a filesystem, then
an 'fsck' of the filesystem is a minimum requirement.  If there are
problems the array can be made bigger again with no loss with another
<B>--grow --array-size=</B>

command.
<P>
A suffix of 'M' or 'G' can be given to indicate Megabytes or
Gigabytes respectively.
A value of
<B>max</B>

restores the apparent size of the array to be whatever the real
amount of available space is.
<P>
<DT><B>-c</B>, <B>--chunk=</B>

<DD>
Specify chunk size of kibibytes.  The default when creating an
array is 512KB.  To ensure compatibility with earlier versions, the
default when Building and array with no persistent metadata is 64KB.
This is only meaningful for RAID0, RAID4, RAID5, RAID6, and RAID10.
<P>
RAID4, RAID5, RAID6, and RAID10 require the chunk size to be a power
of 2.  In any case it must be a multiple of 4KB.
<P>
A suffix of 'M' or 'G' can be given to indicate Megabytes or
Gigabytes respectively.
<P>
<DT><B>--rounding=</B>

<DD>
Specify rounding factor for a Linear array.  The size of each
component will be rounded down to a multiple of this size.
This is a synonym for
<B>--chunk</B>

but highlights the different meaning for Linear as compared to other
RAID levels.  The default is 64K if a kernel earlier than 2.6.16 is in
use, and is 0K (i.e. no rounding) in later kernels.
<P>
<DT><B>-l</B>, <B>--level=</B>

<DD>
Set RAID level.  When used with
<B>--create</B>,

options are: linear, raid0, 0, stripe, raid1, 1, mirror, raid4, 4,
raid5, 5, raid6, 6, raid10, 10, multipath, mp, faulty, container.
Obviously some of these are synonymous.
<P>
When a
<B>CONTAINER</B>

metadata type is requested, only the
<B>container</B>

level is permitted, and it does not need to be explicitly given.
<P>
When used with
<B>--build</B>,

only linear, stripe, raid0, 0, raid1, multipath, mp, and faulty are valid.
<P>
Can be used with
<B>--grow</B>

to change the RAID level in some cases.  See LEVEL CHANGES below.
<P>
<DT><B>-p</B>, <B>--layout=</B>

<DD>
This option configures the fine details of data layout for RAID5, RAID6,
and RAID10 arrays, and controls the failure modes for
<I>faulty</I>.

<P>
The layout of the RAID5 parity block can be one of
<B>left-asymmetric</B>,

<B>left-symmetric</B>,

<B>right-asymmetric</B>,

<B>right-symmetric</B>,

<B>la</B>, <B>ra</B>, <B>ls</B>, <B>rs</B>.

The default is
<B>left-symmetric</B>.

<P>
It is also possible to cause RAID5 to use a RAID4-like layout by
choosing
<B>parity-first</B>,

or
<B>parity-last</B>.

<P>
Finally for RAID5 there are DDF-compatible layouts,
<B>ddf-zero-restart</B>,

<B>ddf-N-restart</B>,

and
<B>ddf-N-continue</B>.

<P>
These same layouts are available for RAID6.  There are also 4 layouts
that will provide an intermediate stage for converting between RAID5
and RAID6.  These provide a layout which is identical to the
corresponding RAID5 layout on the first N-1 devices, and has the 'Q'
syndrome (the second 'parity' block used by RAID6) on the last device.
These layouts are:
<B>left-symmetric-6</B>,

<B>right-symmetric-6</B>,

<B>left-asymmetric-6</B>,

<B>right-asymmetric-6</B>,

and
<B>parity-first-6</B>.

<P>
When setting the failure mode for level
<I>faulty,</I>

the options are:
<B>write-transient</B>, <B>wt</B>,

<B>read-transient</B>, <B>rt</B>,

<B>write-persistent</B>, <B>wp</B>,

<B>read-persistent</B>, <B>rp</B>,

<B>write-all</B>,

<B>read-fixable</B>, <B>rf</B>,

<B>clear</B>, <B>flush</B>, <B>none</B>.

<P>
Each failure mode can be followed by a number, which is used as a period
between fault generation.  Without a number, the fault is generated
once on the first relevant request.  With a number, the fault will be
generated after that many requests, and will continue to be generated
every time the period elapses.
<P>
Multiple failure modes can be current simultaneously by using the
<B>--grow</B>

option to set subsequent failure modes.
<P>
&quot;clear&quot; or &quot;none&quot; will remove any pending or periodic failure modes,
and &quot;flush&quot; will clear any persistent faults.
<P>
Finally, the layout options for RAID10 are one of 'n', 'o' or 'f' followed
by a small number.  The default is 'n2'.  The supported options are:
<P>
<I>'n'</I>

signals 'near' copies.  Multiple copies of one data block are at
similar offsets in different devices.
<P>
<I>'o'</I>

signals 'offset' copies.  Rather than the chunks being duplicated
within a stripe, whole stripes are duplicated but are rotated by one
device so duplicate blocks are on different devices.  Thus subsequent
copies of a block are in the next drive, and are one chunk further
down.
<P>
<I>'f'</I>

signals 'far' copies
(multiple copies have very different offsets).
See <A HREF="/manpages/index.html?4+md">md</A>(4) for more detail about 'near', 'offset', and 'far'.
<P>
The number is the number of copies of each datablock.  2 is normal, 3
can be useful.  This number can be at most equal to the number of
devices in the array.  It does not need to divide evenly into that
number (e.g. it is perfectly legal to have an 'n2' layout for an array
with an odd number of devices).
<P>
When an array is converted between RAID5 and RAID6 an intermediate
RAID6 layout is used in which the second parity block (Q) is always on
the last device.  To convert a RAID5 to RAID6 and leave it in this new
layout (which does not require re-striping) use
<B>--layout=preserve</B>.

This will try to avoid any restriping.
<P>
The converse of this is
<B>--layout=normalise</B>

which will change a non-standard RAID6 layout into a more standard
arrangement.
<P>
<DT><B>--parity=</B>

<DD>
same as
<B>--layout</B>

(thus explaining the p of
<B>-p</B>).

<P>
<DT><B>-b</B>, <B>--bitmap=</B>

<DD>
Specify a file to store a write-intent bitmap in.  The file should not
exist unless
<B>--force</B>

is also given.  The same file should be provided
when assembling the array.  If the word
<B>internal</B>

is given, then the bitmap is stored with the metadata on the array,
and so is replicated on all devices.  If the word
<B>none</B>

is given with
<B>--grow</B>

mode, then any bitmap that is present is removed.
<P>
To help catch typing errors, the filename must contain at least one
slash ('/') if it is a real file (not 'internal' or 'none').
<P>
Note: external bitmaps are only known to work on ext2 and ext3.
Storing bitmap files on other filesystems may result in serious problems.
<P>
<DT><B>--bitmap-chunk=</B>

<DD>
Set the chunksize of the bitmap.  Each bit corresponds to that many
Kilobytes of storage.
When using a file based bitmap, the default is to use the smallest
size that is at-least 4 and requires no more than 2^21 chunks.
When using an
<B>internal</B>

bitmap, the chunksize defaults to 64Meg, or larger if necessary to
fit the bitmap into the available space.
<P>
A suffix of 'M' or 'G' can be given to indicate Megabytes or
Gigabytes respectively.
<P>
<DT><B>-W</B>, <B>--write-mostly</B>

<DD>
subsequent devices listed in a
<B>--build</B>,

<B>--create</B>,

or
<B>--add</B>

command will be flagged as 'write-mostly'.  This is valid for RAID1
only and means that the 'md' driver will avoid reading from these
devices if at all possible.  This can be useful if mirroring over a
slow link.
<P>
<DT><B>--write-behind=</B>

<DD>
Specify that write-behind mode should be enabled (valid for RAID1
only).  If an argument is specified, it will set the maximum number
of outstanding writes allowed.  The default value is 256.
A write-intent bitmap is required in order to use write-behind
mode, and write-behind is only attempted on drives marked as
<I>write-mostly</I>.

<P>
<DT><B>--assume-clean</B>

<DD>
Tell
<I>mdadm</I>

that the array pre-existed and is known to be clean.  It can be useful
when trying to recover from a major failure as you can be sure that no
data will be affected unless you actually write to the array.  It can
also be used when creating a RAID1 or RAID10 if you want to avoid the
initial resync, however this practice --- while normally safe --- is not
recommended.  Use this only if you really know what you are doing.
<DT><DD>
When the devices that will be part of a new array were filled
with zeros before creation the operator knows the array is
actually clean. If that is the case, such as after running
badblocks, this argument can be used to tell mdadm the
facts the operator knows.
<DT><DD>
When an array is resized to a larger size with
<B>--grow --size=</B>

the new space is normally resynced in that same way that the whole
array is resynced at creation.  From Linux version 3.0,
<B>--assume-clean</B>

can be used with that command to avoid the automatic resync.
<P>
<DT><B>--backup-file=</B>

<DD>
This is needed when
<B>--grow</B>

is used to increase the number of raid-devices in a RAID5 or RAID6 if
there are no spare devices available, or to shrink, change RAID level
or layout.  See the GROW MODE section below on RAID-DEVICES CHANGES.
The file must be stored on a separate device, not on the RAID array
being reshaped.
<P>
<DT><B>--continue</B>

<DD>
This option is complementary to the
<B>--freeze-reshape</B>

option for assembly. It is needed when
<B>--grow</B>

operation is interrupted and it is not restarted automatically due to
<B>--freeze-reshape</B>

usage during array assembly.  This option is used together with
<B>-G</B>

, (
<B>--grow</B>

) command and device for a pending reshape to be continued.
All parameters required for reshape continuation will be read from array metadata.
If initial
<B>--grow</B>

command had required
<B>--backup-file=</B>

option to be set, continuation option will require to have exactly the same
backup file given as well.
<DT><DD>
Any other parameter passed together with
<B>--continue</B>

option will be ignored.
<P>
<DT><B>-N</B>, <B>--name=</B>

<DD>
Set a
<B>name</B>

for the array.  This is currently only effective when creating an
array with a version-1 superblock, or an array in a DDF container.
The name is a simple textual string that can be used to identify array
components when assembling.  If name is needed but not specified, it
is taken from the basename of the device that is being created.
e.g. when creating
<I>/dev/md/home</I>

the
<B>name</B>

will default to
<I>home</I>.

<P>
<DT><B>-R</B>, <B>--run</B>

<DD>
Insist that
<I>mdadm</I>

run the array, even if some of the components
appear to be active in another array or filesystem.  Normally
<I>mdadm</I>

will ask for confirmation before including such components in an
array.  This option causes that question to be suppressed.
<P>
<DT><B>-f</B>, <B>--force</B>

<DD>
Insist that
<I>mdadm</I>

accept the geometry and layout specified without question.  Normally
<I>mdadm</I>

will not allow creation of an array with only one device, and will try
to create a RAID5 array with one missing drive (as this makes the
initial resync work faster).  With
<B>--force</B>,

<I>mdadm</I>

will not try to be so clever.
<P>
<DT><B>-a</B>, <B>--auto{=yes,md,mdp,part,p}{NN}</B>

<DD>
Instruct mdadm how to create the device file if needed, possibly allocating
an unused minor number.  &quot;md&quot; causes a non-partitionable array
to be used (though since Linux 2.6.28, these array devices are in fact
partitionable).  &quot;mdp&quot;, &quot;part&quot; or &quot;p&quot; causes a partitionable array (2.6 and
later) to be used.  &quot;yes&quot; requires the named md device to have
a 'standard' format, and the type and minor number will be determined
from this.  With mdadm 3.0, device creation is normally left up to
<I>udev</I>

so this option is unlikely to be needed.
See DEVICE NAMES below.
<P>
The argument can also come immediately after
&quot;-a&quot;.  e.g. &quot;-ap&quot;.
<P>
If
<B>--auto</B>

is not given on the command line or in the config file, then
the default will be
<B>--auto=yes</B>.

<P>
If
<B>--scan</B>

is also given, then any
<I>auto=</I>

entries in the config file will override the
<B>--auto</B>

instruction given on the command line.
<P>
For partitionable arrays,
<I>mdadm</I>

will create the device file for the whole array and for the first 4
partitions.  A different number of partitions can be specified at the
end of this option (e.g.
<B>--auto=p7</B>).

If the device name ends with a digit, the partition names add a 'p',
and a number, e.g.
<I>/dev/md/home1p3</I>.

If there is no trailing digit, then the partition names just have a
number added, e.g.
<I>/dev/md/scratch3</I>.

<P>
If the md device name is in a 'standard' format as described in DEVICE
NAMES, then it will be created, if necessary, with the appropriate
device number based on that name.  If the device name is not in one of these
formats, then a unused device number will be allocated.  The device
number will be considered unused if there is no active array for that
number, and there is no entry in /dev for that number and with a
non-standard name.  Names that are not in 'standard' format are only
allowed in &quot;/dev/md/&quot;.
<P>
This is meaningful with
<B>--create</B>

or
<B>--build</B>.

<P>

<P>
<DT><B>-a</B>, <B>--add</B>

<DD>
This option can be used in Grow mode in two cases.
<P>
If the target array is a Linear array, then
<B>--add</B>

can be used to add one or more devices to the array.  They
are simply catenated on to the end of the array.  Once added, the
devices cannot be removed.
<P>
If the
<B>--raid-disks</B>

option is being used to increase the number of devices in an array,
then
<B>--add</B>

can be used to add some extra devices to be included in the array.
In most cases this is not needed as the extra devices can be added as
spares first, and then the number of raid-disks can be changed.
However for RAID0, it is not possible to add spares.  So to increase
the number of devices in a RAID0, it is necessary to set the new
number of devices, and to add the new devices, in the same command.
<P>
</DL>
<A NAME="lbAJ">&nbsp;</A>
<H2>For assemble:</H2>

<P>
<DL COMPACT>
<DT><B>-u</B>, <B>--uuid=</B>

<DD>
uuid of array to assemble.  Devices which don't have this uuid are
excluded
<P>
<DT><B>-m</B>, <B>--super-minor=</B>

<DD>
Minor number of device that array was created for.  Devices which
don't have this minor number are excluded.  If you create an array as
/dev/md1, then all superblocks will contain the minor number 1, even if
the array is later assembled as /dev/md2.
<P>
Giving the literal word &quot;dev&quot; for
<B>--super-minor</B>

will cause
<I>mdadm</I>

to use the minor number of the md device that is being assembled.
e.g. when assembling
<B>/dev/md0</B>,

<B>--super-minor=dev</B>

will look for super blocks with a minor number of 0.
<P>
<B>--super-minor</B>

is only relevant for v0.90 metadata, and should not normally be used.
Using
<B>--uuid</B>

is much safer.
<P>
<DT><B>-N</B>, <B>--name=</B>

<DD>
Specify the name of the array to assemble.  This must be the name
that was specified when creating the array.  It must either match
the name stored in the superblock exactly, or it must match
with the current
<I>homehost</I>

prefixed to the start of the given name.
<P>
<DT><B>-f</B>, <B>--force</B>

<DD>
Assemble the array even if the metadata on some devices appears to be
out-of-date.  If
<I>mdadm</I>

cannot find enough working devices to start the array, but can find
some devices that are recorded as having failed, then it will mark
those devices as working so that the array can be started.
An array which requires
<B>--force</B>

to be started may contain data corruption.  Use it carefully.
<P>
<DT><B>-R</B>, <B>--run</B>

<DD>
Attempt to start the array even if fewer drives were given than were
present last time the array was active.  Normally if not all the
expected drives are found and
<B>--scan</B>

is not used, then the array will be assembled but not started.
With
<B>--run</B>

an attempt will be made to start it anyway.
<P>
<DT><B>--no-degraded</B>

<DD>
This is the reverse of
<B>--run</B>

in that it inhibits the startup of array unless all expected drives
are present.  This is only needed with
<B>--scan,</B>

and can be used if the physical connections to devices are
not as reliable as you would like.
<P>
<DT><B>-a</B>, <B>--auto{=no,yes,md,mdp,part}</B>

<DD>
See this option under Create and Build options.
<P>
<DT><B>-b</B>, <B>--bitmap=</B>

<DD>
Specify the bitmap file that was given when the array was created.  If
an array has an
<B>internal</B>

bitmap, there is no need to specify this when assembling the array.
<P>
<DT><B>--backup-file=</B>

<DD>
If
<B>--backup-file</B>

was used while reshaping an array (e.g. changing number of devices or
chunk size) and the system crashed during the critical section, then the same
<B>--backup-file</B>

must be presented to
<B>--assemble</B>

to allow possibly corrupted data to be restored, and the reshape
to be completed.
<P>
<DT><B>--invalid-backup</B>

<DD>
If the file needed for the above option is not available for any
reason an empty file can be given together with this option to
indicate that the backup file is invalid.  In this case the data that
was being rearranged at the time of the crash could be irrecoverably
lost, but the rest of the array may still be recoverable.  This option
should only be used as a last resort if there is no way to recover the
backup file.
<P>
<P>
<DT><B>-U</B>, <B>--update=</B>

<DD>
Update the superblock on each device while assembling the array.  The
argument given to this flag can be one of
<B>sparc2.2</B>,

<B>summaries</B>,

<B>uuid</B>,

<B>name</B>,

<B>homehost</B>,

<B>resync</B>,

<B>byteorder</B>,

<B>devicesize</B>,

<B>no-bitmap</B>,

or
<B>super-minor</B>.

<P>
The
<B>sparc2.2</B>

option will adjust the superblock of an array what was created on a Sparc
machine running a patched 2.2 Linux kernel.  This kernel got the
alignment of part of the superblock wrong.  You can use the
<B>--examine --sparc2.2</B>

option to
<I>mdadm</I>

to see what effect this would have.
<P>
The
<B>super-minor</B>

option will update the
<B>preferred minor</B>

field on each superblock to match the minor number of the array being
assembled.
This can be useful if
<B>--examine</B>

reports a different &quot;Preferred Minor&quot; to
<B>--detail</B>.

In some cases this update will be performed automatically
by the kernel driver.  In particular the update happens automatically
at the first write to an array with redundancy (RAID level 1 or
greater) on a 2.6 (or later) kernel.
<P>
The
<B>uuid</B>

option will change the uuid of the array.  If a UUID is given with the
<B>--uuid</B>

option that UUID will be used as a new UUID and will
<B>NOT</B>

be used to help identify the devices in the array.
If no
<B>--uuid</B>

is given, a random UUID is chosen.
<P>
The
<B>name</B>

option will change the
<I>name</I>

of the array as stored in the superblock.  This is only supported for
version-1 superblocks.
<P>
The
<B>homehost</B>

option will change the
<I>homehost</I>

as recorded in the superblock.  For version-0 superblocks, this is the
same as updating the UUID.
For version-1 superblocks, this involves updating the name.
<P>
The
<B>resync</B>

option will cause the array to be marked
<I>dirty</I>

meaning that any redundancy in the array (e.g. parity for RAID5,
copies for RAID1) may be incorrect.  This will cause the RAID system
to perform a &quot;resync&quot; pass to make sure that all redundant information
is correct.
<P>
The
<B>byteorder</B>

option allows arrays to be moved between machines with different
byte-order.
When assembling such an array for the first time after a move, giving
<B>--update=byteorder</B>

will cause
<I>mdadm</I>

to expect superblocks to have their byteorder reversed, and will
correct that order before assembling the array.  This is only valid
with original (Version 0.90) superblocks.
<P>
The
<B>summaries</B>

option will correct the summaries in the superblock.  That is the
counts of total, working, active, failed, and spare devices.
<P>
The
<B>devicesize</B>

option will rarely be of use.  It applies to version 1.1 and 1.2 metadata
only (where the metadata is at the start of the device) and is only
useful when the component device has changed size (typically become
larger).  The version 1 metadata records the amount of the device that
can be used to store data, so if a device in a version 1.1 or 1.2
array becomes larger, the metadata will still be visible, but the
extra space will not.  In this case it might be useful to assemble the
array with
<B>--update=devicesize</B>.

This will cause
<I>mdadm</I>

to determine the maximum usable amount of space on each device and
update the relevant field in the metadata.
<P>
The
<B>no-bitmap</B>

option can be used when an array has an internal bitmap which is
corrupt in some way so that assembling the array normally fails.  It
will cause any internal bitmap to be ignored.
<P>
<DT><B>--freeze-reshape</B>

<DD>
Option is intended to be used in start-up scripts during initrd boot phase.
When array under reshape is assembled during initrd phase, this option
stops reshape after reshape critical section is being restored. This happens
before file system pivot operation and avoids loss of file system context.
Losing file system context would cause reshape to be broken.
<P>
Reshape can be continued later using the
<B>--continue</B>

option for the grow command.
<P>
</DL>
<A NAME="lbAK">&nbsp;</A>
<H2>For Manage mode:</H2>

<P>
<DL COMPACT>
<DT><B>-t</B>, <B>--test</B>

<DD>
Unless a more serious error occurred,
<I>mdadm</I>

will exit with a status of 2 if no changes were made to the array and
0 if at least one change was made.
This can be useful when an indirect specifier such as
<B>missing</B>,

<B>detached</B>

or
<B>faulty</B>

is used in requesting an operation on the array.
<B>--test</B>

will report failure if these specifiers didn't find any match.
<P>
<DT><B>-a</B>, <B>--add</B>

<DD>
hot-add listed devices.
If a device appears to have recently been part of the array
(possibly it failed or was removed) the device is re-added as describe
in the next point.
If that fails or the device was never part of the array, the device is
added as a hot-spare.
If the array is degraded, it will immediately start to rebuild data
onto that spare.
<P>
Note that this and the following options are only meaningful on array
with redundancy.  They don't apply to RAID0 or Linear.
<P>
<DT><B>--re-add</B>

<DD>
re-add a device that was previous removed from an array.
If the metadata on the device reports that it is a member of the
array, and the slot that it used is still vacant, then the device will
be added back to the array in the same position.  This will normally
cause the data for that device to be recovered.  However based on the
event count on the device, the recovery may only require sections that
are flagged a write-intent bitmap to be recovered or may not require
any recovery at all.
<P>
When used on an array that has no metadata (i.e. it was built with
<B>--build)</B>

it will be assumed that bitmap-based recovery is enough to make the
device fully consistent with the array.
<P>
When
<B>--re-add</B>

can be accompanied by
<B>--update=devicesize</B>.

See the description of this option when used in Assemble mode for an
explanation of its use.
<P>
If the device name given is
<B>missing</B>

then mdadm will try to find any device that looks like it should be
part of the array but isn't and will try to re-add all such devices.
<P>
<DT><B>-r</B>, <B>--remove</B>

<DD>
remove listed devices.  They must not be active.  i.e. they should
be failed or spare devices.  As well as the name of a device file
(e.g.
<B>/dev/sda1</B>)

the words
<B>failed</B>

and
<B>detached</B>

can be given to
<B>--remove</B>.

The first causes all failed device to be removed.  The second causes
any device which is no longer connected to the system (i.e an 'open'
returns
<B>ENXIO</B>)

to be removed.  This will only succeed for devices that are spares or
have already been marked as failed.
<P>
<DT><B>-f</B>, <B>--fail</B>

<DD>
mark listed devices as faulty.
As well as the name of a device file, the word
<B>detached</B>

can be given.  This will cause any device that has been detached from
the system to be marked as failed.  It can then be removed.
<P>
<DT><B>--set-faulty</B>

<DD>
same as
<B>--fail</B>.

<P>
<DT><B>--write-mostly</B>

<DD>
Subsequent devices that are added or re-added will have the 'write-mostly'
flag set.  This is only valid for RAID1 and means that the 'md' driver
will avoid reading from these devices if possible.
<DT><B>--readwrite</B>

<DD>
Subsequent devices that are added or re-added will have the 'write-mostly'
flag cleared.
<P>

Each of these options requires that the first device listed is the array
to be acted upon, and the remainder are component devices to be added,
removed, marked as faulty, etc.  Several different operations can be
specified for different devices, e.g.

mdadm /dev/md0 --add /dev/sda1 --fail /dev/sdb1 --remove /dev/sdb1

Each operation applies to all devices listed until the next
operation.
<P>
If an array is using a write-intent bitmap, then devices which have
been removed can be re-added in a way that avoids a full
reconstruction but instead just updates the blocks that have changed
since the device was removed.  For arrays with persistent metadata
(superblocks) this is done automatically.  For arrays created with
<B>--build</B>

mdadm needs to be told that this device we removed recently with
<B>--re-add</B>.

<P>
Devices can only be removed from an array if they are not in active
use, i.e. that must be spares or failed devices.  To remove an active
device, it must first be marked as
<B>faulty.</B>

<P>
</DL>
<A NAME="lbAL">&nbsp;</A>
<H2>For Misc mode:</H2>

<P>
<DL COMPACT>
<DT><B>-Q</B>, <B>--query</B>

<DD>
Examine a device to see
(1) if it is an md device and (2) if it is a component of an md
array.
Information about what is discovered is presented.
<P>
<DT><B>-D</B>, <B>--detail</B>

<DD>
Print details of one or more md devices.
<P>
<DT><B>--detail-platform</B>

<DD>
Print details of the platform's RAID capabilities (firmware / hardware
topology) for a given metadata format.
<P>
<DT><B>-Y</B>, <B>--export</B>

<DD>
When used with
<B>--detail</B>

or
<B>--examine</B>,

output will be formatted as
<B>key=value</B>

pairs for easy import into the environment.
<P>
<DT><B>-E</B>, <B>--examine</B>

<DD>
Print contents of the metadata stored on the named device(s).
Note the contrast between
<B>--examine</B>

and
<B>--detail</B>.

<B>--examine</B>

applies to devices which are components of an array, while
<B>--detail</B>

applies to a whole array which is currently active.
<DT><B>--sparc2.2</B>

<DD>
If an array was created on a SPARC machine with a 2.2 Linux kernel
patched with RAID support, the superblock will have been created
incorrectly, or at least incompatibly with 2.4 and later kernels.
Using the
<B>--sparc2.2</B>

flag with
<B>--examine</B>

will fix the superblock before displaying it.  If this appears to do
the right thing, then the array can be successfully assembled using
<B>--assemble --update=sparc2.2</B>.

<P>
<DT><B>-X</B>, <B>--examine-bitmap</B>

<DD>
Report information about a bitmap file.
The argument is either an external bitmap file or an array component
in case of an internal bitmap.  Note that running this on an array
device (e.g.
<B>/dev/md0</B>)

does not report the bitmap for that array.
<P>
<DT><B>-R</B>, <B>--run</B>

<DD>
start a partially assembled array.  If
<B>--assemble</B>

did not find enough devices to fully start the array, it might leaving
it partially assembled.  If you wish, you can then use
<B>--run</B>

to start the array in degraded mode.
<P>
<DT><B>-S</B>, <B>--stop</B>

<DD>
deactivate array, releasing all resources.
<P>
<DT><B>-o</B>, <B>--readonly</B>

<DD>
mark array as readonly.
<P>
<DT><B>-w</B>, <B>--readwrite</B>

<DD>
mark array as readwrite.
<P>
<DT><B>--zero-superblock</B>

<DD>
If the device contains a valid md superblock, the block is
overwritten with zeros.  With
<B>--force</B>

the block where the superblock would be is overwritten even if it
doesn't appear to be valid.
<P>
<DT><B>--kill-subarray=</B>

<DD>
If the device is a container and the argument to --kill-subarray
specifies an inactive subarray in the container, then the subarray is
deleted.  Deleting all subarrays will leave an 'empty-container' or
spare superblock on the drives.  See --zero-superblock for completely
removing a superblock.  Note that some formats depend on the subarray
index for generating a UUID, this command will fail if it would change
the UUID of an active subarray.
<P>
<DT><B>--update-subarray=</B>

<DD>
If the device is a container and the argument to --update-subarray
specifies a subarray in the container, then attempt to update the given
superblock field in the subarray. See below in
<B>MISC MODE</B>

for details.
<P>
<DT><B>-t</B>, <B>--test</B>

<DD>
When used with
<B>--detail</B>,

the exit status of
<I>mdadm</I>

is set to reflect the status of the device.  See below in
<B>MISC MODE</B>

for details.
<P>
<DT><B>-W</B>, <B>--wait</B>

<DD>
For each md device given, wait for any resync, recovery, or reshape
activity to finish before returning.
<I>mdadm</I>

will return with success if it actually waited for every device
listed, otherwise it will return failure.
<P>
<DT><B>--wait-clean</B>

<DD>
For each md device given, or each device in /proc/mdstat if
<B>--scan</B>

is given, arrange for the array to be marked clean as soon as possible.
<I>mdadm</I>

will return with success if the array uses external metadata and we
successfully waited.  For native arrays this returns immediately as the
kernel handles dirty-clean transitions at shutdown.  No action is taken
if safe-mode handling is disabled.
<P>
</DL>
<A NAME="lbAM">&nbsp;</A>
<H2>For Incremental Assembly mode:</H2>

<DL COMPACT>
<DT><B>--rebuild-map</B>, <B>-r</B>

<DD>
Rebuild the map file
(<B>/var/run/mdadm/map</B>)

that
<I>mdadm</I>

uses to help track which arrays are currently being assembled.
<P>
<DT><B>--run</B>, <B>-R</B>

<DD>
Run any array assembled as soon as a minimal number of devices are
available, rather than waiting until all expected devices are present.
<P>
<DT><B>--scan</B>, <B>-s</B>

<DD>
Only meaningful with
<B>-R</B>

this will scan the
<B>map</B>

file for arrays that are being incrementally assembled and will try to
start any that are not already started.  If any such array is listed
in
<B>mdadm.conf</B>

as requiring an external bitmap, that bitmap will be attached first.
<P>
<DT><B>--fail</B>, <B>-f</B>

<DD>
This allows the hot-plug system to remove devices that have fully disappeared
from the kernel.  It will first fail and then remove the device from any
array it belongs to.
The device name given should be a kernel device name such as &quot;sda&quot;,
not a name in
<I>/dev</I>.

<P>
<DT><B>--path=</B>

<DD>
Only used with --fail.  The 'path' given will be recorded so that if
a new device appears at the same location it can be automatically
added to the same array.  This allows the failed device to be
automatically replaced by a new device without metadata if it appears
at specified path.   This option is normally only set by a
<I>udev</I>

script.
<P>
</DL>
<A NAME="lbAN">&nbsp;</A>
<H2>For Monitor mode:</H2>

<DL COMPACT>
<DT><B>-m</B>, <B>--mail</B>

<DD>
Give a mail address to send alerts to.
<P>
<DT><B>-p</B>, <B>--program</B>, <B>--alert</B>

<DD>
Give a program to be run whenever an event is detected.
<P>
<DT><B>-y</B>, <B>--syslog</B>

<DD>
Cause all events to be reported through 'syslog'.  The messages have
facility of 'daemon' and varying priorities.
<P>
<DT><B>-d</B>, <B>--delay</B>

<DD>
Give a delay in seconds.
<I>mdadm</I>

polls the md arrays and then waits this many seconds before polling
again.  The default is 60 seconds.  Since 2.6.16, there is no need to
reduce this as the kernel alerts
<I>mdadm</I>

immediately when there is any change.
<P>
<DT><B>-r</B>, <B>--increment</B>

<DD>
Give a percentage increment.
<I>mdadm</I>

will generate RebuildNN events with the given percentage increment.
<P>
<DT><B>-f</B>, <B>--daemonise</B>

<DD>
Tell
<I>mdadm</I>

to run as a background daemon if it decides to monitor anything.  This
causes it to fork and run in the child, and to disconnect from the
terminal.  The process id of the child is written to stdout.
This is useful with
<B>--scan</B>

which will only continue monitoring if a mail address or alert program
is found in the config file.
<P>
<DT><B>-i</B>, <B>--pid-file</B>

<DD>
When
<I>mdadm</I>

is running in daemon mode, write the pid of the daemon process to
the specified file, instead of printing it on standard output.
<P>
<DT><B>-1</B>, <B>--oneshot</B>

<DD>
Check arrays only once.  This will generate
<B>NewArray</B>

events and more significantly
<B>DegradedArray</B>

and
<B>SparesMissing</B>

events.  Running

<B>   mdadm --monitor --scan -1</B>


from a cron script will ensure regular notification of any degraded arrays.
<P>
<DT><B>-t</B>, <B>--test</B>

<DD>
Generate a
<B>TestMessage</B>

alert for every array found at startup.  This alert gets mailed and
passed to the alert program.  This can be used for testing that alert
message do get through successfully.
<P>
<DT><B>--no-sharing</B>

<DD>
This inhibits the functionality for moving spares between arrays.
Only one monitoring process started with
<B>--scan</B>

but without this flag is allowed, otherwise the two could interfere
with each other.
<P>
</DL>
<A NAME="lbAO">&nbsp;</A>
<H2>ASSEMBLE MODE</H2>

<P>
<DL COMPACT>
<DT>
<DD>Usage:
<B>mdadm --assemble</B>

<I>md-device options-and-component-devices...</I>

<DT>
<DD>Usage:
<B>mdadm --assemble --scan</B>

<I>md-devices-and-options...</I>

<DT>
<DD>Usage:
<B>mdadm --assemble --scan</B>

<I>options...</I>

<P>
</DL>
<P>

This usage assembles one or more RAID arrays from pre-existing components.
For each array, mdadm needs to know the md device, the identity of the
array, and a number of component-devices.  These can be found in a number of ways.
<P>
In the first usage example (without the
<B>--scan</B>)

the first device given is the md device.
In the second usage example, all devices listed are treated as md
devices and assembly is attempted.
In the third (where no devices are listed) all md devices that are
listed in the configuration file are assembled.  If no arrays are
described by the configuration file, then any arrays that
can be found on unused devices will be assembled.
<P>
If precisely one device is listed, but
<B>--scan</B>

is not given, then
<I>mdadm</I>

acts as though
<B>--scan</B>

was given and identity information is extracted from the configuration file.
<P>
The identity can be given with the
<B>--uuid</B>

option, the
<B>--name</B>

option, or the
<B>--super-minor</B>

option, will be taken from the md-device record in the config file, or
will be taken from the super block of the first component-device
listed on the command line.
<P>
Devices can be given on the
<B>--assemble</B>

command line or in the config file.  Only devices which have an md
superblock which contains the right identity will be considered for
any array.
<P>
The config file is only used if explicitly named with
<B>--config</B>

or requested with (a possibly implicit)
<B>--scan</B>.

In the later case,
<B>/etc/mdadm.conf</B>

or
<B>/etc/mdadm/mdadm.conf</B>

is used.
<P>
If
<B>--scan</B>

is not given, then the config file will only be used to find the
identity of md arrays.
<P>
Normally the array will be started after it is assembled.  However if
<B>--scan</B>

is not given and not all expected drives were listed, then the array
is not started (to guard against usage errors).  To insist that the
array be started in this case (as may work for RAID1, 4, 5, 6, or 10),
give the
<B>--run</B>

flag.
<P>
If
<I>udev</I>

is active,
<I>mdadm</I>

does not create any entries in
<B>/dev</B>

but leaves that to
<I>udev</I>.

It does record information in
<B>/var/run/mdadm/map</B>

which will allow
<I>udev</I>

to choose the correct name.
<P>
If
<I>mdadm</I>

detects that udev is not configured, it will create the devices in
<B>/dev</B>

itself.
<P>
In Linux kernels prior to version 2.6.28 there were two distinctly
different types of md devices that could be created: one that could be
partitioned using standard partitioning tools and one that could not.
Since 2.6.28 that distinction is no longer relevant as both type of
devices can be partitioned.
<I>mdadm</I>

will normally create the type that originally could not be partitioned
as it has a well defined major number (9).
<P>
Prior to 2.6.28, it is important that mdadm chooses the correct type
of array device to use.  This can be controlled with the
<B>--auto</B>

option.  In particular, a value of &quot;mdp&quot; or &quot;part&quot; or &quot;p&quot; tells mdadm
to use a partitionable device rather than the default.
<P>
In the no-udev case, the value given to
<B>--auto</B>

can be suffixed by a number.  This tells
<I>mdadm</I>

to create that number of partition devices rather than the default of 4.
<P>
The value given to
<B>--auto</B>

can also be given in the configuration file as a word starting
<B>auto=</B>

on the ARRAY line for the relevant array.
<P>
<A NAME="lbAP">&nbsp;</A>
<H3>Auto Assembly</H3>

When
<B>--assemble</B>

is used with
<B>--scan</B>

and no devices are listed,
<I>mdadm</I>

will first attempt to assemble all the arrays listed in the config
file.
<P>
If no arrays are listed in the config (other than those marked
<B>&lt;ignore&gt;</B>)

it will look through the available devices for possible arrays and
will try to assemble anything that it finds.  Arrays which are tagged
as belonging to the given homehost will be assembled and started
normally.  Arrays which do not obviously belong to this host are given
names that are expected not to conflict with anything local, and are
started &quot;read-auto&quot; so that nothing is written to any device until the
array is written to. i.e.  automatic resync etc is delayed.
<P>
If
<I>mdadm</I>

finds a consistent set of devices that look like they should comprise
an array, and if the superblock is tagged as belonging to the given
home host, it will automatically choose a device name and try to
assemble the array.  If the array uses version-0.90 metadata, then the
<B>minor</B>

number as recorded in the superblock is used to create a name in
<B>/dev/md/</B>

so for example
<B>/dev/md/3</B>.

If the array uses version-1 metadata, then the
<B>name</B>

from the superblock is used to similarly create a name in
<B>/dev/md/</B>

(the name will have any 'host' prefix stripped first).
<P>
This behaviour can be modified by the
<I>AUTO</I>

line in the
<I>mdadm.conf</I>

configuration file.  This line can indicate that specific metadata
type should, or should not, be automatically assembled.  If an array
is found which is not listed in
<I>mdadm.conf</I>

and has a metadata format that is denied by the
<I>AUTO</I>

line, then it will not be assembled.
The
<I>AUTO</I>

line can also request that all arrays identified as being for this
homehost should be assembled regardless of their metadata type.
See
<I><A HREF="/manpages/index.html?5+mdadm.conf">mdadm.conf</A></I>(5)

for further details.
<P>
Note: Auto assembly cannot be used for assembling and activating some
arrays which are undergoing reshape.  In particular as the
<B>backup-file</B>

cannot be given, any reshape which requires a backup-file to continue
cannot be started by auto assembly.  An array which is growing to more
devices and has passed the critical section can be assembled using
auto-assembly.
<P>
<A NAME="lbAQ">&nbsp;</A>
<H2>BUILD MODE</H2>

<P>
<DL COMPACT>
<DT>
<DD>Usage:
<B>mdadm --build</B>

<I>md-device</I>

<B>--chunk=</B><I>X</I>

<B>--level=</B><I>Y</I>

<B>--raid-devices=</B><I>Z</I>

<I>devices</I>

<P>
</DL>
<P>

This usage is similar to
<B>--create</B>.

The difference is that it creates an array without a superblock.  With
these arrays there is no difference between initially creating the array and
subsequently assembling the array, except that hopefully there is useful
data there in the second case.
<P>
The level may raid0, linear, raid1, raid10, multipath, or faulty, or
one of their synonyms.  All devices must be listed and the array will
be started once complete.  It will often be appropriate to use
<B>--assume-clean</B>

with levels raid1 or raid10.
<P>
<A NAME="lbAR">&nbsp;</A>
<H2>CREATE MODE</H2>

<P>
<DL COMPACT>
<DT>
<DD>Usage:
<B>mdadm --create</B>

<I>md-device</I>

<B>--chunk=</B><I>X</I>

<B>--level=</B><I>Y</I>

<BR>

<B>--raid-devices=</B><I>Z</I>

<I>devices</I>

<P>
</DL>
<P>

This usage will initialise a new md array, associate some devices with
it, and activate the array.
<P>
The named device will normally not exist when
<I>mdadm --create</I>

is run, but will be created by
<I>udev</I>

once the array becomes active.
<P>
As devices are added, they are checked to see if they contain RAID
superblocks or filesystems.  They are also checked to see if the variance in
device size exceeds 1%.
<P>
If any discrepancy is found, the array will not automatically be run, though
the presence of a
<B>--run</B>

can override this caution.
<P>
To create a &quot;degraded&quot; array in which some devices are missing, simply
give the word &quot;<B>missing</B>&quot;
in place of a device name.  This will cause
<I>mdadm</I>

to leave the corresponding slot in the array empty.
For a RAID4 or RAID5 array at most one slot can be
&quot;<B>missing</B>&quot;; for a RAID6 array at most two slots.
For a RAID1 array, only one real device needs to be given.  All of the
others can be
&quot;<B>missing</B>&quot;.
<P>
When creating a RAID5 array,
<I>mdadm</I>

will automatically create a degraded array with an extra spare drive.
This is because building the spare into a degraded array is in general
faster than resyncing the parity on a non-degraded, but not clean,
array.  This feature can be overridden with the
<B>--force</B>

option.
<P>
When creating an array with version-1 metadata a name for the array is
required.
If this is not given with the
<B>--name</B>

option,
<I>mdadm</I>

will choose a name based on the last component of the name of the
device being created.  So if
<B>/dev/md3</B>

is being created, then the name
<B>3</B>

will be chosen.
If
<B>/dev/md/home</B>

is being created, then the name
<B>home</B>

will be used.
<P>
When creating a partition based array, using
<I>mdadm</I>

with version-1.x metadata, the partition type should be set to
<B>0xDA</B>

(non fs-data).  This type selection allows for greater precision since
using any other [RAID auto-detect (0xFD) or a GNU/Linux partition (0x83)],
might create problems in the event of array recovery through a live cdrom.
<P>
A new array will normally get a randomly assigned 128bit UUID which is
very likely to be unique.  If you have a specific need, you can choose
a UUID for the array by giving the
<B>--uuid=</B>

option.  Be warned that creating two arrays with the same UUID is a
recipe for disaster.  Also, using
<B>--uuid=</B>

when creating a v0.90 array will silently override any
<B>--homehost=</B>

setting.








<P>
When creating an array within a
<B>CONTAINER</B>

<I>mdadm</I>

can be given either the list of devices to use, or simply the name of
the container.  The former case gives control over which devices in
the container will be used for the array.  The latter case allows
<I>mdadm</I>

to automatically choose which devices to use based on how much spare
space is available.
<P>
The General Management options that are valid with
<B>--create</B>

are:
<DL COMPACT>
<DT><B>--run</B>

<DD>
insist on running the array even if some devices look like they might
be in use.
<P>
<DT><B>--readonly</B>

<DD>
start the array readonly --- not supported yet.
<P>
</DL>
<A NAME="lbAS">&nbsp;</A>
<H2>MANAGE MODE</H2>

<DL COMPACT>
<DT>
<DD>Usage:
<B>mdadm</B>

<I>device</I>

<I>options... devices...</I>

</DL>
<P>

<P>
This usage will allow individual devices in an array to be failed,
removed or added.  It is possible to perform multiple operations with
on command.  For example:
<BR>

<B>  mdadm /dev/md0 -f /dev/hda1 -r /dev/hda1 -a /dev/hda1</B>

<BR>

will firstly mark
<B>/dev/hda1</B>

as faulty in
<B>/dev/md0</B>

and will then remove it from the array and finally add it back
in as a spare.  However only one md array can be affected by a single
command.
<P>
When a device is added to an active array, mdadm checks to see if it
has metadata on it which suggests that it was recently a member of the
array.  If it does, it tries to &quot;re-add&quot; the device.  If there have
been no changes since the device was removed, or if the array has a
write-intent bitmap which has recorded whatever changes there were,
then the device will immediately become a full member of the array and
those differences recorded in the bitmap will be resolved.
<P>
<A NAME="lbAT">&nbsp;</A>
<H2>MISC MODE</H2>

<DL COMPACT>
<DT>
<DD>Usage:
<B>mdadm</B>

<I>options ...</I>

<I>devices ...</I>

</DL>
<P>

<P>
MISC mode includes a number of distinct operations that
operate on distinct devices.  The operations are:
<DL COMPACT>
<DT><B>--query</B>

<DD>
The device is examined to see if it is
(1) an active md array, or
(2) a component of an md array.
The information discovered is reported.
<P>
<DT><B>--detail</B>

<DD>
The device should be an active md device.
<B>mdadm</B>

will display a detailed description of the array.
<B>--brief</B>

or
<B>--scan</B>

will cause the output to be less detailed and the format to be
suitable for inclusion in
<B>mdadm.conf</B>.

The exit status of
<I>mdadm</I>

will normally be 0 unless
<I>mdadm</I>

failed to get useful information about the device(s); however, if the
<B>--test</B>

option is given, then the exit status will be:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>0<DD>
The array is functioning normally.
<DT>1<DD>
The array has at least one failed device.
<DT>2<DD>
The array has multiple failed devices such that it is unusable.
<DT>4<DD>
There was an error while trying to get information about the device.
</DL>
</DL>

<P>
<DT><B>--detail-platform</B>

<DD>
Print detail of the platform's RAID capabilities (firmware / hardware
topology).  If the metadata is specified with
<B>-e</B>

or
<B>--metadata=</B>

then the return status will be:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>0<DD>
metadata successfully enumerated its platform components on this system
<DT>1<DD>
metadata is platform independent
<DT>2<DD>
metadata failed to find its platform components on this system
</DL>
</DL>

<P>
<DT><B>--update-subarray=</B>

<DD>
If the device is a container and the argument to --update-subarray
specifies a subarray in the container, then attempt to update the given
superblock field in the subarray.  Similar to updating an array in
&quot;assemble&quot; mode, the field to update is selected by
<B>-U</B>

or
<B>--update=</B>

option.  Currently only
<B>name</B>

is supported.
<P>
The 
<B>name</B>

option updates the subarray name in the metadata, it may not affect the
device node name or the device node symlink until the subarray is
re-assembled.  If updating 
<B>name</B>

would change the UUID of an active subarray this operation is blocked,
and the command will end in an error.
<P>
<DT><B>--examine</B>

<DD>
The device should be a component of an md array.
<I>mdadm</I>

will read the md superblock of the device and display the contents.
If
<B>--brief</B>

or
<B>--scan</B>

is given, then multiple devices that are components of the one array
are grouped together and reported in a single entry suitable
for inclusion in
<B>mdadm.conf</B>.

<P>
Having
<B>--scan</B>

without listing any devices will cause all devices listed in the
config file to be examined.
<P>
<DT><B>--stop</B>

<DD>
The devices should be active md arrays which will be deactivated, as
long as they are not currently in use.
<P>
<DT><B>--run</B>

<DD>
This will fully activate a partially assembled md array.
<P>
<DT><B>--readonly</B>

<DD>
This will mark an active array as read-only, providing that it is
not currently being used.
<P>
<DT><B>--readwrite</B>

<DD>
This will change a
<B>readonly</B>

array back to being read/write.
<P>
<DT><B>--scan</B>

<DD>
For all operations except
<B>--examine</B>,

<B>--scan</B>

will cause the operation to be applied to all arrays listed in
<B>/proc/mdstat</B>.

For
<B>--examine,</B>

<B>--scan</B>

causes all devices listed in the config file to be examined.
<P>
<DT><B>-b</B>, <B>--brief</B>

<DD>
Be less verbose.  This is used with
<B>--detail</B>

and
<B>--examine</B>.

Using
<B>--brief</B>

with
<B>--verbose</B>

gives an intermediate level of verbosity.
<P>
</DL>
<A NAME="lbAU">&nbsp;</A>
<H2>MONITOR MODE</H2>

<P>
<DL COMPACT>
<DT>
<DD>Usage:
<B>mdadm --monitor</B>

<I>options... devices...</I>

<P>
</DL>
<P>

This usage causes
<I>mdadm</I>

to periodically poll a number of md arrays and to report on any events
noticed.
<I>mdadm</I>

will never exit once it decides that there are arrays to be checked,
so it should normally be run in the background.
<P>
As well as reporting events,
<I>mdadm</I>

may move a spare drive from one array to another if they are in the
same
<B>spare-group</B>

or
<B>domain</B>

and if the destination array has a failed drive but no spares.
<P>
If any devices are listed on the command line,
<I>mdadm</I>

will only monitor those devices.  Otherwise all arrays listed in the
configuration file will be monitored.  Further, if
<B>--scan</B>

is given, then any other md devices that appear in
<B>/proc/mdstat</B>

will also be monitored.
<P>
The result of monitoring the arrays is the generation of events.
These events are passed to a separate program (if specified) and may
be mailed to a given E-mail address.
<P>
When passing events to a program, the program is run once for each event,
and is given 2 or 3 command-line arguments: the first is the
name of the event (see below), the second is the name of the
md device which is affected, and the third is the name of a related
device if relevant (such as a component device that has failed).
<P>
If
<B>--scan</B>

is given, then a program or an E-mail address must be specified on the
command line or in the config file.  If neither are available, then
<I>mdadm</I>

will not monitor anything.
Without
<B>--scan,</B>

<I>mdadm</I>

will continue monitoring as long as something was found to monitor.  If
no program or email is given, then each event is reported to
<B>stdout</B>.

<P>
The different events are:
<P>
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>DeviceDisappeared</B>

<DD>
An md array which previously was configured appears to no longer be
configured. (syslog priority: Critical)
<P>
If
<I>mdadm</I>

was told to monitor an array which is RAID0 or Linear, then it will
report
<B>DeviceDisappeared</B>

with the extra information
<B>Wrong-Level</B>.

This is because RAID0 and Linear do not support the device-failed,
hot-spare and resync operations which are monitored.
<P>
<DT><B>RebuildStarted</B>

<DD>
An md array started reconstruction. (syslog priority: Warning)
<P>
<DT><B>Rebuild</B><I>NN</I>

<DD>
Where
<I>NN</I>

is a two-digit number (ie. 05, 48). This indicates that rebuild
has passed that many percent of the total. The events are generated
with fixed increment since 0. Increment size may be specified with
a commandline option (default is 20). (syslog priority: Warning)
<P>
<DT><B>RebuildFinished</B>

<DD>
An md array that was rebuilding, isn't any more, either because it
finished normally or was aborted. (syslog priority: Warning)
<P>
<DT><B>Fail</B>

<DD>
An active component device of an array has been marked as
faulty. (syslog priority: Critical)
<P>
<DT><B>FailSpare</B>

<DD>
A spare component device which was being rebuilt to replace a faulty
device has failed. (syslog priority: Critical)
<P>
<DT><B>SpareActive</B>

<DD>
A spare component device which was being rebuilt to replace a faulty
device has been successfully rebuilt and has been made active.
(syslog priority: Info)
<P>
<DT><B>NewArray</B>

<DD>
A new md array has been detected in the
<B>/proc/mdstat</B>

file.  (syslog priority: Info)
<P>
<DT><B>DegradedArray</B>

<DD>
A newly noticed array appears to be degraded.  This message is not
generated when
<I>mdadm</I>

notices a drive failure which causes degradation, but only when
<I>mdadm</I>

notices that an array is degraded when it first sees the array.
(syslog priority: Critical)
<P>
<DT><B>MoveSpare</B>

<DD>
A spare drive has been moved from one array in a
<B>spare-group</B>

or
<B>domain</B>

to another to allow a failed drive to be replaced.
(syslog priority: Info)
<P>
<DT><B>SparesMissing</B>

<DD>
If
<I>mdadm</I>

has been told, via the config file, that an array should have a certain
number of spare devices, and
<I>mdadm</I>

detects that it has fewer than this number when it first sees the
array, it will report a
<B>SparesMissing</B>

message.
(syslog priority: Warning)
<P>
<DT><B>TestMessage</B>

<DD>
An array was found at startup, and the
<B>--test</B>

flag was given.
(syslog priority: Info)
</DL>
</DL>

<P>
Only
<B>Fail,</B>

<B>FailSpare,</B>

<B>DegradedArray,</B>

<B>SparesMissing</B>

and
<B>TestMessage</B>

cause Email to be sent.  All events cause the program to be run.
The program is run with two or three arguments: the event
name, the array device and possibly a second device.
<P>
Each event has an associated array device (e.g.
<B>/dev/md1</B>)

and possibly a second device.  For
<B>Fail</B>,

<B>FailSpare</B>,

and
<B>SpareActive</B>

the second device is the relevant component device.
For
<B>MoveSpare</B>

the second device is the array that the spare was moved from.
<P>
For
<I>mdadm</I>

to move spares from one array to another, the different arrays need to
be labeled with the same
<B>spare-group</B>

or the spares must be allowed to migrate through matching POLICY domains
in the configuration file.  The
<B>spare-group</B>

name can be any string; it is only necessary that different spare
groups use different names.
<P>
When
<I>mdadm</I>

detects that an array in a spare group has fewer active
devices than necessary for the complete array, and has no spare
devices, it will look for another array in the same spare group that
has a full complement of working drive and a spare.  It will then
attempt to remove the spare from the second drive and add it to the
first.
If the removal succeeds but the adding fails, then it is added back to
the original array.
<P>
If the spare group for a degraded array is not defined,
<I>mdadm</I>

will look at the rules of spare migration specified by POLICY lines in
<B>mdadm.conf</B>

and then follow similar steps as above if a matching spare is found.
<P>
<A NAME="lbAV">&nbsp;</A>
<H2>GROW MODE</H2>

The GROW mode is used for changing the size or shape of an active
array.
For this to work, the kernel must support the necessary change.
Various types of growth are being added during 2.6 development.
<P>
Currently the supported changes include
<DL COMPACT>
<DT>*<DD>
change the &quot;size&quot; attribute for RAID1, RAID4, RAID5 and RAID6.
<DT>*<DD>
increase or decrease the &quot;raid-devices&quot; attribute of RAID0, RAID1, RAID4,
RAID5, and RAID6.
<DT>*<DD>
change the chunk-size and layout of RAID0, RAID4, RAID5 and RAID6.
<DT>*<DD>
convert between RAID1 and RAID5, between RAID5 and RAID6, between
RAID0, RAID4, and RAID5, and between RAID0 and RAID10 (in the near-2 mode).
<DT>*<DD>
add a write-intent bitmap to any array which supports these bitmaps, or
remove a write-intent bitmap from such an array.
</DL>
<P>

<P>
Using GROW on containers is currently supported only for Intel's IMSM
container format.  The number of devices in a container can be
increased - which affects all arrays in the container - or an array
in a container can be converted between levels where those levels are
supported by the container, and the conversion is on of those listed
above.  Resizing arrays in an IMSM container with
<B>--grow --size</B>

is not yet supported.
<P>
Grow functionality (e.g. expand a number of raid devices) for Intel's
IMSM container format has an experimental status. It is guarded by the
<B>MDADM_EXPERIMENTAL</B>

environment variable which must be set to '1' for a GROW command to
succeed.
This is for the following reasons:
<P>
<DL COMPACT>
<DT>1.<DD>
Intel's native IMSM check-pointing is not fully tested yet.
This can causes IMSM incompatibility during the grow process: an array
which is growing cannot roam between Microsoft Windows(R) and Linux
systems.
<P>
<DT>2.<DD>
Interrupting a grow operation is not recommended, because it
has not been fully tested for Intel's IMSM container format yet.
<P>
</DL>
<P>

Note: Intel's native checkpointing doesn't use
<B>--backup-file</B>

option and it is transparent for assembly feature.
<P>
<A NAME="lbAW">&nbsp;</A>
<H3>SIZE CHANGES</H3>

Normally when an array is built the &quot;size&quot; is taken from the smallest
of the drives.  If all the small drives in an arrays are, one at a
time, removed and replaced with larger drives, then you could have an
array of large drives with only a small amount used.  In this
situation, changing the &quot;size&quot; with &quot;GROW&quot; mode will allow the extra
space to start being used.  If the size is increased in this way, a
&quot;resync&quot; process will start to make sure the new parts of the array
are synchronised.
<P>
Note that when an array changes size, any filesystem that may be
stored in the array will not automatically grow or shrink to use or
vacate the space.  The
filesystem will need to be explicitly told to use the extra space
after growing, or to reduce its size
<B>prior</B>

to shrinking the array.
<P>
Also the size of an array cannot be changed while it has an active
bitmap.  If an array has a bitmap, it must be removed before the size
can be changed. Once the change is complete a new bitmap can be created.
<P>
<A NAME="lbAX">&nbsp;</A>
<H3>RAID-DEVICES CHANGES</H3>

<P>
A RAID1 array can work with any number of devices from 1 upwards
(though 1 is not very useful).  There may be times which you want to
increase or decrease the number of active devices.  Note that this is
different to hot-add or hot-remove which changes the number of
inactive devices.
<P>
When reducing the number of devices in a RAID1 array, the slots which
are to be removed from the array must already be vacant.  That is, the
devices which were in those slots must be failed and removed.
<P>
When the number of devices is increased, any hot spares that are
present will be activated immediately.
<P>
Changing the number of active devices in a RAID5 or RAID6 is much more
effort.  Every block in the array will need to be read and written
back to a new location.  From 2.6.17, the Linux Kernel is able to
increase the number of devices in a RAID5 safely, including restarting
an interrupted &quot;reshape&quot;.  From 2.6.31, the Linux Kernel is able to
increase or decrease the number of devices in a RAID5 or RAID6.
<P>
From 2.6.35, the Linux Kernel is able to convert a RAID0 in to a RAID4
or RAID5.
<I>mdadm</I>

uses this functionality and the ability to add
devices to a RAID4 to allow devices to be added to a RAID0.  When
requested to do this,
<I>mdadm</I>

will convert the RAID0 to a RAID4, add the necessary disks and make
the reshape happen, and then convert the RAID4 back to RAID0.
<P>
When decreasing the number of devices, the size of the array will also
decrease.  If there was data in the array, it could get destroyed and
this is not reversible, so you should firstly shrink the filesystem on
the array to fit within the new size.  To help prevent accidents,
<I>mdadm</I>

requires that the size of the array be decreased first with
<B>mdadm --grow --array-size</B>.

This is a reversible change which simply makes the end of the array
inaccessible.  The integrity of any data can then be checked before
the non-reversible reduction in the number of devices is request.
<P>
When relocating the first few stripes on a RAID5 or RAID6, it is not
possible to keep the data on disk completely consistent and
crash-proof.  To provide the required safety, mdadm disables writes to
the array while this &quot;critical section&quot; is reshaped, and takes a
backup of the data that is in that section.  For grows, this backup may be
stored in any spare devices that the array has, however it can also be
stored in a separate file specified with the
<B>--backup-file</B>

option, and is required to be specified for shrinks, RAID level
changes and layout changes.  If this option is used, and the system
does crash during the critical period, the same file must be passed to
<B>--assemble</B>

to restore the backup and reassemble the array.  When shrinking rather
than growing the array, the reshape is done from the end towards the
beginning, so the &quot;critical section&quot; is at the end of the reshape.
<P>
<A NAME="lbAY">&nbsp;</A>
<H3>LEVEL CHANGES</H3>

<P>
Changing the RAID level of any array happens instantaneously.  However
in the RAID5 to RAID6 case this requires a non-standard layout of the
RAID6 data, and in the RAID6 to RAID5 case that non-standard layout is
required before the change can be accomplished.  So while the level
change is instant, the accompanying layout change can take quite a
long time.  A
<B>--backup-file</B>

is required.  If the array is not simultaneously being grown or
shrunk, so that the array size will remain the same - for example,
reshaping a 3-drive RAID5 into a 4-drive RAID6 - the backup file will
be used not just for a &quot;cricital section&quot; but throughout the reshape
operation, as described below under LAYOUT CHANGES.
<P>
<A NAME="lbAZ">&nbsp;</A>
<H3>CHUNK-SIZE AND LAYOUT CHANGES</H3>

<P>
Changing the chunk-size of layout without also changing the number of
devices as the same time will involve re-writing all blocks in-place.
To ensure against data loss in the case of a crash, a
<B>--backup-file</B>

must be provided for these changes.  Small sections of the array will
be copied to the backup file while they are being rearranged.  This
means that all the data is copied twice, once to the backup and once
to the new layout on the array, so this type of reshape will go very
slowly.
<P>
If the reshape is interrupted for any reason, this backup file must be
made available to
<B>mdadm --assemble</B>

so the array can be reassembled.  Consequently the file cannot be
stored on the device being reshaped.
<P>
<P>
<A NAME="lbBA">&nbsp;</A>
<H3>BITMAP CHANGES</H3>

<P>
A write-intent bitmap can be added to, or removed from, an active
array.  Either internal bitmaps, or bitmaps stored in a separate file,
can be added.  Note that if you add a bitmap stored in a file which is
in a filesystem that is on the RAID array being affected, the system
will deadlock.  The bitmap must be on a separate filesystem.
<P>
<A NAME="lbBB">&nbsp;</A>
<H2>INCREMENTAL MODE</H2>

<P>
<DL COMPACT>
<DT>
<DD>Usage:
<B>mdadm --incremental</B>

[<B>--run</B>]

[<B>--quiet</B>]

<I>component-device</I>

<DT>
<DD>Usage:
<B>mdadm --incremental --fail</B>

<I>component-device</I>

<DT>
<DD>Usage:
<B>mdadm --incremental --rebuild-map</B>

<DT>
<DD>Usage:
<B>mdadm --incremental --run --scan</B>

<P>
</DL>
<P>

This mode is designed to be used in conjunction with a device
discovery system.  As devices are found in a system, they can be
passed to
<B>mdadm --incremental</B>

to be conditionally added to an appropriate array.
<P>
Conversely, it can also be used with the
<B>--fail</B>

flag to do just the opposite and find whatever array a particular device
is part of and remove the device from that array.
<P>
If the device passed is a
<B>CONTAINER</B>

device created by a previous call to
<I>mdadm</I>,

then rather than trying to add that device to an array, all the arrays
described by the metadata of the container will be started.
<P>
<I>mdadm</I>

performs a number of tests to determine if the device is part of an
array, and which array it should be part of.  If an appropriate array
is found, or can be created,
<I>mdadm</I>

adds the device to the array and conditionally starts the array.
<P>
Note that
<I>mdadm</I>

will normally only add devices to an array which were previously working
(active or spare) parts of that array.  The support for automatic
inclusion of a new drive as a spare in some array requires
a configuration through POLICY in config file.
<P>
The tests that
<I>mdadm</I>

makes are as follow:
<DL COMPACT>
<DT>+<DD>
Is the device permitted by
<B>mdadm.conf</B>?

That is, is it listed in a
<B>DEVICES</B>

line in that file.  If
<B>DEVICES</B>

is absent then the default it to allow any device.  Similar if
<B>DEVICES</B>

contains the special word
<B>partitions</B>

then any device is allowed.  Otherwise the device name given to
<I>mdadm</I>

must match one of the names or patterns in a
<B>DEVICES</B>

line.
<P>
<DT>+<DD>
Does the device have a valid md superblock?  If a specific metadata
version is requested with
<B>--metadata</B>

or
<B>-e</B>

then only that style of metadata is accepted, otherwise
<I>mdadm</I>

finds any known version of metadata.  If no
<I>md</I>

metadata is found, the device may be still added to an array
as a spare if POLICY allows.
<P>

<P>
</DL>
<P>

<I>mdadm</I>

keeps a list of arrays that it has partially assembled in
<B>/var/run/mdadm/map</B>

(or
<B>/var/run/mdadm.map</B>

if the directory doesn't exist.  Or maybe even
<B>/dev/.mdadm.map</B>).

If no array exists which matches
the metadata on the new device,
<I>mdadm</I>

must choose a device name and unit number.  It does this based on any
name given in
<B>mdadm.conf</B>

or any name information stored in the metadata.  If this name
suggests a unit number, that number will be used, otherwise a free
unit number will be chosen.  Normally
<I>mdadm</I>

will prefer to create a partitionable array, however if the
<B>CREATE</B>

line in
<B>mdadm.conf</B>

suggests that a non-partitionable array is preferred, that will be
honoured.
<P>
If the array is not found in the config file and its metadata does not
identify it as belonging to the &quot;homehost&quot;, then
<I>mdadm</I>

will choose a name for the array which is certain not to conflict with
any array which does belong to this host.  It does this be adding an
underscore and a small number to the name preferred by the metadata.
<P>
Once an appropriate array is found or created and the device is added,
<I>mdadm</I>

must decide if the array is ready to be started.  It will
normally compare the number of available (non-spare) devices to the
number of devices that the metadata suggests need to be active.  If
there are at least that many, the array will be started.  This means
that if any devices are missing the array will not be restarted.
<P>
As an alternative,
<B>--run</B>

may be passed to
<I>mdadm</I>

in which case the array will be run as soon as there are enough
devices present for the data to be accessible.  For a RAID1, that
means one device will start the array.  For a clean RAID5, the array
will be started as soon as all but one drive is present.
<P>
Note that neither of these approaches is really ideal.  If it can
be known that all device discovery has completed, then
<BR>

<B>   mdadm -IRs</B>

<BR>

can be run which will try to start all arrays that are being
incrementally assembled.  They are started in &quot;read-auto&quot; mode in
which they are read-only until the first write request.  This means
that no metadata updates are made and no attempt at resync or recovery
happens.  Further devices that are found before the first write can
still be added safely.
<P>
<A NAME="lbBC">&nbsp;</A>
<H2>ENVIRONMENT</H2>

This section describes environment variables that affect how mdadm
operates.
<P>
<DL COMPACT>
<DT><B>MDADM_NO_MDMON</B>

<DD>
Setting this value to 1 will prevent mdadm from automatically launching
mdmon.  This variable is intended primarily for debugging mdadm/mdmon.
<P>
<DT><B>MDADM_NO_UDEV</B>

<DD>
Normally,
<I>mdadm</I>

does not create any device nodes in /dev, but leaves that task to
<I>udev</I>.

If
<I>udev</I>

appears not to be configured, or if this environment variable is set
to '1', the
<I>mdadm</I>

will create and devices that are needed.
<P>
</DL>
<A NAME="lbBD">&nbsp;</A>
<H2>EXAMPLES</H2>

<P>
<B>  mdadm --query /dev/name-of-device</B>

<BR>

This will find out if a given device is a RAID array, or is part of
one, and will provide brief information about the device.
<P>
<B>  mdadm --assemble --scan</B>

<BR>

This will assemble and start all arrays listed in the standard config
file.  This command will typically go in a system startup file.
<P>
<B>  mdadm --stop --scan</B>

<BR>

This will shut down all arrays that can be shut down (i.e. are not
currently in use).  This will typically go in a system shutdown script.
<P>
<B>  mdadm --follow --scan --delay=120</B>

<BR>

If (and only if) there is an Email address or program given in the
standard config file, then
monitor the status of all arrays listed in that file by
polling them ever 2 minutes.
<P>
<B>  mdadm --create /dev/md0 --level=1 --raid-devices=2 /dev/hd[ac]1</B>

<BR>

Create /dev/md0 as a RAID1 array consisting of /dev/hda1 and /dev/hdc1.
<P>
<BR>

<B>  echo 'DEVICE /dev/hd*[0-9] /dev/sd*[0-9]' &gt; mdadm.conf</B>

<BR>

<B>  mdadm --detail --scan &gt;&gt; mdadm.conf</B>

<BR>

This will create a prototype config file that describes currently
active arrays that are known to be made from partitions of IDE or SCSI drives.
This file should be reviewed before being used as it may
contain unwanted detail.
<P>
<B>  echo 'DEVICE /dev/hd[a-z] /dev/sd*[a-z]' &gt; mdadm.conf</B>

<BR>

<B>  mdadm --examine --scan --config=mdadm.conf &gt;&gt; mdadm.conf</B>

<BR>

This will find arrays which could be assembled from existing IDE and
SCSI whole drives (not partitions), and store the information in the
format of a config file.
This file is very likely to contain unwanted detail, particularly
the
<B>devices=</B>

entries.  It should be reviewed and edited before being used as an
actual config file.
<P>
<B>  mdadm --examine --brief --scan --config=partitions</B>

<BR>

<B>  mdadm -Ebsc partitions</B>

<BR>

Create a list of devices by reading
<B>/proc/partitions</B>,

scan these for RAID superblocks, and printout a brief listing of all
that were found.
<P>
<B>  mdadm -Ac partitions -m 0 /dev/md0</B>

<BR>

Scan all partitions and devices listed in
<B>/proc/partitions</B>

and assemble
<B>/dev/md0</B>

out of all such devices with a RAID superblock with a minor number of 0.
<P>
<B>  mdadm --monitor --scan --daemonise &gt; /var/run/mdadm</B>

<BR>

If config file contains a mail address or alert program, run mdadm in
the background in monitor mode monitoring all md devices.  Also write
pid of mdadm daemon to
<B>/var/run/mdadm</B>.

<P>
<B>  mdadm -Iq /dev/somedevice</B>

<BR>

Try to incorporate newly discovered device into some array as
appropriate.
<P>
<B>  mdadm --incremental --rebuild-map --run --scan</B>

<BR>

Rebuild the array map from any current arrays, and then start any that
can be started.
<P>
<B>  mdadm /dev/md4 --fail detached --remove detached</B>

<BR>

Any devices which are components of /dev/md4 will be marked as faulty
and then remove from the array.
<P>
<B>  mdadm --grow /dev/md4 --level=6 --backup-file=/root/backup-md4</B>

<BR>

The array
<B>/dev/md4</B>

which is currently a RAID5 array will be converted to RAID6.  There
should normally already be a spare drive attached to the array as a
RAID6 needs one more drive than a matching RAID5.
<P>
<B>  mdadm --create /dev/md/ddf --metadata=ddf --raid-disks 6 /dev/sd[a-f]</B>

<BR>

Create a DDF array over 6 devices.
<P>
<B>  mdadm --create /dev/md/home -n3 -l5 -z 30000000 /dev/md/ddf</B>

<BR>

Create a RAID5 array over any 3 devices in the given DDF set.  Use
only 30 gigabytes of each device.
<P>
<B>  mdadm -A /dev/md/ddf1 /dev/sd[a-f]</B>

<BR>

Assemble a pre-exist ddf array.
<P>
<B>  mdadm -I /dev/md/ddf1</B>

<BR>

Assemble all arrays contained in the ddf array, assigning names as
appropriate.
<P>
<B>  mdadm --create --help</B>

<BR>

Provide help about the Create mode.
<P>
<B>  mdadm --config --help</B>

<BR>

Provide help about the format of the config file.
<P>
<B>  mdadm --help</B>

<BR>

Provide general help.
<P>
<A NAME="lbBE">&nbsp;</A>
<H2>FILES</H2>

<P>
<A NAME="lbBF">&nbsp;</A>
<H3>/proc/mdstat</H3>

<P>
If you're using the
<B>/proc</B>

filesystem,
<B>/proc/mdstat</B>

lists all active md devices with information about them.
<I>mdadm</I>

uses this to find arrays when
<B>--scan</B>

is given in Misc mode, and to monitor array reconstruction
on Monitor mode.
<P>
<A NAME="lbBG">&nbsp;</A>
<H3>/etc/mdadm.conf</H3>

<P>
The config file lists which devices may be scanned to see if
they contain MD super block, and gives identifying information
(e.g. UUID) about known MD arrays.  See
<B><A HREF="/manpages/index.html?5+mdadm.conf">mdadm.conf</A></B>(5)

for more details.
<P>
<A NAME="lbBH">&nbsp;</A>
<H3>/var/run/mdadm/map</H3>

When
<B>--incremental</B>

mode is used, this file gets a list of arrays currently being created.
If
<B>/var/run/mdadm</B>

does not exist as a directory, then
<B>/var/run/mdadm.map</B>

is used instead.  If
<B>/var/run</B>

is not available (as may be the case during early boot),
<B>/dev/.mdadm.map</B>

is used on the basis that
<B>/dev</B>

is usually available very early in boot.
<P>
<A NAME="lbBI">&nbsp;</A>
<H2>DEVICE NAMES</H2>

<P>
<I>mdadm</I>

understand two sorts of names for array devices.
<P>
The first is the so-called 'standard' format name, which matches the
names used by the kernel and which appear in
<I>/proc/mdstat</I>.

<P>
The second sort can be freely chosen, but must reside in
<I>/dev/md/</I>.

When giving a device name to
<I>mdadm</I>

to create or assemble an array, either full path name such as
<I>/dev/md0</I>

or
<I>/dev/md/home</I>

can be given, or just the suffix of the second sort of name, such as
<I>home</I>

can be given.
<P>
When
<I>mdadm</I>

chooses device names during auto-assembly or incremental assembly, it
will sometimes add a small sequence number to the end of the name to
avoid conflicted between multiple arrays that have the same name.  If
<I>mdadm</I>

can reasonably determine that the array really is meant for this host,
either by a hostname in the metadata, or by the presence of the array
in
<B>mdadm.conf</B>,

then it will leave off the suffix if possible.
Also if the homehost is specified as
<B>&lt;ignore&gt;</B>

<I>mdadm</I>

will only use a suffix if a different array of the same name already
exists or is listed in the config file.
<P>
The standard names for non-partitioned arrays (the only sort of md
array available in 2.4 and earlier) are of the form
<DL COMPACT>
<DT><DD>
/dev/mdNN
</DL>
<P>

where NN is a number.
The standard names for partitionable arrays (as available from 2.6
onwards) are of the form
<DL COMPACT>
<DT><DD>
/dev/md_dNN
</DL>
<P>

Partition numbers should be indicated by added &quot;pMM&quot; to these, thus &quot;/dev/md/d1p2&quot;.
<P>

From kernel version, 2.6.28 the &quot;non-partitioned array&quot; can actually
be partitioned.  So the &quot;md_dNN&quot; names are no longer needed, and
partitions such as &quot;/dev/mdNNpXX&quot; are possible.
<P>
<A NAME="lbBJ">&nbsp;</A>
<H2>NOTE</H2>

<I>mdadm</I>

was previously known as
<I>mdctl</I>.


<I>mdadm</I>

is completely separate from the
<I>raidtools</I>

package, and does not use the
<I>/etc/raidtab</I>

configuration file at all.
<P>
<A NAME="lbBK">&nbsp;</A>
<H2>SEE ALSO</H2>

For further information on mdadm usage, MD and the various levels of
RAID, see:
<DL COMPACT>
<DT><DD>
<B><A HREF="http://raid.wiki.kernel.org/">http://raid.wiki.kernel.org/</A></B>

</DL>
<P>

(based upon Jakob /Ostergaard's Software-RAID.HOWTO)













<P>

The latest version of
<I>mdadm</I>

should always be available from
<DL COMPACT>
<DT><DD>
<B><A HREF="http://www.kernel.org/pub/linux/utils/raid/mdadm/">http://www.kernel.org/pub/linux/utils/raid/mdadm/</A></B>

</DL>
<P>

Related man pages:
<P>

<I><A HREF="/manpages/index.html?8+mdmon">mdmon</A></I>(8),

<I><A HREF="/manpages/index.html?5+mdadm.conf">mdadm.conf</A></I>(5),

<I><A HREF="/manpages/index.html?4+md">md</A></I>(4).

<P>

<I><A HREF="/manpages/index.html?5+raidtab">raidtab</A></I>(5),

<I><A HREF="/manpages/index.html?8+raid0run">raid0run</A></I>(8),

<I><A HREF="/manpages/index.html?8+raidstop">raidstop</A></I>(8),

<I><A HREF="/manpages/index.html?8+mkraid">mkraid</A></I>(8).

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">MODES</A><DD>
<DT><A HREF="#lbAF">OPTIONS</A><DD>
<DT><A HREF="#lbAG">Options for selecting a mode are:</A><DD>
<DT><A HREF="#lbAH">Options that are not mode-specific are:</A><DD>
<DT><A HREF="#lbAI">For create, build, or grow:</A><DD>
<DT><A HREF="#lbAJ">For assemble:</A><DD>
<DT><A HREF="#lbAK">For Manage mode:</A><DD>
<DT><A HREF="#lbAL">For Misc mode:</A><DD>
<DT><A HREF="#lbAM">For Incremental Assembly mode:</A><DD>
<DT><A HREF="#lbAN">For Monitor mode:</A><DD>
<DT><A HREF="#lbAO">ASSEMBLE MODE</A><DD>
<DL>
<DT><A HREF="#lbAP">Auto Assembly</A><DD>
</DL>
<DT><A HREF="#lbAQ">BUILD MODE</A><DD>
<DT><A HREF="#lbAR">CREATE MODE</A><DD>
<DT><A HREF="#lbAS">MANAGE MODE</A><DD>
<DT><A HREF="#lbAT">MISC MODE</A><DD>
<DT><A HREF="#lbAU">MONITOR MODE</A><DD>
<DT><A HREF="#lbAV">GROW MODE</A><DD>
<DL>
<DT><A HREF="#lbAW">SIZE CHANGES</A><DD>
<DT><A HREF="#lbAX">RAID-DEVICES CHANGES</A><DD>
<DT><A HREF="#lbAY">LEVEL CHANGES</A><DD>
<DT><A HREF="#lbAZ">CHUNK-SIZE AND LAYOUT CHANGES</A><DD>
<DT><A HREF="#lbBA">BITMAP CHANGES</A><DD>
</DL>
<DT><A HREF="#lbBB">INCREMENTAL MODE</A><DD>
<DT><A HREF="#lbBC">ENVIRONMENT</A><DD>
<DT><A HREF="#lbBD">EXAMPLES</A><DD>
<DT><A HREF="#lbBE">FILES</A><DD>
<DL>
<DT><A HREF="#lbBF">/proc/mdstat</A><DD>
<DT><A HREF="#lbBG">/etc/mdadm.conf</A><DD>
<DT><A HREF="#lbBH">/var/run/mdadm/map</A><DD>
</DL>
<DT><A HREF="#lbBI">DEVICE NAMES</A><DD>
<DT><A HREF="#lbBJ">NOTE</A><DD>
<DT><A HREF="#lbBK">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:34:27 GMT, December 24, 2015
</div></body>
</HTML>
