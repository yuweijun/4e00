<!DOCTYPE html>

<HTML><head><TITLE>Manpage of PERLINTERN</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux man pages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>PERLINTERN</H1>
Section: Perl Programmers Reference Guide (1)<BR>Updated: 2012-06-22<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

perlintern - autogenerated documentation of purely <B>internal</B>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT> Perl functions<BR>
<A NAME="lbAC">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAC"></A>
<A NAME="ixAAD"></A>
This file is the autogenerated documentation of functions in the
Perl interpreter that are documented using Perl's internal documentation
format but are not marked as part of the Perl <FONT SIZE="-1">API</FONT>. In other words,
<B>they are not for use in extensions</B>!
<A NAME="lbAD">&nbsp;</A>
<H2>CV reference counts and CvOUTSIDE</H2>

<A NAME="ixAAE"></A>
<DL COMPACT>
<DT>CvWEAKOUTSIDE<DD>
<A NAME="ixAAF"></A>
<A NAME="ixAAG"></A>
Each <FONT SIZE="-1">CV</FONT> has a pointer, <TT>&quot;CvOUTSIDE()&quot;</TT>, to its lexically enclosing
<FONT SIZE="-1">CV</FONT> (if any). Because pointers to anonymous sub prototypes are
stored in <TT>&quot;&amp;&quot;</TT> pad slots, it is a possible to get a circular reference,
with the parent pointing to the child and vice-versa. To avoid the
ensuing memory leak, we do not increment the reference count of the <FONT SIZE="-1">CV</FONT>
pointed to by <TT>&quot;CvOUTSIDE&quot;</TT> in the <I>one specific instance</I> that the parent
has a <TT>&quot;&amp;&quot;</TT> pad slot pointing back to us. In this case, we set the
<TT>&quot;CvWEAKOUTSIDE&quot;</TT> flag in the child. This allows us to determine under what
circumstances we should decrement the refcount of the parent when freeing
the child.


<P>


There is a further complication with non-closure anonymous subs (i.e. those
that do not refer to any lexicals outside that sub). In this case, the
anonymous prototype is shared rather than being cloned. This has the
consequence that the parent may be freed while there are still active
children, eg


<P>




<PRE>
    BEGIN { $a = sub { eval '$x' } }

</PRE>




<P>


In this case, the <FONT SIZE="-1">BEGIN</FONT> is freed immediately after execution since there
are no active references to it: the anon sub prototype has
<TT>&quot;CvWEAKOUTSIDE&quot;</TT> set since it's not a closure, and <TT>$a</TT> points to the same
<FONT SIZE="-1">CV</FONT>, so it doesn't contribute to <FONT SIZE="-1">BEGIN</FONT>'s refcount either.  When <TT>$a</TT> is
executed, the <TT>&quot;eval '$x'&quot;</TT> causes the chain of <TT>&quot;CvOUTSIDE&quot;</TT>s to be followed,
and the freed <FONT SIZE="-1">BEGIN</FONT> is accessed.


<P>


To avoid this, whenever a <FONT SIZE="-1">CV</FONT> and its associated pad is freed, any
<TT>&quot;&amp;&quot;</TT> entries in the pad are explicitly removed from the pad, and if the
refcount of the pointed-to anon sub is still positive, then that
child's <TT>&quot;CvOUTSIDE&quot;</TT> is set to point to its grandparent. This will only
occur in the single specific case of a non-closure anon prototype
having one or more active references (such as <TT>$a</TT> above).


<P>


One other thing to consider is that a <FONT SIZE="-1">CV</FONT> may be merely undefined
rather than freed, eg <TT>&quot;undef &amp;foo&quot;</TT>. In this case, its refcount may
not have reached zero, but we still delete its pad and its <TT>&quot;CvROOT&quot;</TT> etc.
Since various children may still have their <TT>&quot;CvOUTSIDE&quot;</TT> pointing at this
undefined <FONT SIZE="-1">CV</FONT>, we keep its own <TT>&quot;CvOUTSIDE&quot;</TT> for the time being, so that
the chain of lexical scopes is unbroken. For example, the following
should print 123:


<P>




<PRE>
    my $x = 123;
    sub tmp { sub { eval '$x' } }
    my $a = tmp();
    undef &amp;tmp;
    print  $a-&gt;();

        bool    CvWEAKOUTSIDE(CV *cv)

</PRE>


</DL>
<A NAME="lbAE">&nbsp;</A>
<H2>Functions in file pad.h</H2>

<A NAME="ixAAH"></A>
<DL COMPACT>
<DT><FONT SIZE="-1">CX_CURPAD_SAVE</FONT><DD>
<A NAME="ixAAI"></A>
<A NAME="ixAAJ"></A>
Save the current pad in the given context block structure.


<P>




<PRE>
        void    CX_CURPAD_SAVE(struct context)

</PRE>


<DT><FONT SIZE="-1">CX_CURPAD_SV</FONT><DD>
<A NAME="ixAAK"></A>
<A NAME="ixAAL"></A>
Access the <FONT SIZE="-1">SV</FONT> at offset po in the saved current pad in the given
context block structure (can be used as an lvalue).


<P>




<PRE>
        SV *    CX_CURPAD_SV(struct context, PADOFFSET po)

</PRE>


<DT><FONT SIZE="-1">PAD_BASE_SV</FONT><DD>
<A NAME="ixAAM"></A>
<A NAME="ixAAN"></A>
Get the value from slot <TT>&quot;po&quot;</TT> in the base (DEPTH=1) pad of a padlist


<P>




<PRE>
        SV *    PAD_BASE_SV(PADLIST padlist, PADOFFSET po)

</PRE>


<DT><FONT SIZE="-1">PAD_CLONE_VARS</FONT><DD>
<A NAME="ixAAO"></A>
<A NAME="ixAAP"></A>
Clone the state variables associated with running and compiling pads.


<P>




<PRE>
        void    PAD_CLONE_VARS(PerlInterpreter *proto_perl, CLONE_PARAMS* param)

</PRE>


<DT><FONT SIZE="-1">PAD_COMPNAME_FLAGS</FONT><DD>
<A NAME="ixAAQ"></A>
<A NAME="ixAAR"></A>
Return the flags for the current compiling pad name
at offset <TT>&quot;po&quot;</TT>. Assumes a valid slot entry.


<P>




<PRE>
        U32     PAD_COMPNAME_FLAGS(PADOFFSET po)

</PRE>


<DT><FONT SIZE="-1">PAD_COMPNAME_GEN</FONT><DD>
<A NAME="ixAAS"></A>
<A NAME="ixAAT"></A>
The generation number of the name at offset <TT>&quot;po&quot;</TT> in the current
compiling pad (lvalue). Note that <TT>&quot;SvUVX&quot;</TT> is hijacked for this purpose.


<P>




<PRE>
        STRLEN  PAD_COMPNAME_GEN(PADOFFSET po)

</PRE>


<DT>PAD_COMPNAME_GEN_set<DD>
<A NAME="ixAAU"></A>
<A NAME="ixAAV"></A>
Sets the generation number of the name at offset <TT>&quot;po&quot;</TT> in the current
ling pad (lvalue) to <TT>&quot;gen&quot;</TT>.  Note that <TT>&quot;SvUV_set&quot;</TT> is hijacked for this purpose.


<P>




<PRE>
        STRLEN  PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)

</PRE>


<DT><FONT SIZE="-1">PAD_COMPNAME_OURSTASH</FONT><DD>
<A NAME="ixAAW"></A>
<A NAME="ixAAX"></A>
Return the stash associated with an <TT>&quot;our&quot;</TT> variable.
Assumes the slot entry is a valid <TT>&quot;our&quot;</TT> lexical.


<P>




<PRE>
        HV *    PAD_COMPNAME_OURSTASH(PADOFFSET po)

</PRE>


<DT><FONT SIZE="-1">PAD_COMPNAME_PV</FONT><DD>
<A NAME="ixAAY"></A>
<A NAME="ixAAZ"></A>
Return the name of the current compiling pad name
at offset <TT>&quot;po&quot;</TT>. Assumes a valid slot entry.


<P>




<PRE>
        char *  PAD_COMPNAME_PV(PADOFFSET po)

</PRE>


<DT><FONT SIZE="-1">PAD_COMPNAME_TYPE</FONT><DD>
<A NAME="ixABA"></A>
<A NAME="ixABB"></A>
Return the type (stash) of the current compiling pad name at offset
<TT>&quot;po&quot;</TT>. Must be a valid name. Returns null if not typed.


<P>




<PRE>
        HV *    PAD_COMPNAME_TYPE(PADOFFSET po)

</PRE>


<DT><FONT SIZE="-1">PAD_DUP</FONT><DD>
<A NAME="ixABC"></A>
<A NAME="ixABD"></A>
Clone a padlist.


<P>




<PRE>
        void    PAD_DUP(PADLIST dstpad, PADLIST srcpad, CLONE_PARAMS* param)

</PRE>


<DT><FONT SIZE="-1">PAD_RESTORE_LOCAL</FONT><DD>
<A NAME="ixABE"></A>
<A NAME="ixABF"></A>
Restore the old pad saved into the local variable opad by <FONT SIZE="-1"><I>PAD_SAVE_LOCAL</I></FONT><I>()</I>


<P>




<PRE>
        void    PAD_RESTORE_LOCAL(PAD *opad)

</PRE>


<DT><FONT SIZE="-1">PAD_SAVE_LOCAL</FONT><DD>
<A NAME="ixABG"></A>
<A NAME="ixABH"></A>
Save the current pad to the local variable opad, then make the
current pad equal to npad


<P>




<PRE>
        void    PAD_SAVE_LOCAL(PAD *opad, PAD *npad)

</PRE>


<DT><FONT SIZE="-1">PAD_SAVE_SETNULLPAD</FONT><DD>
<A NAME="ixABI"></A>
<A NAME="ixABJ"></A>
Save the current pad then set it to null.


<P>




<PRE>
        void    PAD_SAVE_SETNULLPAD()

</PRE>


<DT><FONT SIZE="-1">PAD_SETSV</FONT><DD>
<A NAME="ixABK"></A>
<A NAME="ixABL"></A>
Set the slot at offset <TT>&quot;po&quot;</TT> in the current pad to <TT>&quot;sv&quot;</TT>


<P>




<PRE>
        SV *    PAD_SETSV(PADOFFSET po, SV* sv)

</PRE>


<DT><FONT SIZE="-1">PAD_SET_CUR</FONT><DD>
<A NAME="ixABM"></A>
<A NAME="ixABN"></A>
Set the current pad to be pad <TT>&quot;n&quot;</TT> in the padlist, saving
the previous current pad. <FONT SIZE="-1">NB</FONT> currently this macro expands to a string too
long for some compilers, so it's best to replace it with


<P>




<PRE>
    SAVECOMPPAD();
    PAD_SET_CUR_NOSAVE(padlist,n);


        void    PAD_SET_CUR(PADLIST padlist, I32 n)

</PRE>


<DT><FONT SIZE="-1">PAD_SET_CUR_NOSAVE</FONT><DD>
<A NAME="ixABO"></A>
<A NAME="ixABP"></A>
like <FONT SIZE="-1">PAD_SET_CUR</FONT>, but without the save


<P>




<PRE>
        void    PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)

</PRE>


<DT><FONT SIZE="-1">PAD_SV</FONT><DD>
<A NAME="ixABQ"></A>
<A NAME="ixABR"></A>
Get the value at offset <TT>&quot;po&quot;</TT> in the current pad


<P>




<PRE>
        void    PAD_SV(PADOFFSET po)

</PRE>


<DT>PAD_SVl<DD>
<A NAME="ixABS"></A>
<A NAME="ixABT"></A>
Lightweight and lvalue version of <TT>&quot;PAD_SV&quot;</TT>.
Get or set the value at offset <TT>&quot;po&quot;</TT> in the current pad.
Unlike <TT>&quot;PAD_SV&quot;</TT>, does not print diagnostics with -DX.
For internal use only.


<P>




<PRE>
        SV *    PAD_SVl(PADOFFSET po)

</PRE>


<DT><FONT SIZE="-1">SAVECLEARSV</FONT><DD>
<A NAME="ixABU"></A>
<A NAME="ixABV"></A>
Clear the pointed to pad value on scope exit. (i.e. the runtime action of 'my')


<P>




<PRE>
        void    SAVECLEARSV(SV **svp)

</PRE>


<DT><FONT SIZE="-1">SAVECOMPPAD</FONT><DD>
<A NAME="ixABW"></A>
<A NAME="ixABX"></A>
save PL_comppad and PL_curpad


<P>




<PRE>
        void    SAVECOMPPAD()

</PRE>


<DT><FONT SIZE="-1">SAVEPADSV</FONT><DD>
<A NAME="ixABY"></A>
<A NAME="ixABZ"></A>
Save a pad slot (used to restore after an iteration)


<P>


<FONT SIZE="-1">XXX</FONT> <FONT SIZE="-1">DAPM</FONT> it would make more sense to make the arg a <FONT SIZE="-1">PADOFFSET</FONT>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>void<TT>&nbsp;&nbsp;&nbsp;&nbsp;</TT><FONT SIZE="-1">SAVEPADSV</FONT>(<FONT SIZE="-1">PADOFFSET</FONT> po)<BR>
</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>GV Functions</H2>

<A NAME="ixACA"></A>
<DL COMPACT>
<DT>is_gv_magical<DD>
<A NAME="ixACB"></A>
<A NAME="ixACC"></A>
Returns <TT>&quot;TRUE&quot;</TT> if given the name of a magical <FONT SIZE="-1">GV</FONT>.


<P>


Currently only useful internally when determining if a <FONT SIZE="-1">GV</FONT> should be
created even in rvalue contexts.


<P>


<TT>&quot;flags&quot;</TT> is not used at present but available for future extension to
allow selecting particular classes of magical variable.


<P>


Currently assumes that <TT>&quot;name&quot;</TT> is <FONT SIZE="-1">NUL</FONT> terminated (as well as len being valid).
This assumption is met by all callers within the perl core, which all pass
pointers returned by SvPV.


<P>




<PRE>
        bool    is_gv_magical(const char *name, STRLEN len, U32 flags)

</PRE>


<DT>is_gv_magical_sv<DD>
<A NAME="ixACD"></A>
<A NAME="ixACE"></A>
Returns <TT>&quot;TRUE&quot;</TT> if given the name of a magical <FONT SIZE="-1">GV</FONT>. Calls is_gv_magical.


<P>




<PRE>
        bool    is_gv_magical_sv(SV *name, U32 flags)

</PRE>


</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>Hash Manipulation Functions</H2>

<A NAME="ixACF"></A>
<DL COMPACT>
<DT>refcounted_he_chain_2hv<DD>
<A NAME="ixACG"></A>
<A NAME="ixACH"></A>
Generates and returns a <TT>&quot;HV *&quot;</TT> by walking up the tree starting at the passed
in <TT>&quot;struct refcounted_he *&quot;</TT>.


<P>




<PRE>
        HV *    refcounted_he_chain_2hv(const struct refcounted_he *c)

</PRE>


<DT>refcounted_he_free<DD>
<A NAME="ixACI"></A>
<A NAME="ixACJ"></A>
Decrements the reference count of the passed in <TT>&quot;struct refcounted_he *&quot;</TT>
by one. If the reference count reaches zero the structure's memory is freed,
and <TT>&quot;refcounted_he_free&quot;</TT> iterates onto the parent node.


<P>




<PRE>
        void    refcounted_he_free(struct refcounted_he *he)

</PRE>


<DT>refcounted_he_new<DD>
<A NAME="ixACK"></A>
<A NAME="ixACL"></A>
Creates a new <TT>&quot;struct refcounted_he&quot;</TT>. As key is copied, and value is
stored in a compact form, all references remain the property of the caller.
The <TT>&quot;struct refcounted_he&quot;</TT> is returned with a reference count of 1.


<P>




<PRE>
        struct refcounted_he *  refcounted_he_new(struct refcounted_he *const parent, SV *const key, SV *const value)

</PRE>


</DL>
<A NAME="lbAH">&nbsp;</A>
<H2>IO Functions</H2>

<A NAME="ixACM"></A>
<DL COMPACT>
<DT>start_glob<DD>
<A NAME="ixACN"></A>
<A NAME="ixACO"></A>
Function called by <TT>&quot;do_readline&quot;</TT> to spawn a glob (or do the glob inside
perl on <FONT SIZE="-1">VMS</FONT>). This code used to be inline, but now perl uses <TT>&quot;File::Glob&quot;</TT>
this glob starter is only used by miniperl during the build process.
Moving it away shrinks pp_hot.c; shrinking pp_hot.c helps speed perl up.


<P>




<PRE>
        PerlIO* start_glob(SV *tmpglob, IO *io)

</PRE>


</DL>
<A NAME="lbAI">&nbsp;</A>
<H2>Magical Functions</H2>

<A NAME="ixACP"></A>
<DL COMPACT>
<DT>magic_clearhint<DD>
<A NAME="ixACQ"></A>
<A NAME="ixACR"></A>
Triggered by a delete from %^H, records the key to
<TT>&quot;PL_compiling.cop_hints_hash&quot;</TT>.


<P>




<PRE>
        int     magic_clearhint(SV* sv, MAGIC* mg)

</PRE>


<DT>magic_sethint<DD>
<A NAME="ixACS"></A>
<A NAME="ixACT"></A>
Triggered by a store to %^H, records the key/value pair to
<TT>&quot;PL_compiling.cop_hints_hash&quot;</TT>.  It is assumed that hints aren't storing
anything that would need a deep copy.  Maybe we should warn if we find a
reference.


<P>




<PRE>
        int     magic_sethint(SV* sv, MAGIC* mg)

</PRE>


<DT>mg_localize<DD>
<A NAME="ixACU"></A>
<A NAME="ixACV"></A>
Copy some of the magic from an existing <FONT SIZE="-1">SV</FONT> to new localized version of
that <FONT SIZE="-1">SV</FONT>. Container magic (eg <TT>%ENV</TT>, <TT>$1</TT>, tie) gets copied, value magic
doesn't (eg taint, pos).


<P>




<PRE>
        void    mg_localize(SV* sv, SV* nsv)

</PRE>


</DL>
<A NAME="lbAJ">&nbsp;</A>
<H2>MRO Functions</H2>

<A NAME="ixACW"></A>
<DL COMPACT>
<DT>mro_get_linear_isa_dfs<DD>
<A NAME="ixACX"></A>
<A NAME="ixACY"></A>
Returns the Depth-First Search linearization of <TT>@ISA</TT>
the given stash.  The return value is a read-only AV*.
<TT>&quot;level&quot;</TT> should be 0 (it is used internally in this
function's recursion).


<P>


You are responsible for <TT>&quot;SvREFCNT_inc()&quot;</TT> on the
return value if you plan to store it anywhere
semi-permanently (otherwise it might be deleted
out from under you the next time the cache is
invalidated).


<P>




<PRE>
        AV*     mro_get_linear_isa_dfs(HV* stash, U32 level)

</PRE>


<DT>mro_isa_changed_in<DD>
<A NAME="ixACZ"></A>
<A NAME="ixADA"></A>
Takes the necessary steps (cache invalidations, mostly)
when the <TT>@ISA</TT> of the given package has changed.  Invoked
by the <TT>&quot;setisa&quot;</TT> magic, should not need to invoke directly.


<P>




<PRE>
        void    mro_isa_changed_in(HV* stash)

</PRE>


</DL>
<A NAME="lbAK">&nbsp;</A>
<H2>Pad Data Structures</H2>

<A NAME="ixADB"></A>
<DL COMPACT>
<DT>CvPADLIST<DD>
<A NAME="ixADC"></A>
<A NAME="ixADD"></A>
<FONT SIZE="-1">CV</FONT>'s can have CvPADLIST(cv) set to point to an <FONT SIZE="-1">AV</FONT>.


<P>


For these purposes ``forms'' are a kind-of <FONT SIZE="-1">CV</FONT>, eval&quot;``s are too (except they're
not callable at will and are always thrown away after the eval''&quot; is done
executing). Require'd files are simply evals without any outer lexical
scope.


<P>


XSUBs don't have CvPADLIST set - dXSTARG fetches values from PL_curpad,
but that is really the callers pad (a slot of which is allocated by
every entersub).


<P>


The CvPADLIST <FONT SIZE="-1">AV</FONT> has does not have AvREAL set, so <FONT SIZE="-1">REFCNT</FONT> of component items
is managed ``manual'' (mostly in pad.c) rather than normal av.c rules.
The items in the <FONT SIZE="-1">AV</FONT> are not SVs as for a normal <FONT SIZE="-1">AV</FONT>, but other AVs:


<P>


0'th Entry of the CvPADLIST is an <FONT SIZE="-1">AV</FONT> which represents the ``names'' or rather
the ``static type information'' for lexicals.


<P>


The CvDEPTH'th entry of CvPADLIST <FONT SIZE="-1">AV</FONT> is an <FONT SIZE="-1">AV</FONT> which is the stack frame at that
depth of recursion into the <FONT SIZE="-1">CV</FONT>.
The 0'th slot of a frame <FONT SIZE="-1">AV</FONT> is an <FONT SIZE="-1">AV</FONT> which is <TT>@_</TT>.
other entries are storage for variables and op targets.


<P>


During compilation:
<TT>&quot;PL_comppad_name&quot;</TT> is set to the names <FONT SIZE="-1">AV</FONT>.
<TT>&quot;PL_comppad&quot;</TT> is set to the frame <FONT SIZE="-1">AV</FONT> for the frame CvDEPTH == 1.
<TT>&quot;PL_curpad&quot;</TT> is set to the body of the frame <FONT SIZE="-1">AV</FONT> (i.e. AvARRAY(PL_comppad)).


<P>


During execution, <TT>&quot;PL_comppad&quot;</TT> and <TT>&quot;PL_curpad&quot;</TT> refer to the live
frame of the currently executing sub.


<P>


Iterating over the names <FONT SIZE="-1">AV</FONT> iterates over all possible pad
items. Pad slots that are SVs_PADTMP (targets/GVs/constants) end up having
&amp;PL_sv_undef ``names'' (see <I>pad_alloc()</I>).


<P>


Only my/our variable (SVs_PADMY/SVs_PADOUR) slots get valid names.
The rest are op targets/GVs/constants which are statically allocated
or resolved at compile time.  These don't have names by which they
can be looked up from Perl code at run time through eval&quot;`` like
my/our variables can be.  Since they can't be looked up by ''name&quot;
but only by their index allocated at compile time (which is usually
in PL_op-&gt;op_targ), wasting a name <FONT SIZE="-1">SV</FONT> for them doesn't make sense.


<P>


The SVs in the names <FONT SIZE="-1">AV</FONT> have their <FONT SIZE="-1">PV</FONT> being the name of the variable.
xlow+1..xhigh inclusive in the <FONT SIZE="-1">NV</FONT> union is a range of cop_seq numbers for
which the name is valid.  For typed lexicals name <FONT SIZE="-1">SV</FONT> is SVt_PVMG and SvSTASH
points at the type.  For <TT>&quot;our&quot;</TT> lexicals, the type is also SVt_PVMG, with the
SvOURSTASH slot pointing at the stash of the associated global (so that
duplicate <TT>&quot;our&quot;</TT> declarations in the same package can be detected).  SvUVX is
sometimes hijacked to store the generation number during compilation.


<P>


If SvFAKE is set on the name <FONT SIZE="-1">SV</FONT>, then that slot in the frame <FONT SIZE="-1">AV</FONT> is
a <FONT SIZE="-1">REFCNT</FONT>'ed reference to a lexical from ``outside''. In this case,
the name <FONT SIZE="-1">SV</FONT> does not use xlow and xhigh to store a cop_seq range, since it is
in scope throughout. Instead xhigh stores some flags containing info about
the real lexical (is it declared in an anon, and is it capable of being
instantiated multiple times?), and for fake ANONs, xlow contains the index
within the parent's pad where the lexical's value is stored, to make
cloning quicker.


<P>


If the 'name' is '&amp;' the corresponding entry in frame <FONT SIZE="-1">AV</FONT>
is a <FONT SIZE="-1">CV</FONT> representing a possible closure.
(SvFAKE and name of '&amp;' is not a meaningful combination currently but could
become so if <TT>&quot;my sub foo {}&quot;</TT> is implemented.)


<P>


Note that formats are treated as anon subs, and are cloned each time
write is called (if necessary).


<P>


The flag SVf_PADSTALE is cleared on lexicals each time the <I>my()</I> is executed,
and set on scope exit. This allows the 'Variable <TT>$x</TT> is not available' warning
to be generated in evals, such as


<P>




<PRE>
    { my $x = 1; sub f { eval '$x'} } f();

</PRE>




<P>


For state vars, SVf_PADSTALE is overloaded to mean 'not yet initialised'


<P>




<PRE>
        AV *    CvPADLIST(CV *cv)

</PRE>


<DT>cv_clone<DD>
<A NAME="ixADE"></A>
<A NAME="ixADF"></A>
Clone a <FONT SIZE="-1">CV:</FONT> make a new <FONT SIZE="-1">CV</FONT> which points to the same code etc, but which
has a newly-created pad built by copying the prototype pad and capturing
any outer lexicals.


<P>




<PRE>
        CV*     cv_clone(CV* proto)

</PRE>


<DT>cv_dump<DD>
<A NAME="ixADG"></A>
<A NAME="ixADH"></A>
dump the contents of a <FONT SIZE="-1">CV</FONT>


<P>




<PRE>
        void    cv_dump(const CV *cv, const char *title)

</PRE>


<DT>do_dump_pad<DD>
<A NAME="ixADI"></A>
<A NAME="ixADJ"></A>
Dump the contents of a padlist


<P>




<PRE>
        void    do_dump_pad(I32 level, PerlIO *file, PADLIST *padlist, int full)

</PRE>


<DT>intro_my<DD>
<A NAME="ixADK"></A>
<A NAME="ixADL"></A>
``Introduce'' my variables to visible status.


<P>




<PRE>
        U32     intro_my()

</PRE>


<DT>pad_add_anon<DD>
<A NAME="ixADM"></A>
<A NAME="ixADN"></A>
Add an anon code entry to the current compiling pad


<P>




<PRE>
        PADOFFSET       pad_add_anon(SV* sv, OPCODE op_type)

</PRE>


<DT>pad_add_name<DD>
<A NAME="ixADO"></A>
<A NAME="ixADP"></A>
Create a new name and associated <FONT SIZE="-1">PADMY</FONT> <FONT SIZE="-1">SV</FONT> in the current pad; return the
offset.
If <TT>&quot;typestash&quot;</TT> is valid, the name is for a typed lexical; set the
name's stash to that value.
If <TT>&quot;ourstash&quot;</TT> is valid, it's an our lexical, set the name's
SvOURSTASH to that value


<P>


If fake, it means we're cloning an existing entry


<P>




<PRE>
        PADOFFSET       pad_add_name(const char *name, HV* typestash, HV* ourstash, bool clone, bool state)

</PRE>


<DT>pad_alloc<DD>
<A NAME="ixADQ"></A>
<A NAME="ixADR"></A>
Allocate a new my or tmp pad entry. For a my, simply push a null <FONT SIZE="-1">SV</FONT> onto
the end of PL_comppad, but for a tmp, scan the pad from PL_padix upwards
for a slot which has no name and no active value.


<P>




<PRE>
        PADOFFSET       pad_alloc(I32 optype, U32 tmptype)

</PRE>


<DT>pad_block_start<DD>
<A NAME="ixADS"></A>
<A NAME="ixADT"></A>
Update the pad compilation state variables on entry to a new block


<P>




<PRE>
        void    pad_block_start(int full)

</PRE>


<DT>pad_check_dup<DD>
<A NAME="ixADU"></A>
<A NAME="ixADV"></A>
Check for duplicate declarations: report any of:
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;a&nbsp;my&nbsp;in&nbsp;the&nbsp;current&nbsp;scope&nbsp;with&nbsp;the&nbsp;same&nbsp;name;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;an&nbsp;our&nbsp;(anywhere&nbsp;in&nbsp;the&nbsp;pad)&nbsp;with&nbsp;the&nbsp;same&nbsp;name&nbsp;and&nbsp;the&nbsp;same&nbsp;stash
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;<TT>&quot;ourstash&quot;</TT>
<TT>&quot;is_our&quot;</TT> indicates that the name to check is an 'our' declaration


<P>




<PRE>
        void    pad_check_dup(const char* name, bool is_our, const HV* ourstash)

</PRE>


<DT>pad_findlex<DD>
<A NAME="ixADW"></A>
<A NAME="ixADX"></A>
Find a named lexical anywhere in a chain of nested pads. Add fake entries
in the inner pads if it's found in an outer one.


<P>


Returns the offset in the bottom pad of the lex or the fake lex.
cv is the <FONT SIZE="-1">CV</FONT> in which to start the search, and seq is the current cop_seq
to match against. If warn is true, print appropriate warnings.  The out_*
vars return values, and so are pointers to where the returned values
should be stored. out_capture, if non-null, requests that the innermost
instance of the lexical is captured; out_name_sv is set to the innermost
matched namesv or fake namesv; out_flags returns the flags normally
associated with the <FONT SIZE="-1">IVX</FONT> field of a fake namesv.


<P>


Note that <I>pad_findlex()</I> is recursive; it recurses up the chain of CVs,
then comes back down, adding fake entries as it goes. It has to be this way
because fake namesvs in anon protoypes have to store in xlow the index into
the parent pad.


<P>




<PRE>
        PADOFFSET       pad_findlex(const char *name, const CV* cv, U32 seq, int warn, SV** out_capture, SV** out_name_sv, int *out_flags)

</PRE>


<DT>pad_findmy<DD>
<A NAME="ixADY"></A>
<A NAME="ixADZ"></A>
Given a lexical name, try to find its offset, first in the current pad,
or failing that, in the pads of any lexically enclosing subs (including
the complications introduced by eval). If the name is found in an outer pad,
then a fake entry is added to the current pad.
Returns the offset in the current pad, or <FONT SIZE="-1">NOT_IN_PAD</FONT> on failure.


<P>




<PRE>
        PADOFFSET       pad_findmy(const char* name)

</PRE>


<DT>pad_fixup_inner_anons<DD>
<A NAME="ixAEA"></A>
<A NAME="ixAEB"></A>
For any anon CVs in the pad, change CvOUTSIDE of that <FONT SIZE="-1">CV</FONT> from
old_cv to new_cv if necessary. Needed when a newly-compiled <FONT SIZE="-1">CV</FONT> has to be
moved to a pre-existing <FONT SIZE="-1">CV</FONT> struct.


<P>




<PRE>
        void    pad_fixup_inner_anons(PADLIST *padlist, CV *old_cv, CV *new_cv)

</PRE>


<DT>pad_free<DD>
<A NAME="ixAEC"></A>
<A NAME="ixAED"></A>
Free the <FONT SIZE="-1">SV</FONT> at offset po in the current pad.


<P>




<PRE>
        void    pad_free(PADOFFSET po)

</PRE>


<DT>pad_leavemy<DD>
<A NAME="ixAEE"></A>
<A NAME="ixAEF"></A>
Cleanup at end of scope during compilation: set the max seq number for
lexicals in this scope and warn of any lexicals that never got introduced.


<P>




<PRE>
        void    pad_leavemy()

</PRE>


<DT>pad_new<DD>
<A NAME="ixAEG"></A>
<A NAME="ixAEH"></A>
Create a new compiling padlist, saving and updating the various global
vars at the same time as creating the pad itself. The following flags
can be <FONT SIZE="-1">OR</FONT>'ed together:


<P>




<PRE>
    padnew_CLONE        this pad is for a cloned CV
    padnew_SAVE         save old globals
    padnew_SAVESUB      also save extra stuff for start of sub

        PADLIST*        pad_new(int flags)

</PRE>


<DT>pad_push<DD>
<A NAME="ixAEI"></A>
<A NAME="ixAEJ"></A>
Push a new pad frame onto the padlist, unless there's already a pad at
this depth, in which case don't bother creating a new one.  Then give
the new pad an <TT>@_</TT> in slot zero.


<P>




<PRE>
        void    pad_push(PADLIST *padlist, int depth)

</PRE>


<DT>pad_reset<DD>
<A NAME="ixAEK"></A>
<A NAME="ixAEL"></A>
Mark all the current temporaries for reuse


<P>




<PRE>
        void    pad_reset()

</PRE>


<DT>pad_setsv<DD>
<A NAME="ixAEM"></A>
<A NAME="ixAEN"></A>
Set the entry at offset po in the current pad to sv.
Use the macro <FONT SIZE="-1"><I>PAD_SETSV</I></FONT><I>()</I> rather than calling this function directly.


<P>




<PRE>
        void    pad_setsv(PADOFFSET po, SV* sv)

</PRE>


<DT>pad_swipe<DD>
<A NAME="ixAEO"></A>
<A NAME="ixAEP"></A>
Abandon the tmp in the current pad at offset po and replace with a
new one.


<P>




<PRE>
        void    pad_swipe(PADOFFSET po, bool refadjust)

</PRE>


<DT>pad_tidy<DD>
<A NAME="ixAEQ"></A>
<A NAME="ixAER"></A>
Tidy up a pad after we've finished compiling it:
<BR>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;remove&nbsp;most&nbsp;stuff&nbsp;from&nbsp;the&nbsp;pads&nbsp;of&nbsp;anonsub&nbsp;prototypes;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;give&nbsp;it&nbsp;a&nbsp;<TT>@_</TT>;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;mark&nbsp;tmps&nbsp;as&nbsp;such.


<P>




<PRE>
        void    pad_tidy(padtidy_type type)

</PRE>


<DT>pad_undef<DD>
<A NAME="ixAES"></A>
<A NAME="ixAET"></A>
Free the padlist associated with a <FONT SIZE="-1">CV</FONT>.
If parts of it happen to be current, we null the relevant
PL_*pad* global vars so that we don't have any dangling references left.
We also repoint the CvOUTSIDE of any about-to-be-orphaned
inner subs to the outer of this cv.


<P>


(This function should really be called pad_free, but the name was already
taken)


<P>




<PRE>
        void    pad_undef(CV* cv)

</PRE>


</DL>
<A NAME="lbAL">&nbsp;</A>
<H2>Per-Interpreter Variables</H2>

<A NAME="ixAEU"></A>
<DL COMPACT>
<DT>PL_DBsingle<DD>
<A NAME="ixAEV"></A>
<A NAME="ixAEW"></A>
When Perl is run in debugging mode, with the <B>-d</B> switch, this <FONT SIZE="-1">SV</FONT> is a
boolean which indicates whether subs are being single-stepped.
Single-stepping is automatically turned on after every step.  This is the C
variable which corresponds to Perl's <TT>$DB::single</TT> variable.  See
<TT>&quot;PL_DBsub&quot;</TT>.


<P>




<PRE>
        SV *    PL_DBsingle

</PRE>


<DT>PL_DBsub<DD>
<A NAME="ixAEX"></A>
<A NAME="ixAEY"></A>
When Perl is run in debugging mode, with the <B>-d</B> switch, this <FONT SIZE="-1">GV</FONT> contains
the <FONT SIZE="-1">SV</FONT> which holds the name of the sub being debugged.  This is the C
variable which corresponds to Perl's <TT>$DB::sub</TT> variable.  See
<TT>&quot;PL_DBsingle&quot;</TT>.


<P>




<PRE>
        GV *    PL_DBsub

</PRE>


<DT>PL_DBtrace<DD>
<A NAME="ixAEZ"></A>
<A NAME="ixAFA"></A>
Trace variable used when Perl is run in debugging mode, with the <B>-d</B>
switch.  This is the C variable which corresponds to Perl's <TT>$DB::trace</TT>
variable.  See <TT>&quot;PL_DBsingle&quot;</TT>.


<P>




<PRE>
        SV *    PL_DBtrace

</PRE>


<DT>PL_dowarn<DD>
<A NAME="ixAFB"></A>
<A NAME="ixAFC"></A>
The C variable which corresponds to Perl's $^W warning variable.


<P>




<PRE>
        bool    PL_dowarn

</PRE>


<DT>PL_last_in_gv<DD>
<A NAME="ixAFD"></A>
<A NAME="ixAFE"></A>
The <FONT SIZE="-1">GV</FONT> which was last used for a filehandle input operation. (<TT>&quot;&lt;FH&gt;&quot;</TT>)


<P>




<PRE>
        GV*     PL_last_in_gv

</PRE>


<DT>PL_ofs_sv<DD>
<A NAME="ixAFF"></A>
<A NAME="ixAFG"></A>
The output field separator - <TT>$,</TT> in Perl space.


<P>




<PRE>
        SV*     PL_ofs_sv

</PRE>


<DT>PL_rs<DD>
<A NAME="ixAFH"></A>
<A NAME="ixAFI"></A>
The input record separator - <TT>$/</TT> in Perl space.


<P>




<PRE>
        SV*     PL_rs

</PRE>


</DL>
<A NAME="lbAM">&nbsp;</A>
<H2>Stack Manipulation Macros</H2>

<A NAME="ixAFJ"></A>
<DL COMPACT>
<DT>djSP<DD>
<A NAME="ixAFK"></A>
<A NAME="ixAFL"></A>
Declare Just <TT>&quot;SP&quot;</TT>. This is actually identical to <TT>&quot;dSP&quot;</TT>, and declares
a local copy of perl's stack pointer, available via the <TT>&quot;SP&quot;</TT> macro.
See <TT>&quot;SP&quot;</TT>.  (Available for backward source code compatibility with the
old (Perl 5.005) thread model.)


<P>




<PRE>
                djSP;

</PRE>


<DT><FONT SIZE="-1">LVRET</FONT><DD>
<A NAME="ixAFM"></A>
<A NAME="ixAFN"></A>
True if this op will be the return value of an lvalue subroutine
</DL>
<A NAME="lbAN">&nbsp;</A>
<H2>SV Manipulation Functions</H2>

<A NAME="ixAFO"></A>
<DL COMPACT>
<DT>sv_add_arena<DD>
<A NAME="ixAFP"></A>
<A NAME="ixAFQ"></A>
Given a chunk of memory, link it to the head of the list of arenas,
and split it into a list of free SVs.


<P>




<PRE>
        void    sv_add_arena(char* ptr, U32 size, U32 flags)

</PRE>


<DT>sv_clean_all<DD>
<A NAME="ixAFR"></A>
<A NAME="ixAFS"></A>
Decrement the refcnt of each remaining <FONT SIZE="-1">SV</FONT>, possibly triggering a
cleanup. This function may have to be called multiple times to free
SVs which are in complex self-referential hierarchies.


<P>




<PRE>
        I32     sv_clean_all()

</PRE>


<DT>sv_clean_objs<DD>
<A NAME="ixAFT"></A>
<A NAME="ixAFU"></A>
Attempt to destroy all objects not yet freed


<P>




<PRE>
        void    sv_clean_objs()

</PRE>


<DT>sv_free_arenas<DD>
<A NAME="ixAFV"></A>
<A NAME="ixAFW"></A>
Deallocate the memory used by all arenas. Note that all the individual <FONT SIZE="-1">SV</FONT>
heads and bodies within the arenas must already have been freed.


<P>




<PRE>
        void    sv_free_arenas()

</PRE>


</DL>
<A NAME="lbAO">&nbsp;</A>
<H2>SV-Body Allocation</H2>

<A NAME="ixAFX"></A>
<DL COMPACT>
<DT>sv_2num<DD>
<A NAME="ixAFY"></A>
<A NAME="ixAFZ"></A>
Return an <FONT SIZE="-1">SV</FONT> with the numeric value of the source <FONT SIZE="-1">SV</FONT>, doing any necessary
reference or overload conversion.  You must use the <TT>&quot;SvNUM(sv)&quot;</TT> macro to
access this function.


<P>




<PRE>
        SV*     sv_2num(SV* sv)

</PRE>


</DL>
<A NAME="lbAP">&nbsp;</A>
<H2>Unicode Support</H2>

<A NAME="ixAGA"></A>
<DL COMPACT>
<DT>find_uninit_var<DD>
<A NAME="ixAGB"></A>
<A NAME="ixAGC"></A>
Find the name of the undefined variable (if any) that caused the operator o
to issue a ``Use of uninitialized value'' warning.
If match is true, only return a name if it's value matches uninit_sv.
So roughly speaking, if a unary operator (such as <FONT SIZE="-1">OP_COS</FONT>) generates a
warning, then following the direct child of the op may yield an
<FONT SIZE="-1">OP_PADSV</FONT> or <FONT SIZE="-1">OP_GV</FONT> that gives the name of the undefined variable. On the
other hand, with <FONT SIZE="-1">OP_ADD</FONT> there are two branches to follow, so we only print
the variable name if we get an exact match.


<P>


The name is returned as a mortal <FONT SIZE="-1">SV</FONT>.


<P>


Assumes that PL_op is the op that originally triggered the error, and that
PL_comppad/PL_curpad points to the currently executing pad.


<P>




<PRE>
        SV*     find_uninit_var(OP* obase, SV* uninit_sv, bool top)

</PRE>


<DT>report_uninit<DD>
<A NAME="ixAGD"></A>
<A NAME="ixAGE"></A>
Print appropriate ``Use of uninitialized variable'' warning


<P>




<PRE>
        void    report_uninit(SV* uninit_sv)

</PRE>


</DL>
<A NAME="lbAQ">&nbsp;</A>
<H2>AUTHORS</H2>

<A NAME="ixAGF"></A>
The autodocumentation system was originally added to the Perl core by
Benjamin Stuhl. Documentation is by whoever was kind enough to
document their functions.
<A NAME="lbAR">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAGG"></A>
<I><A HREF="/manpages/index.html?1+perlguts">perlguts</A></I>(1), <I><A HREF="http://localhost/cgi-bin/man/man2html?1+perlapi">perlapi</A></I>(1)
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">DESCRIPTION</A><DD>
<DT><A HREF="#lbAD">CV reference counts and CvOUTSIDE</A><DD>
<DT><A HREF="#lbAE">Functions in file pad.h</A><DD>
<DT><A HREF="#lbAF">GV Functions</A><DD>
<DT><A HREF="#lbAG">Hash Manipulation Functions</A><DD>
<DT><A HREF="#lbAH">IO Functions</A><DD>
<DT><A HREF="#lbAI">Magical Functions</A><DD>
<DT><A HREF="#lbAJ">MRO Functions</A><DD>
<DT><A HREF="#lbAK">Pad Data Structures</A><DD>
<DT><A HREF="#lbAL">Per-Interpreter Variables</A><DD>
<DT><A HREF="#lbAM">Stack Manipulation Macros</A><DD>
<DT><A HREF="#lbAN">SV Manipulation Functions</A><DD>
<DT><A HREF="#lbAO">SV-Body Allocation</A><DD>
<DT><A HREF="#lbAP">Unicode Support</A><DD>
<DT><A HREF="#lbAQ">AUTHORS</A><DD>
<DT><A HREF="#lbAR">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:29:08 GMT, December 24, 2015
</div></body>
</HTML>
