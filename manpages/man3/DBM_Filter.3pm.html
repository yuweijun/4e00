<!DOCTYPE html>

<HTML><head><TITLE>Manpage of DBM_Filter</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>DBM_Filter</H1>
Section: Perl Programmers Reference Guide (3pm)<BR>Updated: 2009-02-12<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

DBM_Filter -- Filter DBM keys/values
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
    use DBM_Filter ;
    use SDBM_File; # or DB_File, or GDBM_File, or NDBM_File, or ODBM_File

    $db = tie %hash, ...

    $db-&gt;Filter_Push(Fetch =&gt; sub {...},
                     Store =&gt; sub {...});

    $db-&gt;Filter_Push('my_filter1');
    $db-&gt;Filter_Push('my_filter2', params...);

    $db-&gt;Filter_Key_Push(...) ;
    $db-&gt;Filter_Value_Push(...) ;

    $db-&gt;Filter_Pop();
    $db-&gt;Filtered();

    package DBM_Filter::my_filter1;
    
    sub Store { ... }
    sub Fetch { ... }

    1;

    package DBM_Filter::my_filter2;

    sub Filter
    {
        my @opts = @_;
        ...
        return (
            sub Store { ... },
            sub Fetch { ... } );
    }

    1;

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
This module provides an interface that allows filters to be applied
to tied Hashes associated with <FONT SIZE="-1">DBM</FONT> files. It builds on the <FONT SIZE="-1">DBM</FONT> Filter
hooks that are present in all the *DB*_File modules included with the
standard Perl source distribution from version 5.6.1 onwards. In addition
to the *DB*_File modules distributed with Perl, the BerkeleyDB module,
available on <FONT SIZE="-1">CPAN</FONT>, supports the <FONT SIZE="-1">DBM</FONT> Filter hooks. See perldbmfilter
for more details on the <FONT SIZE="-1">DBM</FONT> Filter hooks.
<A NAME="lbAE">&nbsp;</A>
<H2>What is a DBM Filter?</H2>

<A NAME="ixAAE"></A>
A <FONT SIZE="-1">DBM</FONT> Filter allows the keys and/or values in a tied hash to be modified
by some user-defined code just before it is written to the <FONT SIZE="-1">DBM</FONT> file and
just after it is read back from the <FONT SIZE="-1">DBM</FONT> file. For example, this snippet
of code
<P>



<PRE>
    $some_hash{&quot;abc&quot;} = 42;

</PRE>


<P>

could potentially trigger two filters, one for the writing of the key
``abc'' and another for writing the value 42.  Similarly, this snippet
<P>



<PRE>
    my ($key, $value) = each %some_hash

</PRE>


<P>

will trigger two filters, one for the reading of the key and one for
the reading of the value.
<P>

Like the existing <FONT SIZE="-1">DBM</FONT> Filter functionality, this module arranges for the
<TT>$_</TT> variable to be populated with the key or value that a filter will
check. This usually means that most <FONT SIZE="-1">DBM</FONT> filters tend to be very short.
<A NAME="lbAF">&nbsp;</A>
<H3>So what's new?</H3>

<A NAME="ixAAF"></A>
The main enhancements over the standard <FONT SIZE="-1">DBM</FONT> Filter hooks are:
<DL COMPACT>
<DT>*<DD>
A cleaner interface.
<DT>*<DD>
The ability to easily apply multiple filters to a single <FONT SIZE="-1">DBM</FONT> file.
<DT>*<DD>
The ability to create ``canned'' filters. These allow commonly used filters
to be packaged into a stand-alone module.
</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>METHODS</H2>

<A NAME="ixAAG"></A>
This module will arrange for the following methods to be available via
the object returned from the <TT>&quot;tie&quot;</TT> call.
<A NAME="lbAH">&nbsp;</A>
<H3>$db-&gt;<I>Filter_Push()</I></H3>



<A NAME="ixAAH"></A>
<A NAME="lbAI">&nbsp;</A>
<H3>$db-&gt;<I>Filter_Key_Push()</I></H3>



<A NAME="ixAAI"></A>
<A NAME="lbAJ">&nbsp;</A>
<H3>$db-&gt;<I>Filter_Value_Push()</I></H3>



<A NAME="ixAAJ"></A>
Add a filter to filter stack for the database, <TT>$db</TT>. The three formats
vary only in whether they apply to the <FONT SIZE="-1">DBM</FONT> key, the <FONT SIZE="-1">DBM</FONT> value or both.
<DL COMPACT>
<DT>Filter_Push<DD>
<A NAME="ixAAK"></A>
The filter is applied to <I>both</I> keys and values.
<DT>Filter_Key_Push<DD>
<A NAME="ixAAL"></A>
The filter is applied to the key <I>only</I>.
<DT>Filter_Value_Push<DD>
<A NAME="ixAAM"></A>
The filter is applied to the value <I>only</I>.
</DL>
<A NAME="lbAK">&nbsp;</A>
<H3>$db-&gt;<I>Filter_Pop()</I></H3>



<A NAME="ixAAN"></A>
Removes the last filter that was applied to the <FONT SIZE="-1">DBM</FONT> file associated with
<TT>$db</TT>, if present.
<A NAME="lbAL">&nbsp;</A>
<H3>$db-&gt;<I>Filtered()</I></H3>



<A NAME="ixAAO"></A>
Returns <FONT SIZE="-1">TRUE</FONT> if there are any filters applied to the <FONT SIZE="-1">DBM</FONT> associated
with <TT>$db</TT>.  Otherwise returns <FONT SIZE="-1">FALSE</FONT>.
<A NAME="lbAM">&nbsp;</A>
<H2>Writing a Filter</H2>

<A NAME="ixAAP"></A>
Filters can be created in two main ways
<A NAME="lbAN">&nbsp;</A>
<H3>Immediate Filters</H3>

<A NAME="ixAAQ"></A>
An immediate filter allows you to specify the filter code to be used
at the point where the filter is applied to a dbm. In this mode the
Filter_*_Push methods expects to receive exactly two parameters.
<P>



<PRE>
    my $db = tie %hash, 'SDBM_File', ...
    $db-&gt;Filter_Push( Store =&gt; sub { },
                      Fetch =&gt; sub { });

</PRE>


<P>

The code reference associated with <TT>&quot;Store&quot;</TT> will be called before any
key/value is written to the database and the code reference associated
with <TT>&quot;Fetch&quot;</TT> will be called after any key/value is read from the
database.
<P>

For example, here is a sample filter that adds a trailing <FONT SIZE="-1">NULL</FONT> character
to all strings before they are written to the <FONT SIZE="-1">DBM</FONT> file, and removes the
trailing <FONT SIZE="-1">NULL</FONT> when they are read from the <FONT SIZE="-1">DBM</FONT> file
<P>



<PRE>
    my $db = tie %hash, 'SDBM_File', ...
    $db-&gt;Filter_Push( Store =&gt; sub { $_ .= &quot;\x00&quot; ; },
                      Fetch =&gt; sub { s/\x00$// ;    });

</PRE>


<P>

Points to note:
<DL COMPACT>
<DT>1.<DD>
Both the Store and Fetch filters manipulate <TT>$_</TT>.
</DL>
<A NAME="lbAO">&nbsp;</A>
<H3>Canned Filters</H3>

<A NAME="ixAAR"></A>
Immediate filters are useful for one-off situations. For more generic
problems it can be useful to package the filter up in its own module.
<P>

The usage is for a canned filter is:
<P>



<PRE>
    $db-&gt;Filter_Push(&quot;name&quot;, params)

</PRE>


<P>

where
<DL COMPACT>
<DT>name<DD>


<A NAME="ixAAS"></A>
is the name of the module to load. If the string specified does not
contain the package separator characters ``::'', it is assumed to refer to
the full module name ``DBM_Filter::name''. This means that the full names
for canned filters, ``null'' and ``utf8'', included with this module are:


<P>




<PRE>
    DBM_Filter::null
    DBM_Filter::utf8

</PRE>


<DT>params<DD>
<A NAME="ixAAT"></A>
any optional parameters that need to be sent to the filter. See the
encode filter for an example of a module that uses parameters.
</DL>
<P>

The module that implements the canned filter can take one of two
forms. Here is a template for the first
<P>



<PRE>
    package DBM_Filter::null ;

    use strict;
    use warnings;

    sub Store 
    {
        # store code here    
    }

    sub Fetch
    {
        # fetch code here
    }

    1;

</PRE>


<P>

Notes:
<DL COMPACT>
<DT>1.<DD>
The package name uses the <TT>&quot;DBM_Filter::&quot;</TT> prefix.
<DT>2.<DD>
The module <I>must</I> have both a Store and a Fetch method. If only one is
present, or neither are present, a fatal error will be thrown.
</DL>
<P>

The second form allows the filter to hold state information using a
closure, thus:
<P>



<PRE>
    package DBM_Filter::encoding ;

    use strict;
    use warnings;

    sub Filter
    {
        my @params = @_ ;

        ...
        return {
            Store   =&gt; sub { $_ = $encoding-&gt;encode($_) },
            Fetch   =&gt; sub { $_ = $encoding-&gt;decode($_) }
            } ;
    }

    1;

</PRE>


<P>

In this instance the ``Store'' and ``Fetch'' methods are encapsulated inside a
``Filter'' method.
<A NAME="lbAP">&nbsp;</A>
<H2>Filters Included</H2>

<A NAME="ixAAU"></A>
A number of canned filers are provided with this module. They cover a
number of the main areas that filters are needed when interfacing with
<FONT SIZE="-1">DBM</FONT> files. They also act as templates for your own filters.
<P>

The filter included are:
<DL COMPACT>
<DT>*<DD>
utf8


<P>


This module will ensure that all data written to the <FONT SIZE="-1">DBM</FONT> will be encoded
in <FONT SIZE="-1">UTF-8</FONT>.


<P>


This module needs the Encode module.
<DT>*<DD>
encode


<P>


Allows you to choose the character encoding will be store in the <FONT SIZE="-1">DBM</FONT> file.
<DT>*<DD>
compress


<P>


This filter will compress all data before it is written to the database
and uncompressed it on reading.


<P>


This module needs Compress::Zlib.
<DT>*<DD>
int32


<P>


This module is used when interoperating with a C/C<FONT SIZE="-2">++</FONT> application that
uses a C int as either the key and/or value in the <FONT SIZE="-1">DBM</FONT> file.
<DT>*<DD>
null


<P>


This module ensures that all data written to the <FONT SIZE="-1">DBM</FONT> file is null
terminated. This is useful when you have a perl script that needs
to interoperate with a <FONT SIZE="-1">DBM</FONT> file that a C program also uses. A fairly
common issue is for the C application to include the terminating null
in a string when it writes to the <FONT SIZE="-1">DBM</FONT> file. This filter will ensure that
all data written to the <FONT SIZE="-1">DBM</FONT> file can be read by the C application.
</DL>
<A NAME="lbAQ">&nbsp;</A>
<H2>NOTES</H2>

<A NAME="ixAAV"></A>
<A NAME="lbAR">&nbsp;</A>
<H3>Maintain Round Trip Integrity</H3>

<A NAME="ixAAW"></A>
When writing a <FONT SIZE="-1">DBM</FONT> filter it is <I>very</I> important to ensure that it is
possible to retrieve all data that you have written when the <FONT SIZE="-1">DBM</FONT> filter
is in place. In practice, this means that whatever transformation is
applied to the data in the Store method, the <I>exact</I> inverse operation
should be applied in the Fetch method.
<P>

If you don't provide an exact inverse transformation, you will find that
code like this will not behave as you expect.
<P>



<PRE>
     while (my ($k, $v) = each %hash)
     {
         ...
     }

</PRE>


<P>

Depending on the transformation, you will find that one or more of the
following will happen
<DL COMPACT>
<DT>1.<DD>
The loop will never terminate.
<DT>2.<DD>
Too few records will be retrieved.
<DT>3.<DD>
Too many will be retrieved.
<DT>4.<DD>
The loop will do the right thing for a while, but it will unexpectedly fail.
</DL>
<A NAME="lbAS">&nbsp;</A>
<H3>Don't mix filtered &amp; non-filtered data in the same database file.</H3>

<A NAME="ixAAX"></A>
This is just a restatement of the previous section. Unless you are
completely certain you know what you are doing, avoid mixing filtered &amp;
non-filtered data.
<A NAME="lbAT">&nbsp;</A>
<H2>EXAMPLE</H2>

<A NAME="ixAAY"></A>
Say you need to interoperate with a legacy C application that stores
keys as C ints and the values and null terminated <FONT SIZE="-1">UTF-8</FONT> strings. Here
is how you would set that up
<P>



<PRE>
    my $db = tie %hash, 'SDBM_File', ...

    $db-&gt;Filter_Key_Push('int32') ;

    $db-&gt;Filter_Value_Push('utf8');
    $db-&gt;Filter_Value_Push('null');

</PRE>


<A NAME="lbAU">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAZ"></A>
&lt;DB_File&gt;,  GDBM_File, NDBM_File, ODBM_File, SDBM_File, perldbmfilter
<A NAME="lbAV">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixABA"></A>
Paul Marquess &lt;<A HREF="mailto:pmqs@cpan.org">pmqs@cpan.org</A>&gt;
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">What is a DBM Filter?</A><DD>
<DL>
<DT><A HREF="#lbAF">So what's new?</A><DD>
</DL>
<DT><A HREF="#lbAG">METHODS</A><DD>
<DL>
<DT><A HREF="#lbAH">$db-&gt;<I>Filter_Push()</I></A><DD>
<DT><A HREF="#lbAI">$db-&gt;<I>Filter_Key_Push()</I></A><DD>
<DT><A HREF="#lbAJ">$db-&gt;<I>Filter_Value_Push()</I></A><DD>
<DT><A HREF="#lbAK">$db-&gt;<I>Filter_Pop()</I></A><DD>
<DT><A HREF="#lbAL">$db-&gt;<I>Filtered()</I></A><DD>
</DL>
<DT><A HREF="#lbAM">Writing a Filter</A><DD>
<DL>
<DT><A HREF="#lbAN">Immediate Filters</A><DD>
<DT><A HREF="#lbAO">Canned Filters</A><DD>
</DL>
<DT><A HREF="#lbAP">Filters Included</A><DD>
<DT><A HREF="#lbAQ">NOTES</A><DD>
<DL>
<DT><A HREF="#lbAR">Maintain Round Trip Integrity</A><DD>
<DT><A HREF="#lbAS">Don't mix filtered &amp; non-filtered data in the same database file.</A><DD>
</DL>
<DT><A HREF="#lbAT">EXAMPLE</A><DD>
<DT><A HREF="#lbAU">SEE ALSO</A><DD>
<DT><A HREF="#lbAV">AUTHOR</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:22 GMT, December 24, 2015
</div></body>
</HTML>
