<!DOCTYPE html>

<HTML><head><TITLE>Manpage of File::Temp</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>File::Temp</H1>
Section: Perl Programmers Reference Guide (3pm)<BR>Updated: 2009-06-30<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

File::Temp - return name and handle of a temporary file safely
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
  use File::Temp qw/ tempfile tempdir /;

  $fh = tempfile();
  ($fh, $filename) = tempfile();

  ($fh, $filename) = tempfile( $template, DIR =&gt; $dir);
  ($fh, $filename) = tempfile( $template, SUFFIX =&gt; '.dat');
  ($fh, $filename) = tempfile( $template, TMPDIR =&gt; 1 );

  binmode( $fh, &quot;:utf8&quot; );

  $dir = tempdir( CLEANUP =&gt; 1 );
  ($fh, $filename) = tempfile( DIR =&gt; $dir );

</PRE>


<P>

Object interface:
<P>



<PRE>
  require File::Temp;
  use File::Temp ();
  use File::Temp qw/ :seekable /;

  $fh = File::Temp-&gt;new();
  $fname = $fh-&gt;filename;

  $fh = File::Temp-&gt;new(TEMPLATE =&gt; $template);
  $fname = $fh-&gt;filename;

  $tmp = File::Temp-&gt;new( UNLINK =&gt; 0, SUFFIX =&gt; '.dat' );
  print $tmp &quot;Some data\n&quot;;
  print &quot;Filename is $tmp\n&quot;;
  $tmp-&gt;seek( 0, SEEK_END );

</PRE>


<P>

The following interfaces are provided for compatibility with
existing APIs. They should not be used in new code.
<P>

MkTemp family:
<P>



<PRE>
  use File::Temp qw/ :mktemp  /;

  ($fh, $file) = mkstemp( &quot;tmpfileXXXXX&quot; );
  ($fh, $file) = mkstemps( &quot;tmpfileXXXXXX&quot;, $suffix);

  $tmpdir = mkdtemp( $template );

  $unopened_file = mktemp( $template );

</PRE>


<P>

<FONT SIZE="-1">POSIX</FONT> functions:
<P>



<PRE>
  use File::Temp qw/ :POSIX /;

  $file = tmpnam();
  $fh = tmpfile();

  ($fh, $file) = tmpnam();

</PRE>


<P>

Compatibility functions:
<P>



<PRE>
  $unopened_file = File::Temp::tempnam( $dir, $pfx );

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
<TT>&quot;File::Temp&quot;</TT> can be used to create and open temporary files in a safe
way.  There is both a function interface and an object-oriented
interface.  The File::Temp constructor or the <I>tempfile()</I> function can
be used to return the name and the open filehandle of a temporary
file.  The <I>tempdir()</I> function can be used to create a temporary
directory.
<P>

The security aspect of temporary file creation is emphasized such that
a filehandle and filename are returned together.  This helps guarantee
that a race condition can not occur where the temporary file is
created by another process between checking for the existence of the
file and its opening.  Additional security levels are provided to
check, for example, that the sticky bit is set on world writable
directories.  See ``safe_level'' for more information.
<P>

For compatibility with popular C library functions, Perl implementations of
the <I>mkstemp()</I> family of functions are provided. These are, <I>mkstemp()</I>,
<I>mkstemps()</I>, <I>mkdtemp()</I> and <I>mktemp()</I>.
<P>

Additionally, implementations of the standard <FONT SIZE="-1">POSIX</FONT>
<I>tmpnam()</I> and <I>tmpfile()</I> functions are provided if required.
<P>

Implementations of <I>mktemp()</I>, <I>tmpnam()</I>, and <I>tempnam()</I> are provided,
but should be used with caution since they return only a filename
that was valid when function was called, so cannot guarantee
that the file will not exist by the time the caller opens the filename.
<P>

Filehandles returned by these functions support the seekable methods.
<A NAME="lbAE">&nbsp;</A>
<H2>OBJECT-ORIENTED INTERFACE</H2>

<A NAME="ixAAE"></A>
This is the primary interface for interacting with
<TT>&quot;File::Temp&quot;</TT>. Using the <FONT SIZE="-1">OO</FONT> interface a temporary file can be created
when the object is constructed and the file can be removed when the
object is no longer required.
<P>

Note that there is no method to obtain the filehandle from the
<TT>&quot;File::Temp&quot;</TT> object. The object itself acts as a filehandle. Also,
the object is configured such that it stringifies to the name of the
temporary file, and can be compared to a filename directly. The object
isa <TT>&quot;IO::Handle&quot;</TT> and isa <TT>&quot;IO::Seekable&quot;</TT> so all those methods are
available.
<DL COMPACT>
<DT><B>new</B><DD>
<A NAME="ixAAF"></A>
Create a temporary file object.


<P>




<PRE>
  my $tmp = File::Temp-&gt;new();

</PRE>




<P>


by default the object is constructed as if <TT>&quot;tempfile&quot;</TT>
was called without options, but with the additional behaviour
that the temporary file is removed by the object destructor
if <FONT SIZE="-1">UNLINK</FONT> is set to true (the default).


<P>


Supported arguments are the same as for <TT>&quot;tempfile&quot;</TT>: <FONT SIZE="-1">UNLINK</FONT>
(defaulting to true), <FONT SIZE="-1">DIR</FONT>, <FONT SIZE="-1">EXLOCK</FONT> and <FONT SIZE="-1">SUFFIX</FONT>. Additionally, the filename
template is specified using the <FONT SIZE="-1">TEMPLATE</FONT> option. The <FONT SIZE="-1">OPEN</FONT> option
is not supported (the file is always opened).


<P>




<PRE>
 $tmp = File::Temp-&gt;new( TEMPLATE =&gt; 'tempXXXXX',
                        DIR =&gt; 'mydir',
                        SUFFIX =&gt; '.dat');

</PRE>




<P>


Arguments are case insensitive.


<P>


Can call <I>croak()</I> if an error occurs.
<DT><B>newdir</B><DD>
<A NAME="ixAAG"></A>
Create a temporary directory using an object oriented interface.


<P>




<PRE>
  $dir = File::Temp-&gt;newdir();

</PRE>




<P>


By default the directory is deleted when the object goes out of scope.


<P>


Supports the same options as the <TT>&quot;tempdir&quot;</TT> function. Note that directories
created with this method default to <FONT SIZE="-1">CLEANUP</FONT> =&gt; 1.


<P>




<PRE>
  $dir = File::Temp-&gt;newdir( $template, %options );

</PRE>


<DT><B>filename</B><DD>
<A NAME="ixAAH"></A>
Return the name of the temporary file associated with this object
(if the object was created using the ``new'' constructor).


<P>




<PRE>
  $filename = $tmp-&gt;filename;

</PRE>




<P>


This method is called automatically when the object is used as
a string.
<DT><B>dirname</B><DD>
<A NAME="ixAAI"></A>
Return the name of the temporary directory associated with this
object (if the object was created using the ``newdir'' constructor).


<P>




<PRE>
  $dirname = $tmpdir-&gt;dirname;

</PRE>




<P>


This method is called automatically when the object is used in string context.
<DT><B>unlink_on_destroy</B><DD>
<A NAME="ixAAJ"></A>
Control whether the file is unlinked when the object goes out of scope.
The file is removed if this value is true and <TT>$KEEP_ALL</TT> is not.


<P>




<PRE>
 $fh-&gt;unlink_on_destroy( 1 );

</PRE>




<P>


Default is for the file to be removed.
<DT><B></B><FONT SIZE="-1"><B>DESTROY</B></FONT><B></B><DD>
<A NAME="ixAAK"></A>
When the object goes out of scope, the destructor is called. This
destructor will attempt to unlink the file (using <TT>&quot;unlink1&quot;</TT>)
if the constructor was called with <FONT SIZE="-1">UNLINK</FONT> set to 1 (the default state
if <FONT SIZE="-1">UNLINK</FONT> is not specified).


<P>


No error is given if the unlink fails.


<P>


If the object has been passed to a child process during a fork, the
file will be deleted when the object goes out of scope in the parent.


<P>


For a temporary directory object the directory will be removed
unless the <FONT SIZE="-1">CLEANUP</FONT> argument was used in the constructor (and set to
false) or <TT>&quot;unlink_on_destroy&quot;</TT> was modified after creation.


<P>


If the global variable <TT>$KEEP_ALL</TT> is true, the file or directory
will not be removed.
</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>FUNCTIONS</H2>

<A NAME="ixAAL"></A>
This section describes the recommended interface for generating
temporary files and directories.
<DL COMPACT>
<DT><B>tempfile</B><DD>
<A NAME="ixAAM"></A>
This is the basic function to generate temporary files.
The behaviour of the file can be changed using various options:


<P>




<PRE>
  $fh = tempfile();
  ($fh, $filename) = tempfile();

</PRE>




<P>


Create a temporary file in  the directory specified for temporary
files, as specified by the <I>tmpdir()</I> function in File::Spec.


<P>




<PRE>
  ($fh, $filename) = tempfile($template);

</PRE>




<P>


Create a temporary file in the current directory using the supplied
template.  Trailing `X' characters are replaced with random letters to
generate the filename.  At least four `X' characters must be present
at the end of the template.


<P>




<PRE>
  ($fh, $filename) = tempfile($template, SUFFIX =&gt; $suffix)

</PRE>




<P>


Same as previously, except that a suffix is added to the template
after the `X' translation.  Useful for ensuring that a temporary
filename has a particular extension when needed by other applications.
But see the <FONT SIZE="-1">WARNING</FONT> at the end.


<P>




<PRE>
  ($fh, $filename) = tempfile($template, DIR =&gt; $dir);

</PRE>




<P>


Translates the template as before except that a directory name
is specified.


<P>




<PRE>
  ($fh, $filename) = tempfile($template, TMPDIR =&gt; 1);

</PRE>




<P>


Equivalent to specifying a <FONT SIZE="-1">DIR</FONT> of ``File::Spec-&gt;tmpdir'', writing the file
into the same temporary directory as would be used if no template was
specified at all.


<P>




<PRE>
  ($fh, $filename) = tempfile($template, UNLINK =&gt; 1);

</PRE>




<P>


Return the filename and filehandle as before except that the file is
automatically removed when the program exits (dependent on
<TT>$KEEP_ALL</TT>). Default is for the file to be removed if a file handle is
requested and to be kept if the filename is requested. In a scalar
context (where no filename is returned) the file is always deleted
either (depending on the operating system) on exit or when it is
closed (unless <TT>$KEEP_ALL</TT> is true when the temp file is created).


<P>


Use the object-oriented interface if fine-grained control of when
a file is removed is required.


<P>


If the template is not specified, a template is always
automatically generated. This temporary file is placed in <I>tmpdir()</I>
(File::Spec) unless a directory is specified explicitly with the
<FONT SIZE="-1">DIR</FONT> option.


<P>




<PRE>
  $fh = tempfile( DIR =&gt; $dir );

</PRE>




<P>


If called in scalar context, only the filehandle is returned and the
file will automatically be deleted when closed on operating systems
that support this (see the description of <I>tmpfile()</I> elsewhere in this
document).  This is the preferred mode of operation, as if you only
have a filehandle, you can never create a race condition by fumbling
with the filename. On systems that can not unlink an open file or can
not mark a file as temporary when it is opened (for example, Windows
<FONT SIZE="-1">NT</FONT> uses the <TT>&quot;O_TEMPORARY&quot;</TT> flag) the file is marked for deletion when
the program ends (equivalent to setting <FONT SIZE="-1">UNLINK</FONT> to 1). The <TT>&quot;UNLINK&quot;</TT>
flag is ignored if present.


<P>




<PRE>
  (undef, $filename) = tempfile($template, OPEN =&gt; 0);

</PRE>




<P>


This will return the filename based on the template but
will not open this file.  Cannot be used in conjunction with
<FONT SIZE="-1">UNLINK</FONT> set to true. Default is to always open the file
to protect from possible race conditions. A warning is issued
if warnings are turned on. Consider using the <I>tmpnam()</I>
and <I>mktemp()</I> functions described elsewhere in this document
if opening the file is not required.


<P>


If the operating system supports it (for example <FONT SIZE="-1">BSD</FONT> derived systems), the 
filehandle will be opened with O_EXLOCK (open with exclusive file lock). 
This can sometimes cause problems if the intention is to pass the filename 
to another system that expects to take an exclusive lock itself (such as 
DBD::SQLite) whilst ensuring that the tempfile is not reused. In this 
situation the ``<FONT SIZE="-1">EXLOCK</FONT>'' option can be passed to tempfile. By default <FONT SIZE="-1">EXLOCK</FONT> 
will be true (this retains compatibility with earlier releases).


<P>




<PRE>
  ($fh, $filename) = tempfile($template, EXLOCK =&gt; 0);

</PRE>




<P>


Options can be combined as required.


<P>


Will <I>croak()</I> if there is an error.
<DT><B>tempdir</B><DD>
<A NAME="ixAAN"></A>
This is the recommended interface for creation of temporary
directories.  By default the directory will not be removed on exit
(that is, it won't be temporary; this behaviour can not be changed
because of issues with backwards compatibility). To enable removal
either use the <FONT SIZE="-1">CLEANUP</FONT> option which will trigger removal on program
exit, or consider using the ``newdir'' method in the object interface which
will allow the directory to be cleaned up when the object goes out of
scope.


<P>


The behaviour of the function depends on the arguments:


<P>




<PRE>
  $tempdir = tempdir();

</PRE>




<P>


Create a directory in <I>tmpdir()</I> (see File::Spec).


<P>




<PRE>
  $tempdir = tempdir( $template );

</PRE>




<P>


Create a directory from the supplied template. This template is
similar to that described for <I>tempfile()</I>. `X' characters at the end
of the template are replaced with random letters to construct the
directory name. At least four `X' characters must be in the template.


<P>




<PRE>
  $tempdir = tempdir ( DIR =&gt; $dir );

</PRE>




<P>


Specifies the directory to use for the temporary directory.
The temporary directory name is derived from an internal template.


<P>




<PRE>
  $tempdir = tempdir ( $template, DIR =&gt; $dir );

</PRE>




<P>


Prepend the supplied directory name to the template. The template
should not include parent directory specifications itself. Any parent
directory specifications are removed from the template before
prepending the supplied directory.


<P>




<PRE>
  $tempdir = tempdir ( $template, TMPDIR =&gt; 1 );

</PRE>




<P>


Using the supplied template, create the temporary directory in
a standard location for temporary files. Equivalent to doing


<P>




<PRE>
  $tempdir = tempdir ( $template, DIR =&gt; File::Spec-&gt;tmpdir);

</PRE>




<P>


but shorter. Parent directory specifications are stripped from the
template itself. The <TT>&quot;TMPDIR&quot;</TT> option is ignored if <TT>&quot;DIR&quot;</TT> is set
explicitly.  Additionally, <TT>&quot;TMPDIR&quot;</TT> is implied if neither a template
nor a directory are supplied.


<P>




<PRE>
  $tempdir = tempdir( $template, CLEANUP =&gt; 1);

</PRE>




<P>


Create a temporary directory using the supplied template, but
attempt to remove it (and all files inside it) when the program
exits. Note that an attempt will be made to remove all files from
the directory even if they were not created by this module (otherwise
why ask to clean it up?). The directory removal is made with
the <I>rmtree()</I> function from the File::Path module.
Of course, if the template is not specified, the temporary directory
will be created in <I>tmpdir()</I> and will also be removed at program exit.


<P>


Will <I>croak()</I> if there is an error.
</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>MKTEMP FUNCTIONS</H2>

<A NAME="ixAAO"></A>
The following functions are Perl implementations of the
<I>mktemp()</I> family of temp file generation system calls.
<DL COMPACT>
<DT><B>mkstemp</B><DD>
<A NAME="ixAAP"></A>
Given a template, returns a filehandle to the temporary file and the name
of the file.


<P>




<PRE>
  ($fh, $name) = mkstemp( $template );

</PRE>




<P>


In scalar context, just the filehandle is returned.


<P>


The template may be any filename with some number of X's appended
to it, for example <I>/tmp/temp.XXXX</I>. The trailing X's are replaced
with unique alphanumeric combinations.


<P>


Will <I>croak()</I> if there is an error.
<DT><B>mkstemps</B><DD>
<A NAME="ixAAQ"></A>
Similar to <I>mkstemp()</I>, except that an extra argument can be supplied
with a suffix to be appended to the template.


<P>




<PRE>
  ($fh, $name) = mkstemps( $template, $suffix );

</PRE>




<P>


For example a template of <TT>&quot;testXXXXXX&quot;</TT> and suffix of <TT>&quot;.dat&quot;</TT>
would generate a file similar to <I>testhGji_w.dat</I>.


<P>


Returns just the filehandle alone when called in scalar context.


<P>


Will <I>croak()</I> if there is an error.
<DT><B>mkdtemp</B><DD>
<A NAME="ixAAR"></A>
Create a directory from a template. The template must end in
X's that are replaced by the routine.


<P>




<PRE>
  $tmpdir_name = mkdtemp($template);

</PRE>




<P>


Returns the name of the temporary directory created.


<P>


Directory must be removed by the caller.


<P>


Will <I>croak()</I> if there is an error.
<DT><B>mktemp</B><DD>
<A NAME="ixAAS"></A>
Returns a valid temporary filename but does not guarantee
that the file will not be opened by someone else.


<P>




<PRE>
  $unopened_file = mktemp($template);

</PRE>




<P>


Template is the same as that required by <I>mkstemp()</I>.


<P>


Will <I>croak()</I> if there is an error.
</DL>
<A NAME="lbAH">&nbsp;</A>
<H2>POSIX FUNCTIONS</H2>

<A NAME="ixAAT"></A>
This section describes the re-implementation of the <I>tmpnam()</I>
and <I>tmpfile()</I> functions described in <FONT SIZE="-1">POSIX</FONT>
using the <I>mkstemp()</I> from this module.
<P>

Unlike the <FONT SIZE="-1">POSIX</FONT> implementations, the directory used
for the temporary file is not specified in a system include
file (<TT>&quot;P_tmpdir&quot;</TT>) but simply depends on the choice of <I>tmpdir()</I>
returned by File::Spec. On some implementations this
location can be set using the <TT>&quot;TMPDIR&quot;</TT> environment variable, which
may not be secure.
If this is a problem, simply use <I>mkstemp()</I> and specify a template.
<DL COMPACT>
<DT><B>tmpnam</B><DD>
<A NAME="ixAAU"></A>
When called in scalar context, returns the full name (including path)
of a temporary file (uses <I>mktemp()</I>). The only check is that the file does
not already exist, but there is no guarantee that that condition will
continue to apply.


<P>




<PRE>
  $file = tmpnam();

</PRE>




<P>


When called in list context, a filehandle to the open file and
a filename are returned. This is achieved by calling <I>mkstemp()</I>
after constructing a suitable template.


<P>




<PRE>
  ($fh, $file) = tmpnam();

</PRE>




<P>


If possible, this form should be used to prevent possible
race conditions.


<P>


See ``tmpdir'' in File::Spec for information on the choice of temporary
directory for a particular operating system.


<P>


Will <I>croak()</I> if there is an error.
<DT><B>tmpfile</B><DD>
<A NAME="ixAAV"></A>
Returns the filehandle of a temporary file.


<P>




<PRE>
  $fh = tmpfile();

</PRE>




<P>


The file is removed when the filehandle is closed or when the program
exits. No access to the filename is provided.


<P>


If the temporary file can not be created undef is returned.
Currently this command will probably not work when the temporary
directory is on an <FONT SIZE="-1">NFS</FONT> file system.


<P>


Will <I>croak()</I> if there is an error.
</DL>
<A NAME="lbAI">&nbsp;</A>
<H2>ADDITIONAL FUNCTIONS</H2>

<A NAME="ixAAW"></A>
These functions are provided for backwards compatibility
with common tempfile generation C library functions.
<P>

They are not exported and must be addressed using the full package
name.
<DL COMPACT>
<DT><B>tempnam</B><DD>
<A NAME="ixAAX"></A>
Return the name of a temporary file in the specified directory
using a prefix. The file is guaranteed not to exist at the time
the function was called, but such guarantees are good for one
clock tick only.  Always use the proper form of <TT>&quot;sysopen&quot;</TT>
with <TT>&quot;O_CREAT | O_EXCL&quot;</TT> if you must open such a filename.


<P>




<PRE>
  $filename = File::Temp::tempnam( $dir, $prefix );

</PRE>




<P>


Equivalent to running <I>mktemp()</I> with <TT>$dir</TT>/$prefixXXXXXXXX
(using unix file convention as an example)


<P>


Because this function uses <I>mktemp()</I>, it can suffer from race conditions.


<P>


Will <I>croak()</I> if there is an error.
</DL>
<A NAME="lbAJ">&nbsp;</A>
<H2>UTILITY FUNCTIONS</H2>

<A NAME="ixAAY"></A>
Useful functions for dealing with the filehandle and filename.
<DL COMPACT>
<DT><B>unlink0</B><DD>
<A NAME="ixAAZ"></A>
Given an open filehandle and the associated filename, make a safe
unlink. This is achieved by first checking that the filename and
filehandle initially point to the same file and that the number of
links to the file is 1 (all fields returned by <I>stat()</I> are compared).
Then the filename is unlinked and the filehandle checked once again to
verify that the number of links on that file is now 0.  This is the
closest you can come to making sure that the filename unlinked was the
same as the file whose descriptor you hold.


<P>




<PRE>
  unlink0($fh, $path)
     or die &quot;Error unlinking file $path safely&quot;;

</PRE>




<P>


Returns false on error but <I>croaks()</I> if there is a security
anomaly. The filehandle is not closed since on some occasions this is
not required.


<P>


On some platforms, for example Windows <FONT SIZE="-1">NT</FONT>, it is not possible to
unlink an open file (the file must be closed first). On those
platforms, the actual unlinking is deferred until the program ends and
good status is returned. A check is still performed to make sure that
the filehandle and filename are pointing to the same thing (but not at
the time the end block is executed since the deferred removal may not
have access to the filehandle).


<P>


Additionally, on Windows <FONT SIZE="-1">NT</FONT> not all the fields returned by <I>stat()</I> can
be compared. For example, the <TT>&quot;dev&quot;</TT> and <TT>&quot;rdev&quot;</TT> fields seem to be
different.  Also, it seems that the size of the file returned by <I>stat()</I>
does not always agree, with <TT>&quot;stat(FH)&quot;</TT> being more accurate than
<TT>&quot;stat(filename)&quot;</TT>, presumably because of caching issues even when
using autoflush (this is usually overcome by waiting a while after
writing to the tempfile before attempting to <TT>&quot;unlink0&quot;</TT> it).


<P>


Finally, on <FONT SIZE="-1">NFS</FONT> file systems the link count of the file handle does
not always go to zero immediately after unlinking. Currently, this
command is expected to fail on <FONT SIZE="-1">NFS</FONT> disks.


<P>


This function is disabled if the global variable <TT>$KEEP_ALL</TT> is true
and an unlink on open file is supported. If the unlink is to be deferred
to the <FONT SIZE="-1">END</FONT> block, the file is still registered for removal.


<P>


This function should not be called if you are using the object oriented
interface since the it will interfere with the object destructor deleting
the file.
<DT><B>cmpstat</B><DD>
<A NAME="ixABA"></A>
Compare <TT>&quot;stat&quot;</TT> of filehandle with <TT>&quot;stat&quot;</TT> of provided filename.  This
can be used to check that the filename and filehandle initially point
to the same file and that the number of links to the file is 1 (all
fields returned by <I>stat()</I> are compared).


<P>




<PRE>
  cmpstat($fh, $path)
     or die &quot;Error comparing handle with file&quot;;

</PRE>




<P>


Returns false if the stat information differs or if the link count is
greater than 1. Calls croak if there is a security anomaly.


<P>


On certain platforms, for example Windows, not all the fields returned by <I>stat()</I>
can be compared. For example, the <TT>&quot;dev&quot;</TT> and <TT>&quot;rdev&quot;</TT> fields seem to be
different in Windows.  Also, it seems that the size of the file
returned by <I>stat()</I> does not always agree, with <TT>&quot;stat(FH)&quot;</TT> being more
accurate than <TT>&quot;stat(filename)&quot;</TT>, presumably because of caching issues
even when using autoflush (this is usually overcome by waiting a while
after writing to the tempfile before attempting to <TT>&quot;unlink0&quot;</TT> it).


<P>


Not exported by default.
<DT><B>unlink1</B><DD>
<A NAME="ixABB"></A>
Similar to <TT>&quot;unlink0&quot;</TT> except after file comparison using cmpstat, the
filehandle is closed prior to attempting to unlink the file. This
allows the file to be removed without using an <FONT SIZE="-1">END</FONT> block, but does
mean that the post-unlink comparison of the filehandle state provided
by <TT>&quot;unlink0&quot;</TT> is not available.


<P>




<PRE>
  unlink1($fh, $path)
     or die &quot;Error closing and unlinking file&quot;;

</PRE>




<P>


Usually called from the object destructor when using the <FONT SIZE="-1">OO</FONT> interface.


<P>


Not exported by default.


<P>


This function is disabled if the global variable <TT>$KEEP_ALL</TT> is true.


<P>


Can call <I>croak()</I> if there is a security anomaly during the <I>stat()</I>
comparison.
<DT><B>cleanup</B><DD>
<A NAME="ixABC"></A>
Calling this function will cause any temp files or temp directories
that are registered for removal to be removed. This happens automatically
when the process exits but can be triggered manually if the caller is sure
that none of the temp files are required. This method can be registered as
an Apache callback.


<P>


On OSes where temp files are automatically removed when the temp file
is closed, calling this function will have no effect other than to remove
temporary directories (which may include temporary files).


<P>




<PRE>
  File::Temp::cleanup();

</PRE>




<P>


Not exported by default.
</DL>
<A NAME="lbAK">&nbsp;</A>
<H2>PACKAGE VARIABLES</H2>

<A NAME="ixABD"></A>
These functions control the global state of the package.
<DL COMPACT>
<DT><B>safe_level</B><DD>
<A NAME="ixABE"></A>
Controls the lengths to which the module will go to check the safety of the
temporary file or directory before proceeding.
Options are:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><FONT SIZE="-1">STANDARD</FONT><DD>
<A NAME="ixABF"></A>
Do the basic security measures to ensure the directory exists and is
writable, that temporary files are opened only if they do not already
exist, and that possible race conditions are avoided.  Finally the
unlink0 function is used to remove files safely.
<DT><FONT SIZE="-1">MEDIUM</FONT><DD>
<A NAME="ixABG"></A>
In addition to the <FONT SIZE="-1">STANDARD</FONT> security, the output directory is checked
to make sure that it is owned either by root or the user running the
program. If the directory is writable by group or by other, it is then
checked to make sure that the sticky bit is set.


<P>


Will not work on platforms that do not support the <TT>&quot;-k&quot;</TT> test
for sticky bit.
<DT><FONT SIZE="-1">HIGH</FONT><DD>
<A NAME="ixABH"></A>
In addition to the <FONT SIZE="-1">MEDIUM</FONT> security checks, also check for the
possibility of ``<I>chown()</I> giveaway'' using the <FONT SIZE="-1">POSIX</FONT>
<I>sysconf()</I> function. If this is a possibility, each directory in the
path is checked in turn for safeness, recursively walking back to the
root directory.


<P>


For platforms that do not support the <FONT SIZE="-1">POSIX</FONT>
<TT>&quot;_PC_CHOWN_RESTRICTED&quot;</TT> symbol (for example, Windows <FONT SIZE="-1">NT</FONT>) it is
assumed that ``<I>chown()</I> giveaway'' is possible and the recursive test
is performed.
</DL>
</DL>

<DL COMPACT><DT><DD>


<P>


The level can be changed as follows:


<P>




<PRE>
  File::Temp-&gt;safe_level( File::Temp::HIGH );

</PRE>




<P>


The level constants are not exported by the module.


<P>


Currently, you must be running at least perl v5.6.0 in order to
run with <FONT SIZE="-1">MEDIUM</FONT> or <FONT SIZE="-1">HIGH</FONT> security. This is simply because the
safety tests use functions from Fcntl that are not
available in older versions of perl. The problem is that the version
number for Fcntl is the same in perl 5.6.0 and in 5.005_03 even though
they are different versions.


<P>


On systems that do not support the <FONT SIZE="-1">HIGH</FONT> or <FONT SIZE="-1">MEDIUM</FONT> safety levels
(for example Win <FONT SIZE="-1">NT</FONT> or <FONT SIZE="-1">OS/2</FONT>) any attempt to change the level will
be ignored. The decision to ignore rather than raise an exception
allows portable programs to be written with high security in mind
for the systems that can support this without those programs failing
on systems where the extra tests are irrelevant.


<P>


If you really need to see whether the change has been accepted
simply examine the return value of <TT>&quot;safe_level&quot;</TT>.


<P>




<PRE>
  $newlevel = File::Temp-&gt;safe_level( File::Temp::HIGH );
  die &quot;Could not change to high security&quot;
      if $newlevel != File::Temp::HIGH;

</PRE>


</DL>

<DT>TopSystemUID<DD>
<A NAME="ixABI"></A>
This is the highest <FONT SIZE="-1">UID</FONT> on the current system that refers to a root
<FONT SIZE="-1">UID</FONT>. This is used to make sure that the temporary directory is
owned by a system <FONT SIZE="-1">UID</FONT> (<TT>&quot;root&quot;</TT>, <TT>&quot;bin&quot;</TT>, <TT>&quot;sys&quot;</TT> etc) rather than
simply by root.


<P>


This is required since on many unix systems <TT>&quot;/tmp&quot;</TT> is not owned
by root.


<P>


Default is to assume that any <FONT SIZE="-1">UID</FONT> less than or equal to 10 is a root
<FONT SIZE="-1">UID</FONT>.


<P>




<PRE>
  File::Temp-&gt;top_system_uid(10);
  my $topid = File::Temp-&gt;top_system_uid;

</PRE>




<P>


This value can be adjusted to reduce security checking if required.
The value is only relevant when <TT>&quot;safe_level&quot;</TT> is set to <FONT SIZE="-1">MEDIUM</FONT> or higher.
<DT><B>$KEEP_ALL</B><DD>


<A NAME="ixABJ"></A>
Controls whether temporary files and directories should be retained
regardless of any instructions in the program to remove them
automatically.  This is useful for debugging but should not be used in
production code.


<P>




<PRE>
  $File::Temp::KEEP_ALL = 1;

</PRE>




<P>


Default is for files to be removed as requested by the caller.


<P>


In some cases, files will only be retained if this variable is true
when the file is created. This means that you can not create a temporary
file, set this variable and expect the temp file to still be around
when the program exits.
<DT><B>$DEBUG</B><DD>


<A NAME="ixABK"></A>
Controls whether debugging messages should be enabled.


<P>




<PRE>
  $File::Temp::DEBUG = 1;

</PRE>




<P>


Default is for debugging mode to be disabled.
</DL>
<A NAME="lbAL">&nbsp;</A>
<H2>WARNING</H2>

<A NAME="ixABL"></A>
For maximum security, endeavour always to avoid ever looking at,
touching, or even imputing the existence of the filename.  You do not
know that that filename is connected to the same file as the handle
you have, and attempts to check this can only trigger more race
conditions.  It's far more secure to use the filehandle alone and
dispense with the filename altogether.
<P>

If you need to pass the handle to something that expects a filename
then, on a unix system, use <TT>&quot;&quot;/dev/fd/&quot; . fileno($fh)&quot;</TT> for arbitrary
programs, or more generally <TT>&quot;&quot;+&lt;=&amp;&quot; . fileno($fh)&quot;</TT> for Perl
programs.  You will have to clear the close-on-exec bit on that file
descriptor before passing it to another process.
<P>



<PRE>
    use Fcntl qw/F_SETFD F_GETFD/;
    fcntl($tmpfh, F_SETFD, 0)
        or die &quot;Can't clear close-on-exec flag on temp fh: $!\n&quot;;

</PRE>


<A NAME="lbAM">&nbsp;</A>
<H3>Temporary files and <FONT SIZE="-1">NFS</FONT></H3>

<A NAME="ixABM"></A>
Some problems are associated with using temporary files that reside
on <FONT SIZE="-1">NFS</FONT> file systems and it is recommended that a local filesystem
is used whenever possible. Some of the security tests will most probably
fail when the temp file is not local. Additionally, be aware that
the performance of I/O operations over <FONT SIZE="-1">NFS</FONT> will not be as good as for
a local disk.
<A NAME="lbAN">&nbsp;</A>
<H3>Forking</H3>

<A NAME="ixABN"></A>
In some cases files created by File::Temp are removed from within an
<FONT SIZE="-1">END</FONT> block. Since <FONT SIZE="-1">END</FONT> blocks are triggered when a child process exits
(unless <TT>&quot;POSIX::_exit()&quot;</TT> is used by the child) File::Temp takes care
to only remove those temp files created by a particular process <FONT SIZE="-1">ID</FONT>. This
means that a child will not attempt to remove temp files created by the
parent process.
<P>

If you are forking many processes in parallel that are all creating
temporary files, you may need to reset the random number seed using
srand(<FONT SIZE="-1">EXPR</FONT>) in each child else all the children will attempt to walk
through the same set of random file names and may well cause
themselves to give up if they exceed the number of retry attempts.
<A NAME="lbAO">&nbsp;</A>
<H3>Directory removal</H3>

<A NAME="ixABO"></A>
Note that if you have chdir'ed into the temporary directory and it is
subsequently cleaned up (either in the <FONT SIZE="-1">END</FONT> block or as part of object
destruction), then you will get a warning from <I>File::Path::rmtree()</I>.
<A NAME="lbAP">&nbsp;</A>
<H3><FONT SIZE="-1">BINMODE</FONT></H3>

<A NAME="ixABP"></A>
The file returned by File::Temp will have been opened in binary mode
if such a mode is available. If that is not correct, use the <TT>&quot;binmode()&quot;</TT>
function to change the mode of the filehandle.
<P>

Note that you can modify the encoding of a file opened by File::Temp
also by using <TT>&quot;binmode()&quot;</TT>.
<A NAME="lbAQ">&nbsp;</A>
<H2>HISTORY</H2>

<A NAME="ixABQ"></A>
Originally began life in May 1999 as an <FONT SIZE="-1">XS</FONT> interface to the system
<I>mkstemp()</I> function. In March 2000, the OpenBSD <I>mkstemp()</I> code was
translated to Perl for total control of the code's
security checking, to ensure the presence of the function regardless of
operating system and to help with portability. The module was shipped
as a standard part of perl from v5.6.1.
<A NAME="lbAR">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixABR"></A>
``tmpnam'' in <FONT SIZE="-1">POSIX</FONT>, ``tmpfile'' in <FONT SIZE="-1">POSIX</FONT>, File::Spec, File::Path
<P>

See IO::File and File::MkTemp, Apache::TempFile for
different implementations of temporary file handling.
<P>

See File::Tempdir for an alternative object-oriented wrapper for
the <TT>&quot;tempdir&quot;</TT> function.
<A NAME="lbAS">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixABS"></A>
Tim Jenness &lt;<A HREF="mailto:tjenness@cpan.org">tjenness@cpan.org</A>&gt;
<P>

Copyright (C) 2007-2009 Tim Jenness.
Copyright (C) 1999-2007 Tim Jenness and the <FONT SIZE="-1">UK</FONT> Particle Physics and
Astronomy Research Council. All Rights Reserved.  This program is free
software; you can redistribute it and/or modify it under the same
terms as Perl itself.
<P>

Original Perl implementation loosely based on the OpenBSD C code for
<I>mkstemp()</I>. Thanks to Tom Christiansen for suggesting that this module
should be written and providing ideas for code improvements and
security enhancements.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">OBJECT-ORIENTED INTERFACE</A><DD>
<DT><A HREF="#lbAF">FUNCTIONS</A><DD>
<DT><A HREF="#lbAG">MKTEMP FUNCTIONS</A><DD>
<DT><A HREF="#lbAH">POSIX FUNCTIONS</A><DD>
<DT><A HREF="#lbAI">ADDITIONAL FUNCTIONS</A><DD>
<DT><A HREF="#lbAJ">UTILITY FUNCTIONS</A><DD>
<DT><A HREF="#lbAK">PACKAGE VARIABLES</A><DD>
<DT><A HREF="#lbAL">WARNING</A><DD>
<DL>
<DT><A HREF="#lbAM">Temporary files and <FONT SIZE="-1">NFS</FONT></A><DD>
<DT><A HREF="#lbAN">Forking</A><DD>
<DT><A HREF="#lbAO">Directory removal</A><DD>
<DT><A HREF="#lbAP"><FONT SIZE="-1">BINMODE</FONT></A><DD>
</DL>
<DT><A HREF="#lbAQ">HISTORY</A><DD>
<DT><A HREF="#lbAR">SEE ALSO</A><DD>
<DT><A HREF="#lbAS">AUTHOR</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:27 GMT, December 24, 2015
</div></body>
</HTML>
