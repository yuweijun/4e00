<!DOCTYPE html>

<HTML><head><TITLE>Manpage of OBJ_nid2obj</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"documentation"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>OBJ_nid2obj</H1>
Section: OpenSSL (3)<BR>Updated: 2006-05-14<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

OBJ_nid2obj, OBJ_nid2ln, OBJ_nid2sn, OBJ_obj2nid, OBJ_txt2nid, OBJ_ln2nid, OBJ_sn2nid,
OBJ_cmp, OBJ_dup, OBJ_txt2obj, OBJ_obj2txt, OBJ_create, OBJ_cleanup - ASN1 object utility
functions
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
 #include &lt;<A HREF="file:/usr/include/openssl/objects.h">openssl/objects.h</A>&gt;

 ASN1_OBJECT * OBJ_nid2obj(int n);
 const char *  OBJ_nid2ln(int n);
 const char *  OBJ_nid2sn(int n);

 int OBJ_obj2nid(const ASN1_OBJECT *o);
 int OBJ_ln2nid(const char *ln);
 int OBJ_sn2nid(const char *sn);

 int OBJ_txt2nid(const char *s);

 ASN1_OBJECT * OBJ_txt2obj(const char *s, int no_name);
 int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name);

 int OBJ_cmp(const ASN1_OBJECT *a,const ASN1_OBJECT *b);
 ASN1_OBJECT * OBJ_dup(const ASN1_OBJECT *o);

 int OBJ_create(const char *oid,const char *sn,const char *ln);
 void OBJ_cleanup(void);

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
The <FONT SIZE="-1">ASN1</FONT> object utility functions process <FONT SIZE="-1">ASN1_OBJECT</FONT> structures which are
a representation of the <FONT SIZE="-1">ASN1</FONT> <FONT SIZE="-1">OBJECT</FONT> <FONT SIZE="-1">IDENTIFIER</FONT> (<FONT SIZE="-1">OID</FONT>) type.
<P>

<I>OBJ_nid2obj()</I>, <I>OBJ_nid2ln()</I> and <I>OBJ_nid2sn()</I> convert the <FONT SIZE="-1">NID</FONT> <B>n</B> to 
an <FONT SIZE="-1">ASN1_OBJECT</FONT> structure, its long name and its short name respectively,
or <B></B><FONT SIZE="-1"><B>NULL</B></FONT><B></B> is an error occurred.
<P>

<I>OBJ_obj2nid()</I>, <I>OBJ_ln2nid()</I>, <I>OBJ_sn2nid()</I> return the corresponding <FONT SIZE="-1">NID</FONT>
for the object <B>o</B>, the long name &lt;ln&gt; or the short name &lt;sn&gt; respectively
or NID_undef if an error occurred.
<P>

<I>OBJ_txt2nid()</I> returns <FONT SIZE="-1">NID</FONT> corresponding to text string &lt;s&gt;. <B>s</B> can be
a long name, a short name or the numerical respresentation of an object.
<P>

<I>OBJ_txt2obj()</I> converts the text string <B>s</B> into an <FONT SIZE="-1">ASN1_OBJECT</FONT> structure.
If <B>no_name</B> is 0 then long names and short names will be interpreted
as well as numerical forms. If <B>no_name</B> is 1 only the numerical form
is acceptable.
<P>

<I>OBJ_obj2txt()</I> converts the <B></B><FONT SIZE="-1"><B>ASN1_OBJECT</B></FONT><B></B> <B>a</B> into a textual representation.
The representation is written as a null terminated string to <B>buf</B>
at most <B>buf_len</B> bytes are written, truncating the result if necessary.
The total amount of space required is returned. If <B>no_name</B> is 0 then
if the object has a long or short name then that will be used, otherwise
the numerical form will be used. If <B>no_name</B> is 1 then the numerical
form will always be used.
<P>

<I>OBJ_cmp()</I> compares <B>a</B> to <B>b</B>. If the two are identical 0 is returned.
<P>

<I>OBJ_dup()</I> returns a copy of <B>o</B>.
<P>

<I>OBJ_create()</I> adds a new object to the internal table. <B>oid</B> is the 
numerical form of the object, <B>sn</B> the short name and <B>ln</B> the
long name. A new <FONT SIZE="-1">NID</FONT> is returned for the created object.
<P>

<I>OBJ_cleanup()</I> cleans up OpenSSLs internal object table: this should
be called before an application exits if any new objects were added
using <I>OBJ_create()</I>.
<A NAME="lbAE">&nbsp;</A>
<H2>NOTES</H2>

<A NAME="ixAAE"></A>
Objects in OpenSSL can have a short name, a long name and a numerical
identifier (<FONT SIZE="-1">NID</FONT>) associated with them. A standard set of objects is
represented in an internal table. The appropriate values are defined
in the header file <B>objects.h</B>.
<P>

For example the <FONT SIZE="-1">OID</FONT> for commonName has the following definitions:
<P>



<PRE>
 #define SN_commonName                   &quot;CN&quot;
 #define LN_commonName                   &quot;commonName&quot;
 #define NID_commonName                  13

</PRE>


<P>

New objects can be added by calling <I>OBJ_create()</I>.
<P>

Table objects have certain advantages over other objects: for example
their NIDs can be used in a C language switch statement. They are
also static constant structures which are shared: that is there
is only a single constant structure for each table object.
<P>

Objects which are not in the table have the <FONT SIZE="-1">NID</FONT> value NID_undef.
<P>

Objects do not need to be in the internal tables to be processed,
the functions <I>OBJ_txt2obj()</I> and <I>OBJ_obj2txt()</I> can process the numerical
form of an <FONT SIZE="-1">OID</FONT>.
<A NAME="lbAF">&nbsp;</A>
<H2>EXAMPLES</H2>

<A NAME="ixAAF"></A>
Create an object for <B>commonName</B>:
<P>



<PRE>
 ASN1_OBJECT *o;
 o = OBJ_nid2obj(NID_commonName);

</PRE>


<P>

Check if an object is <B>commonName</B>
<P>



<PRE>
 if (OBJ_obj2nid(obj) == NID_commonName)
        /* Do something */

</PRE>


<P>

Create a new <FONT SIZE="-1">NID</FONT> and initialize an object from it:
<P>



<PRE>
 int new_nid;
 ASN1_OBJECT *obj;
 new_nid = OBJ_create(&quot;1.2.3.4&quot;, &quot;NewOID&quot;, &quot;New Object Identifier&quot;);

 obj = OBJ_nid2obj(new_nid);

</PRE>


<P>

Create a new object directly:
<P>



<PRE>
 obj = OBJ_txt2obj(&quot;1.2.3.4&quot;, 1);

</PRE>


<A NAME="lbAG">&nbsp;</A>
<H2>BUGS</H2>

<A NAME="ixAAG"></A>
<I>OBJ_obj2txt()</I> is awkward and messy to use: it doesn't follow the 
convention of other OpenSSL functions where the buffer can be set
to <B></B><FONT SIZE="-1"><B>NULL</B></FONT><B></B> to determine the amount of data that should be written.
Instead <B>buf</B> must point to a valid buffer and <B>buf_len</B> should
be set to a positive value. A buffer length of 80 should be more
than enough to handle any <FONT SIZE="-1">OID</FONT> encountered in practice.
<A NAME="lbAH">&nbsp;</A>
<H2>RETURN VALUES</H2>

<A NAME="ixAAH"></A>
<I>OBJ_nid2obj()</I> returns an <B></B><FONT SIZE="-1"><B>ASN1_OBJECT</B></FONT><B></B> structure or <B></B><FONT SIZE="-1"><B>NULL</B></FONT><B></B> is an
error occurred.
<P>

<I>OBJ_nid2ln()</I> and <I>OBJ_nid2sn()</I> returns a valid string or <B></B><FONT SIZE="-1"><B>NULL</B></FONT><B></B>
on error.
<P>

<I>OBJ_obj2nid()</I>, <I>OBJ_ln2nid()</I>, <I>OBJ_sn2nid()</I> and <I>OBJ_txt2nid()</I> return
a <FONT SIZE="-1">NID</FONT> or <B>NID_undef</B> on error.
<A NAME="lbAI">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAI"></A>
<I><A HREF="/manpages/index.html?3+ERR_get_error">ERR_get_error</A></I>(3)
<A NAME="lbAJ">&nbsp;</A>
<H2>HISTORY</H2>

<A NAME="ixAAJ"></A>
<FONT SIZE="-1">TBA</FONT>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">NOTES</A><DD>
<DT><A HREF="#lbAF">EXAMPLES</A><DD>
<DT><A HREF="#lbAG">BUGS</A><DD>
<DT><A HREF="#lbAH">RETURN VALUES</A><DD>
<DT><A HREF="#lbAI">SEE ALSO</A><DD>
<DT><A HREF="#lbAJ">HISTORY</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:35 GMT, December 24, 2015
</div></div>
</body>
</HTML>
