<!DOCTYPE html>

<HTML><head><TITLE>Manpage of Filter::Simple</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"documentation"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>Filter::Simple</H1>
Section: Perl Programmers Reference Guide (3pm)<BR>Updated: 2009-04-11<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Filter::Simple - Simplified source filtering
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
 # in MyFilter.pm:

     package MyFilter;

     use Filter::Simple;
     
     FILTER { ... };

     # or just:
     #
     # use Filter::Simple sub { ... };

 # in user's code:

     use MyFilter;

     # this code is filtered

     no MyFilter;

     # this code is not

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
<A NAME="lbAE">&nbsp;</A>
<H3>The Problem</H3>

<A NAME="ixAAE"></A>
Source filtering is an immensely powerful feature of recent versions of Perl.
It allows one to extend the language itself (e.g. the Switch module), to 
simplify the language (e.g. Language::Pythonesque), or to completely recast the
language (e.g. Lingua::Romana::Perligata). Effectively, it allows one to use
the full power of Perl as its own, recursively applied, macro language.
<P>

The excellent Filter::Util::Call module (by Paul Marquess) provides a
usable Perl interface to source filtering, but it is often too powerful
and not nearly as simple as it could be.
<P>

To use the module it is necessary to do the following:
<DL COMPACT>
<DT>1.<DD>
Download, build, and install the Filter::Util::Call module.
(If you have Perl 5.7.1 or later, this is already done for you.)
<DT>2.<DD>
Set up a module that does a <TT>&quot;use Filter::Util::Call&quot;</TT>.
<DT>3.<DD>
Within that module, create an <TT>&quot;import&quot;</TT> subroutine.
<DT>4.<DD>
Within the <TT>&quot;import&quot;</TT> subroutine do a call to <TT>&quot;filter_add&quot;</TT>, passing
it either a subroutine reference.
<DT>5.<DD>
Within the subroutine reference, call <TT>&quot;filter_read&quot;</TT> or <TT>&quot;filter_read_exact&quot;</TT>
to ``prime'' <TT>$_</TT> with source code data from the source file that will
<TT>&quot;use&quot;</TT> your module. Check the status value returned to see if any
source code was actually read in.
<DT>6.<DD>
Process the contents of <TT>$_</TT> to change the source code in the desired manner.
<DT>7.<DD>
Return the status value.
<DT>8.<DD>
If the act of unimporting your module (via a <TT>&quot;no&quot;</TT>) should cause source
code filtering to cease, create an <TT>&quot;unimport&quot;</TT> subroutine, and have it call
<TT>&quot;filter_del&quot;</TT>. Make sure that the call to <TT>&quot;filter_read&quot;</TT> or
<TT>&quot;filter_read_exact&quot;</TT> in step 5 will not accidentally read past the
<TT>&quot;no&quot;</TT>. Effectively this limits source code filters to line-by-line
operation, unless the <TT>&quot;import&quot;</TT> subroutine does some fancy
pre-pre-parsing of the source code it's filtering.
</DL>
<P>

For example, here is a minimal source code filter in a module named
<FONT SIZE="-1">BANG</FONT>.pm. It simply converts every occurrence of the sequence <TT>&quot;BANG\s+BANG&quot;</TT>
to the sequence <TT>&quot;die 'BANG' if $BANG&quot;</TT> in any piece of code following a
<TT>&quot;use BANG;&quot;</TT> statement (until the next <TT>&quot;no BANG;&quot;</TT> statement, if any):
<P>



<PRE>
    package BANG;
 
    use Filter::Util::Call ;

    sub import {
        filter_add( sub {
        my $caller = caller;
        my ($status, $no_seen, $data);
        while ($status = filter_read()) {
            if (/^\s*no\s+$caller\s*;\s*?$/) {
                $no_seen=1;
                last;
            }
            $data .= $_;
            $_ = &quot;&quot;;
        }
        $_ = $data;
        s/BANG\s+BANG/die 'BANG' if \$BANG/g
            unless $status &lt; 0;
        $_ .= &quot;no $class;\n&quot; if $no_seen;
        return 1;
        })
    }

    sub unimport {
        filter_del();
    }

    1 ;

</PRE>


<P>

This level of sophistication puts filtering out of the reach of
many programmers.
<A NAME="lbAF">&nbsp;</A>
<H3>A Solution</H3>

<A NAME="ixAAF"></A>
The Filter::Simple module provides a simplified interface to
Filter::Util::Call; one that is sufficient for most common cases.
<P>

Instead of the above process, with Filter::Simple the task of setting up
a source code filter is reduced to:
<DL COMPACT>
<DT>1.<DD>
Download and install the Filter::Simple module.
(If you have Perl 5.7.1 or later, this is already done for you.)
<DT>2.<DD>
Set up a module that does a <TT>&quot;use Filter::Simple&quot;</TT> and then
calls <TT>&quot;FILTER { ... }&quot;</TT>.
<DT>3.<DD>
Within the anonymous subroutine or block that is passed to
<TT>&quot;FILTER&quot;</TT>, process the contents of <TT>$_</TT> to change the source code in
the desired manner.
</DL>
<P>

In other words, the previous example, would become:
<P>



<PRE>
    package BANG;
    use Filter::Simple;
    
    FILTER {
        s/BANG\s+BANG/die 'BANG' if \$BANG/g;
    };

    1 ;

</PRE>


<P>

Note that the source code is passed as a single string, so any regex that
uses <TT>&quot;^&quot;</TT> or <TT>&quot;$&quot;</TT> to detect line boundaries will need the <TT>&quot;/m&quot;</TT> flag.
<A NAME="lbAG">&nbsp;</A>
<H3>Disabling or changing &lt;no&gt; behaviour</H3>

<A NAME="ixAAG"></A>
By default, the installed filter only filters up to a line consisting of one of
the three standard source ``terminators'':
<P>



<PRE>
    no ModuleName;  # optional comment

</PRE>


<P>

or:
<P>



<PRE>
    __END__

</PRE>


<P>

or:
<P>



<PRE>
    __DATA__

</PRE>


<P>

but this can be altered by passing a second argument to <TT>&quot;use Filter::Simple&quot;</TT>
or <TT>&quot;FILTER&quot;</TT> (just remember: there's <I>no</I> comma after the initial block when
you use <TT>&quot;FILTER&quot;</TT>).
<P>

That second argument may be either a <TT>&quot;qr&quot;</TT>'d regular expression (which is then
used to match the terminator line), or a defined false value (which indicates
that no terminator line should be looked for), or a reference to a hash
(in which case the terminator is the value associated with the key
<TT>'terminator'</TT>.
<P>

For example, to cause the previous filter to filter only up to a line of the
form:
<P>



<PRE>
    GNAB esu;

</PRE>


<P>

you would write:
<P>



<PRE>
    package BANG;
    use Filter::Simple;
    
    FILTER {
        s/BANG\s+BANG/die 'BANG' if \$BANG/g;
    }
    qr/^\s*GNAB\s+esu\s*;\s*?$/;

</PRE>


<P>

or:
<P>



<PRE>
    FILTER {
        s/BANG\s+BANG/die 'BANG' if \$BANG/g;
    }
    { terminator =&gt; qr/^\s*GNAB\s+esu\s*;\s*?$/ };

</PRE>


<P>

and to prevent the filter's being turned off in any way:
<P>



<PRE>
    package BANG;
    use Filter::Simple;
    
    FILTER {
        s/BANG\s+BANG/die 'BANG' if \$BANG/g;
    }
    &quot;&quot;;    # or: 0

</PRE>


<P>

or:
<P>



<PRE>
    FILTER {
        s/BANG\s+BANG/die 'BANG' if \$BANG/g;
    }
    { terminator =&gt; &quot;&quot; };

</PRE>


<P>

<B>Note that, no matter what you set the terminator pattern to,
the actual terminator itself </B>must<B> be contained on a single source line.</B>
<A NAME="lbAH">&nbsp;</A>
<H3>All-in-one interface</H3>

<A NAME="ixAAH"></A>
Separating the loading of Filter::Simple:
<P>



<PRE>
    use Filter::Simple;

</PRE>


<P>

from the setting up of the filtering:
<P>



<PRE>
    FILTER { ... };

</PRE>


<P>

is useful because it allows other code (typically parser support code
or caching variables) to be defined before the filter is invoked.
However, there is often no need for such a separation.
<P>

In those cases, it is easier to just append the filtering subroutine and
any terminator specification directly to the <TT>&quot;use&quot;</TT> statement that loads
Filter::Simple, like so:
<P>



<PRE>
    use Filter::Simple sub {
        s/BANG\s+BANG/die 'BANG' if \$BANG/g;
    };

</PRE>


<P>

This is exactly the same as:
<P>



<PRE>
    use Filter::Simple;
    BEGIN {
        Filter::Simple::FILTER {
            s/BANG\s+BANG/die 'BANG' if \$BANG/g;
        };
    }

</PRE>


<P>

except that the <TT>&quot;FILTER&quot;</TT> subroutine is not exported by Filter::Simple.
<A NAME="lbAI">&nbsp;</A>
<H3>Filtering only specific components of source code</H3>

<A NAME="ixAAI"></A>
One of the problems with a filter like:
<P>



<PRE>
    use Filter::Simple;

    FILTER { s/BANG\s+BANG/die 'BANG' if \$BANG/g };

</PRE>


<P>

is that it indiscriminately applies the specified transformation to
the entire text of your source program. So something like:
<P>



<PRE>
    warn 'BANG BANG, YOU'RE DEAD';
    BANG BANG;

</PRE>


<P>

will become:
<P>



<PRE>
    warn 'die 'BANG' if $BANG, YOU'RE DEAD';
    die 'BANG' if $BANG;

</PRE>


<P>

It is very common when filtering source to only want to apply the filter
to the non-character-string parts of the code, or alternatively to <I>only</I>
the character strings.
<P>

Filter::Simple supports this type of filtering by automatically
exporting the <TT>&quot;FILTER_ONLY&quot;</TT> subroutine.
<P>

<TT>&quot;FILTER_ONLY&quot;</TT> takes a sequence of specifiers that install separate
(and possibly multiple) filters that act on only parts of the source code.
For example:
<P>



<PRE>
    use Filter::Simple;

    FILTER_ONLY
        code      =&gt; sub { s/BANG\s+BANG/die 'BANG' if \$BANG/g },
        quotelike =&gt; sub { s/BANG\s+BANG/CHITTY CHITTY/g };

</PRE>


<P>

The <TT>&quot;code&quot;</TT> subroutine will only be used to filter parts of the source
code that are not quotelikes, <FONT SIZE="-1">POD</FONT>, or <TT>&quot;__DATA__&quot;</TT>. The <TT>&quot;quotelike&quot;</TT>
subroutine only filters Perl quotelikes (including here documents).
<P>

The full list of alternatives is:
<DL COMPACT>
<DT>code<DD>


<A NAME="ixAAJ"></A>
Filters only those sections of the source code that are not quotelikes, <FONT SIZE="-1">POD</FONT>, or
<TT>&quot;__DATA__&quot;</TT>.
<DT>code_no_comments<DD>


<A NAME="ixAAK"></A>
Filters only those sections of the source code that are not quotelikes, <FONT SIZE="-1">POD</FONT>,
comments, or <TT>&quot;__DATA__&quot;</TT>.
<DT>executable<DD>


<A NAME="ixAAL"></A>
Filters only those sections of the source code that are not <FONT SIZE="-1">POD</FONT> or <TT>&quot;__DATA__&quot;</TT>.
<DT>executable_no_comments<DD>


<A NAME="ixAAM"></A>
Filters only those sections of the source code that are not <FONT SIZE="-1">POD</FONT>, comments, or <TT>&quot;__DATA__&quot;</TT>.
<DT>quotelike<DD>


<A NAME="ixAAN"></A>
Filters only Perl quotelikes (as interpreted by
<TT>&amp;Text::Balanced::extract_quotelike</TT>).
<DT>string<DD>


<A NAME="ixAAO"></A>
Filters only the string literal parts of a Perl quotelike (i.e. the 
contents of a string literal, either half of a <TT>&quot;tr///&quot;</TT>, the second
half of an <TT>&quot;s///&quot;</TT>).
<DT>regex<DD>


<A NAME="ixAAP"></A>
Filters only the pattern literal parts of a Perl quotelike (i.e. the 
contents of a <TT>&quot;qr//&quot;</TT> or an <TT>&quot;m//&quot;</TT>, the first half of an <TT>&quot;s///&quot;</TT>).
<DT>all<DD>


<A NAME="ixAAQ"></A>
Filters everything. Identical in effect to <TT>&quot;FILTER&quot;</TT>.
</DL>
<P>

Except for <TT>&quot;FILTER_ONLY code =&gt; sub {...}&quot;</TT>, each of
the component filters is called repeatedly, once for each component
found in the source code.
<P>

Note that you can also apply two or more of the same type of filter in
a single <TT>&quot;FILTER_ONLY&quot;</TT>. For example, here's a simple 
macro-preprocessor that is only applied within regexes,
with a final debugging pass that prints the resulting source code:
<P>



<PRE>
    use Regexp::Common;
    FILTER_ONLY
        regex =&gt; sub { s/!\[/[^/g },
        regex =&gt; sub { s/%d/$RE{num}{int}/g },
        regex =&gt; sub { s/%f/$RE{num}{real}/g },
        all   =&gt; sub { print if $::DEBUG };

</PRE>


<A NAME="lbAJ">&nbsp;</A>
<H3>Filtering only the code parts of source code</H3>

<A NAME="ixAAR"></A>
Most source code ceases to be grammatically correct when it is broken up
into the pieces between string literals and regexes. So the <TT>'code'</TT>
and <TT>'code_no_comments'</TT> component filter behave slightly differently
from the other partial filters described in the previous section.
<P>

Rather than calling the specified processor on each individual piece of
code (i.e. on the bits between quotelikes), the <TT>'code...'</TT> partial
filters operate on the entire source code, but with the quotelike bits
(and, in the case of <TT>'code_no_comments'</TT>, the comments) ``blanked out''.
<P>

That is, a <TT>'code...'</TT> filter <I>replaces</I> each quoted string, quotelike,
regex, <FONT SIZE="-1">POD</FONT>, and __DATA__ section with a placeholder. The
delimiters of this placeholder are the contents of the <TT>$;</TT> variable
at the time the filter is applied (normally <TT>&quot;\034&quot;</TT>). The remaining
four bytes are a unique identifier for the component being replaced.
<P>

This approach makes it comparatively easy to write code preprocessors
without worrying about the form or contents of strings, regexes, etc.
<P>

For convenience, during a <TT>'code...'</TT> filtering operation, Filter::Simple
provides a package variable (<TT>$Filter::Simple::placeholder</TT>) that
contains a pre-compiled regex that matches any placeholder...and
captures the identifier within the placeholder. Placeholders can be
moved and re-ordered within the source code as needed.
<P>

In addition, a second package variable (<TT>@Filter::Simple::components</TT>)
contains a list of the various pieces of <TT>$_</TT>, as they were originally split
up to allow placeholders to be inserted.
<P>

Once the filtering has been applied, the original strings, regexes, <FONT SIZE="-1">POD</FONT>,
etc. are re-inserted into the code, by replacing each placeholder with
the corresponding original component (from <TT>@components</TT>). Note that
this means that the <TT>@components</TT> variable must be treated with extreme
care within the filter. The <TT>@components</TT> array stores the ``back-
translations'' of each placeholder inserted into <TT>$_</TT>, as well as the
interstitial source code between placeholders. If the placeholder
backtranslations are altered in <TT>@components</TT>, they will be similarly
changed when the placeholders are removed from <TT>$_</TT> after the filter
is complete.
<P>

For example, the following filter detects concatenated pairs of
strings/quotelikes and reverses the order in which they are
concatenated:
<P>



<PRE>
    package DemoRevCat;
    use Filter::Simple;

    FILTER_ONLY code =&gt; sub {
        my $ph = $Filter::Simple::placeholder;
        s{ ($ph) \s* [.] \s* ($ph) }{ $2.$1 }gx
    };

</PRE>


<P>

Thus, the following code:
<P>



<PRE>
    use DemoRevCat;

    my $str = &quot;abc&quot; . q(def);

    print &quot;$str\n&quot;;

</PRE>


<P>

would become:
<P>



<PRE>
    my $str = q(def).&quot;abc&quot;;

    print &quot;$str\n&quot;;

</PRE>


<P>

and hence print:
<P>



<PRE>
    defabc

</PRE>


<A NAME="lbAK">&nbsp;</A>
<H3>Using Filter::Simple with an explicit import subroutine</H3>



<A NAME="ixAAS"></A>
Filter::Simple generates a special <TT>&quot;import&quot;</TT> subroutine for
your module (see ``How it works'') which would normally replace any
<TT>&quot;import&quot;</TT> subroutine you might have explicitly declared.
<P>

However, Filter::Simple is smart enough to notice your existing
<TT>&quot;import&quot;</TT> and Do The Right Thing with it.
That is, if you explicitly define an <TT>&quot;import&quot;</TT> subroutine in a package
that's using Filter::Simple, that <TT>&quot;import&quot;</TT> subroutine will still
be invoked immediately after any filter you install.
<P>

The only thing you have to remember is that the <TT>&quot;import&quot;</TT> subroutine
<I>must</I> be declared <I>before</I> the filter is installed. If you use <TT>&quot;FILTER&quot;</TT>
to install the filter:
<P>



<PRE>
    package Filter::TurnItUpTo11;

    use Filter::Simple;

    FILTER { s/(\w+)/\U$1/ };

</PRE>


<P>

that will almost never be a problem, but if you install a filtering
subroutine by passing it directly to the <TT>&quot;use Filter::Simple&quot;</TT>
statement:
<P>



<PRE>
    package Filter::TurnItUpTo11;

    use Filter::Simple sub{ s/(\w+)/\U$1/ };

</PRE>


<P>

then you must make sure that your <TT>&quot;import&quot;</TT> subroutine appears before
that <TT>&quot;use&quot;</TT> statement.
<A NAME="lbAL">&nbsp;</A>
<H3>Using Filter::Simple and Exporter together</H3>

<A NAME="ixAAT"></A>
Likewise, Filter::Simple is also smart enough
to Do The Right Thing if you use Exporter:
<P>



<PRE>
    package Switch;
    use base Exporter;
    use Filter::Simple;

    @EXPORT    = qw(switch case);
    @EXPORT_OK = qw(given  when);

    FILTER { $_ = magic_Perl_filter($_) }

</PRE>


<P>

Immediately after the filter has been applied to the source,
Filter::Simple will pass control to Exporter, so it can do its magic too.
<P>

Of course, here too, Filter::Simple has to know you're using Exporter
before it applies the filter. That's almost never a problem, but if you're
nervous about it, you can guarantee that things will work correctly by
ensuring that your <TT>&quot;use base Exporter&quot;</TT> always precedes your
<TT>&quot;use Filter::Simple&quot;</TT>.
<A NAME="lbAM">&nbsp;</A>
<H3>How it works</H3>

<A NAME="ixAAU"></A>
The Filter::Simple module exports into the package that calls <TT>&quot;FILTER&quot;</TT>
(or <TT>&quot;use&quot;</TT>s it directly) --- such as package ``<FONT SIZE="-1">BANG</FONT>'' in the above example ---
two automagically constructed
subroutines --- <TT>&quot;import&quot;</TT> and <TT>&quot;unimport&quot;</TT> --- which take care of all the
nasty details.
<P>

In addition, the generated <TT>&quot;import&quot;</TT> subroutine passes its own argument
list to the filtering subroutine, so the <FONT SIZE="-1">BANG</FONT>.pm filter could easily 
be made parametric:
<P>



<PRE>
    package BANG;
 
    use Filter::Simple;
    
    FILTER {
        my ($die_msg, $var_name) = @_;
        s/BANG\s+BANG/die '$die_msg' if \${$var_name}/g;
    };

    # and in some user code:

    use BANG &quot;BOOM&quot;, &quot;BAM&quot;;  # &quot;BANG BANG&quot; becomes: die 'BOOM' if $BAM

</PRE>


<P>

The specified filtering subroutine is called every time a <TT>&quot;use BANG&quot;</TT> is
encountered, and passed all the source code following that call, up to
either the next <TT>&quot;no BANG;&quot;</TT> (or whatever terminator you've set) or the
end of the source file, whichever occurs first. By default, any <TT>&quot;no
BANG;&quot;</TT> call must appear by itself on a separate line, or it is ignored.
<A NAME="lbAN">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixAAV"></A>
Damian Conway
<A NAME="lbAO">&nbsp;</A>
<H2>CONTACT</H2>

<A NAME="ixAAW"></A>
Filter::Simple is now maintained by the Perl5-Porters.
Please submit bug via the <TT>&quot;perlbug&quot;</TT> tool that comes with your perl.
For usage instructions, read <TT>&quot;perldoc perlbug&quot;</TT> or possibly <TT>&quot;man perlbug&quot;</TT>.
For mostly anything else, please contact &lt;<A HREF="mailto:perl5-porters@perl.org">perl5-porters@perl.org</A>&gt;.
<P>

Maintainer of the <FONT SIZE="-1">CPAN</FONT> release is Steffen Mueller &lt;<A HREF="mailto:smueller@cpan.org">smueller@cpan.org</A>&gt;.
Contact him with technical difficulties with respect to the packaging of the
<FONT SIZE="-1">CPAN</FONT> module.
<P>

Praise of the module, flowers, and presents still go to the author,
Damian Conway &lt;<A HREF="mailto:damian@conway.org">damian@conway.org</A>&gt;.
<A NAME="lbAP">&nbsp;</A>
<H2>COPYRIGHT AND LICENSE</H2>

<A NAME="ixAAX"></A>


<PRE>
    Copyright (c) 2000-2008, Damian Conway. All Rights Reserved.
    This module is free software. It may be used, redistributed
    and/or modified under the same terms as Perl itself.

</PRE>


<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE">The Problem</A><DD>
<DT><A HREF="#lbAF">A Solution</A><DD>
<DT><A HREF="#lbAG">Disabling or changing &lt;no&gt; behaviour</A><DD>
<DT><A HREF="#lbAH">All-in-one interface</A><DD>
<DT><A HREF="#lbAI">Filtering only specific components of source code</A><DD>
<DT><A HREF="#lbAJ">Filtering only the code parts of source code</A><DD>
<DT><A HREF="#lbAK">Using Filter::Simple with an explicit import subroutine</A><DD>
<DT><A HREF="#lbAL">Using Filter::Simple and Exporter together</A><DD>
<DT><A HREF="#lbAM">How it works</A><DD>
</DL>
<DT><A HREF="#lbAN">AUTHOR</A><DD>
<DT><A HREF="#lbAO">CONTACT</A><DD>
<DT><A HREF="#lbAP">COPYRIGHT AND LICENSE</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:27 GMT, December 24, 2015
</div></div>
</body>
</HTML>
