<!DOCTYPE html>

<HTML><head><TITLE>Manpage of MQ_NOTIFY</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>MQ_NOTIFY</H1>
Section: Linux Programmer's Manual (3)<BR>Updated: 2009-03-31<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

mq_notify - register for notification when a message is available
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<PRE>
<B>#include &lt;<A HREF="file:/usr/include/mqueue.h">mqueue.h</A>&gt;</B>

<B>mqd_t mq_notify(mqd_t </B><I>mqdes</I><B>, const struct sigevent *</B><I>notification</I><B>);</B>
</PRE>

<P>
Link with <I>-lrt</I>.
<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<B>mq_notify</B>()

allows the calling process to register or unregister for delivery of
an asynchronous notification when a new message arrives on
the empty message queue referred to by the descriptor
<I>mqdes</I>.

<P>
The
<I>notification</I>

argument is a pointer to a
<I>sigevent</I>

structure that is defined something like the following:

<PRE>

union sigval {          /* Data passed with notification */
    int     sival_int;         /* Integer value */
    void   *sival_ptr;         /* Pointer value */
};

struct sigevent {
    int          sigev_notify; /* Notification method */
    int          sigev_signo;  /* Notification signal */
    union sigval sigev_value;  /* Data passed with
                                  notification */
    void       (*sigev_notify_function) (union sigval);
                               /* Function for thread
                                  notification */
    void        *sigev_notify_attributes;
                               /* Thread function attributes */
};
</PRE>


<P>

If
<I>notification</I>

is a non-NULL pointer, then
<B>mq_notify</B>()

registers the calling process to receive message notification.
The
<I>sigev_notify</I>

field of the
<I>sigevent</I>

to which
<I>notification</I>

points specifies how notification is to be performed.
This field has one of the following values:
<DL COMPACT>
<DT><B>SIGEV_NONE</B>

<DD>
A &quot;null&quot; notification: the calling process is registered as the target
for notification, but when a message arrives, no notification is sent.

<DT><B>SIGEV_SIGNAL</B>

<DD>
Notify the process by sending the signal specified in
<I>sigev_signo</I>.

If the signal is caught with a signal handler that
was registered using the
<B><A HREF="/manpages/index.html?2+sigaction">sigaction</A></B>(2)

<B>SA_SIGINFO</B>

flag, then the following fields are set in the
<I>siginfo_t</I>

structure that is passed as the second argument of the handler:
<I>si_code</I>

is set to
<B>SI_MESGQ</B>;

<I>si_signo</I>

is set to the signal number;
<I>si_value</I>

is set to the value specified in
<I>notification-&gt;sigev_value</I>;



<I>si_pid</I>

is set to the PID of the process that sent the message; and
<I>si_uid</I>

is set to the real user ID of the sending process.
The same information is available if the signal is accepted using
<B><A HREF="/manpages/index.html?2+sigwaitinfo">sigwaitinfo</A></B>(2).

<DT><B>SIGEV_THREAD</B>

<DD>
Deliver notification by invoking
<I>notification-&gt;sigev_notify_function</I>

as the start function of a new thread.
The function is invoked with
<I>notification-&gt;sigev_value</I>

as its sole argument.
If
<I>notification-&gt;sigev_notify_attributes</I>

is not NULL, then it should point to a
<I>pthread_attr_t</I>

structure that defines attributes for the thread (see
<B><A HREF="/manpages/index.html?3+pthread_attr_init">pthread_attr_init</A></B>(3)).

</DL>
<P>

Only one process can be registered to receive notification
from a message queue.
<P>
If
<I>notification</I>

is NULL, and the calling process is currently registered to receive
notifications for this message queue, then the registration is removed;
another process can then register to receive a message notification
for this queue.
<P>
Message notification only occurs when a new message arrives and
the queue was previously empty.
If the queue was not empty at the time
<B>mq_notify</B>()

was called, then a notification will only occur after
the queue is emptied and a new message arrives.
<P>
If another process or thread is waiting to read a message
from an empty queue using
<B><A HREF="/manpages/index.html?3+mq_receive">mq_receive</A></B>(3),

then any message notification registration is ignored:
the message is delivered to the process or thread calling
<B><A HREF="/manpages/index.html?3+mq_receive">mq_receive</A></B>(3),

and the message notification registration remains in effect.
<P>
Notification occurs once: after a notification is delivered,
the notification registration is removed,
and another process can register for message notification.
If the notified process wishes to receive the next notification,
it can use
<B>mq_notify</B>()

to request a further notification.
This should be done before emptying all unread messages from the queue.
(Placing the queue in non-blocking mode is useful for emptying
the queue of messages without blocking once it is empty.)
<A NAME="lbAE">&nbsp;</A>
<H2>RETURN VALUE</H2>

On success
<B>mq_notify</B>()

returns 0; on error, -1 is returned, with
<I>errno</I>

set to indicate the error.
<A NAME="lbAF">&nbsp;</A>
<H2>ERRORS</H2>

<DL COMPACT>
<DT><B>EBADF</B>

<DD>
The descriptor specified in
<I>mqdes</I>

is invalid.
<DT><B>EBUSY</B>

<DD>
Another process has already registered to receive notification
for this message queue.
<DT><B>EINVAL</B>

<DD>
<I>notification-&gt;sigev_notify</I>

is not one of the permitted values; or
<I>notification-&gt;sigev_notify</I>

is
<B>SIGEV_SIGNAL</B>

and
<I>notification-&gt;sigev_signo</I>

is not a valid signal number.
<DT><B>ENOMEM</B>

<DD>
Insufficient memory.
</DL>
<P>

POSIX.1-2008 says that an implementation
<I>may</I>

generate an
<B>EINVAL</B>


error if
<I>notification</I>

is NULL, and the caller is not currently registered to receive
notifications for the queue
<I>mqdes</I>.

<A NAME="lbAG">&nbsp;</A>
<H2>CONFORMING TO</H2>

POSIX.1-2001.
<A NAME="lbAH">&nbsp;</A>
<H2>EXAMPLE</H2>

The following program registers a notification request for the
message queue named in its command-line argument.
Notification is performed by creating a thread.
The thread executes a function which reads one message from the
queue and then terminates the process.
<PRE>

#include &lt;<A HREF="file:/usr/include/pthread.h">pthread.h</A>&gt;
#include &lt;<A HREF="file:/usr/include/mqueue.h">mqueue.h</A>&gt;
#include &lt;<A HREF="file:/usr/include/assert.h">assert.h</A>&gt;
#include &lt;<A HREF="file:/usr/include/stdio.h">stdio.h</A>&gt;
#include &lt;<A HREF="file:/usr/include/stdlib.h">stdlib.h</A>&gt;
#include &lt;<A HREF="file:/usr/include/unistd.h">unistd.h</A>&gt;

#define handle_error(msg) \
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

static void                     /* Thread start function */
tfunc(union sigval sv)
{
    struct mq_attr attr;
    ssize_t nr;
    void *buf;
    mqd_t mqdes = *((mqd_t *) sv.sival_ptr);

    /* Determine max. msg size; allocate buffer to receive msg */

    if (mq_getattr(mqdes, &amp;attr) == -1)
        handle_error(&quot;mq_getattr&quot;);
    buf = malloc(attr.mq_msgsize);
    if (buf == NULL)
        handle_error(&quot;malloc&quot;);

    nr = mq_receive(mqdes, buf, attr.mq_msgsize, NULL);
    if (nr == -1)
        handle_error(&quot;mq_receive&quot;);

    printf(&quot;Read %ld bytes from MQ\n&quot;, (long) nr);
    free(buf);
    exit(EXIT_SUCCESS);         /* Terminate the process */
}

int
main(int argc, char *argv[])
{
    mqd_t mqdes;
    struct sigevent not;

    assert(argc == 2);

    mqdes = mq_open(argv[1], O_RDONLY);
    if (mqdes == (mqd_t) -1)
        handle_error(&quot;mq_open&quot;);

    not.sigev_notify = SIGEV_THREAD;
    not.sigev_notify_function = tfunc;
    not.sigev_notify_attributes = NULL;
    not.sigev_value.sival_ptr = &amp;mqdes;   /* Arg. to thread func. */
    if (mq_notify(mqdes, &amp;not) == -1)
        handle_error(&quot;mq_notify&quot;);

    pause();    /* Process will be terminated by thread function */
}
</PRE>

<A NAME="lbAI">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="/manpages/index.html?3+mq_close">mq_close</A></B>(3),

<B><A HREF="/manpages/index.html?3+mq_getattr">mq_getattr</A></B>(3),

<B><A HREF="/manpages/index.html?3+mq_open">mq_open</A></B>(3),

<B><A HREF="/manpages/index.html?3+mq_receive">mq_receive</A></B>(3),

<B><A HREF="/manpages/index.html?3+mq_send">mq_send</A></B>(3),

<B><A HREF="/manpages/index.html?3+mq_unlink">mq_unlink</A></B>(3),

<B><A HREF="/manpages/index.html?7+mq_overview">mq_overview</A></B>(7)

<A NAME="lbAJ">&nbsp;</A>
<H2>COLOPHON</H2>

This page is part of release 3.22 of the Linux
<I>man-pages</I>

project.
A description of the project,
and information about reporting bugs,
can be found at
<A HREF="http://www.kernel.org/doc/man-pages/.">http://www.kernel.org/doc/man-pages/.</A>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">RETURN VALUE</A><DD>
<DT><A HREF="#lbAF">ERRORS</A><DD>
<DT><A HREF="#lbAG">CONFORMING TO</A><DD>
<DT><A HREF="#lbAH">EXAMPLE</A><DD>
<DT><A HREF="#lbAI">SEE ALSO</A><DD>
<DT><A HREF="#lbAJ">COLOPHON</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:35 GMT, December 24, 2015
</div></div>
</body>
</HTML>
