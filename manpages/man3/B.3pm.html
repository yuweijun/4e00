<!DOCTYPE html>

<HTML><head><TITLE>Manpage of B</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>B</H1>
Section: Perl Programmers Reference Guide (3pm)<BR>Updated: 2009-02-12<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

B - The Perl Compiler
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
        use B;

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
The <TT>&quot;B&quot;</TT> module supplies classes which allow a Perl program to delve
into its own innards. It is the module used to implement the
``backends'' of the Perl compiler. Usage of the compiler does not
require knowledge of this module: see the <I>O</I> module for the
user-visible part. The <TT>&quot;B&quot;</TT> module is of use to those who want to
write new compiler backends. This documentation assumes that the
reader knows a fair amount about perl's internals including such
things as SVs, OPs and the internal symbol table and syntax tree
of a program.
<A NAME="lbAE">&nbsp;</A>
<H2>OVERVIEW</H2>

<A NAME="ixAAE"></A>
The <TT>&quot;B&quot;</TT> module contains a set of utility functions for querying the
current state of the Perl interpreter; typically these functions
return objects from the B::SV and B::OP classes, or their derived
classes.  These classes in turn define methods for querying the
resulting objects about their own internal state.
<A NAME="lbAF">&nbsp;</A>
<H2>Utility Functions</H2>

<A NAME="ixAAF"></A>
The <TT>&quot;B&quot;</TT> module exports a variety of functions: some are simple
utility functions, others provide a Perl program with a way to
get an initial ``handle'' on an internal object.
<A NAME="lbAG">&nbsp;</A>
<H3>Functions Returning B::SV, B::AV, B::HV, and B::CV objects</H3>



<A NAME="ixAAG"></A>
For descriptions of the class hierarchy of these objects and the
methods that can be called on them, see below, ``<FONT SIZE="-1">OVERVIEW</FONT> <FONT SIZE="-1">OF</FONT>
<FONT SIZE="-1">CLASSES</FONT>'' and ``SV-RELATED <FONT SIZE="-1">CLASSES</FONT>''.
<DL COMPACT>
<DT>sv_undef<DD>
<A NAME="ixAAH"></A>
Returns the <FONT SIZE="-1">SV</FONT> object corresponding to the C variable <TT>&quot;sv_undef&quot;</TT>.
<DT>sv_yes<DD>
<A NAME="ixAAI"></A>
Returns the <FONT SIZE="-1">SV</FONT> object corresponding to the C variable <TT>&quot;sv_yes&quot;</TT>.
<DT>sv_no<DD>
<A NAME="ixAAJ"></A>
Returns the <FONT SIZE="-1">SV</FONT> object corresponding to the C variable <TT>&quot;sv_no&quot;</TT>.
<DT>svref_2object(<FONT SIZE="-1">SVREF</FONT>)<DD>
<A NAME="ixAAK"></A>
Takes a reference to any Perl value, and turns the referred-to value
into an object in the appropriate B::OP-derived or B::SV-derived
class. Apart from functions such as <TT>&quot;main_root&quot;</TT>, this is the primary
way to get an initial ``handle'' on an internal perl data structure
which can then be followed with the other access methods.


<P>


The returned object will only be valid as long as the underlying OPs
and SVs continue to exist. Do not attempt to use the object after the
underlying structures are freed.
<DT>amagic_generation<DD>
<A NAME="ixAAL"></A>
Returns the <FONT SIZE="-1">SV</FONT> object corresponding to the C variable <TT>&quot;amagic_generation&quot;</TT>.
<DT>init_av<DD>
<A NAME="ixAAM"></A>
Returns the <FONT SIZE="-1">AV</FONT> object (i.e. in class B::AV) representing <FONT SIZE="-1">INIT</FONT> blocks.
<DT>check_av<DD>
<A NAME="ixAAN"></A>
Returns the <FONT SIZE="-1">AV</FONT> object (i.e. in class B::AV) representing <FONT SIZE="-1">CHECK</FONT> blocks.
<DT>unitcheck_av<DD>
<A NAME="ixAAO"></A>
Returns the <FONT SIZE="-1">AV</FONT> object (i.e. in class B::AV) representing <FONT SIZE="-1">UNITCHECK</FONT> blocks.
<DT>begin_av<DD>
<A NAME="ixAAP"></A>
Returns the <FONT SIZE="-1">AV</FONT> object (i.e. in class B::AV) representing <FONT SIZE="-1">BEGIN</FONT> blocks.
<DT>end_av<DD>
<A NAME="ixAAQ"></A>
Returns the <FONT SIZE="-1">AV</FONT> object (i.e. in class B::AV) representing <FONT SIZE="-1">END</FONT> blocks.
<DT>comppadlist<DD>
<A NAME="ixAAR"></A>
Returns the <FONT SIZE="-1">AV</FONT> object (i.e. in class B::AV) of the global comppadlist.
<DT>regex_padav<DD>
<A NAME="ixAAS"></A>
Only when perl was compiled with ithreads.
<DT>main_cv<DD>
<A NAME="ixAAT"></A>
Return the (faked) <FONT SIZE="-1">CV</FONT> corresponding to the main part of the Perl
program.
</DL>
<A NAME="lbAH">&nbsp;</A>
<H3>Functions for Examining the Symbol Table</H3>

<A NAME="ixAAU"></A>
<DL COMPACT>
<DT>walksymtable(<FONT SIZE="-1">SYMREF</FONT>, <FONT SIZE="-1">METHOD</FONT>, <FONT SIZE="-1">RECURSE</FONT>, <FONT SIZE="-1">PREFIX</FONT>)<DD>
<A NAME="ixAAV"></A>
Walk the symbol table starting at <FONT SIZE="-1">SYMREF</FONT> and call <FONT SIZE="-1">METHOD</FONT> on each
symbol (a B::GV object) visited.  When the walk reaches package
symbols (such as ``Foo::'') it invokes <FONT SIZE="-1">RECURSE</FONT>, passing in the symbol
name, and only recurses into the package if that sub returns true.


<P>


<FONT SIZE="-1">PREFIX</FONT> is the name of the <FONT SIZE="-1">SYMREF</FONT> you're walking.


<P>


For example:


<P>




<PRE>
  # Walk CGI's symbol table calling print_subs on each symbol.
  # Recurse only into CGI::Util::
  walksymtable(\%CGI::, 'print_subs', sub { $_[0] eq 'CGI::Util::' },
               'CGI::');

</PRE>




<P>


<I>print_subs()</I> is a B::GV method you have declared. Also see ``B::GV
Methods'', below.
</DL>
<A NAME="lbAI">&nbsp;</A>
<H3>Functions Returning B::OP objects or for walking op trees</H3>



<A NAME="ixAAW"></A>
For descriptions of the class hierarchy of these objects and the
methods that can be called on them, see below, ``<FONT SIZE="-1">OVERVIEW</FONT> <FONT SIZE="-1">OF</FONT>
<FONT SIZE="-1">CLASSES</FONT>'' and ``OP-RELATED <FONT SIZE="-1">CLASSES</FONT>''.
<DL COMPACT>
<DT>main_root<DD>
<A NAME="ixAAX"></A>
Returns the root op (i.e. an object in the appropriate B::OP-derived
class) of the main part of the Perl program.
<DT>main_start<DD>
<A NAME="ixAAY"></A>
Returns the starting op of the main part of the Perl program.
<DT>walkoptree(<FONT SIZE="-1">OP</FONT>, <FONT SIZE="-1">METHOD</FONT>)<DD>
<A NAME="ixAAZ"></A>
Does a tree-walk of the syntax tree based at <FONT SIZE="-1">OP</FONT> and calls <FONT SIZE="-1">METHOD</FONT> on
each op it visits. Each node is visited before its children. If
<TT>&quot;walkoptree_debug&quot;</TT> (see below) has been called to turn debugging on then
the method <TT>&quot;walkoptree_debug&quot;</TT> is called on each op before <FONT SIZE="-1">METHOD</FONT> is
called.
<DT>walkoptree_debug(<FONT SIZE="-1">DEBUG</FONT>)<DD>
<A NAME="ixABA"></A>
Returns the current debugging flag for <TT>&quot;walkoptree&quot;</TT>. If the optional
<FONT SIZE="-1">DEBUG</FONT> argument is non-zero, it sets the debugging flag to that. See
the description of <TT>&quot;walkoptree&quot;</TT> above for what the debugging flag
does.
</DL>
<A NAME="lbAJ">&nbsp;</A>
<H3>Miscellaneous Utility Functions</H3>

<A NAME="ixABB"></A>
<DL COMPACT>
<DT>ppname(<FONT SIZE="-1">OPNUM</FONT>)<DD>
<A NAME="ixABC"></A>
Return the <FONT SIZE="-1">PP</FONT> function name (e.g. ``pp_add'') of op number <FONT SIZE="-1">OPNUM</FONT>.
<DT>hash(<FONT SIZE="-1">STR</FONT>)<DD>
<A NAME="ixABD"></A>
Returns a string in the form ``0x...'' representing the value of the
internal hash function used by perl on string <FONT SIZE="-1">STR</FONT>.
<DT>cast_I32(I)<DD>
<A NAME="ixABE"></A>
Casts I to the internal I32 type used by that perl.
<DT>minus_c<DD>
<A NAME="ixABF"></A>
Does the equivalent of the <TT>&quot;-c&quot;</TT> command-line option. Obviously, this
is only useful in a <FONT SIZE="-1">BEGIN</FONT> block or else the flag is set too late.
<DT>cstring(<FONT SIZE="-1">STR</FONT>)<DD>
<A NAME="ixABG"></A>
Returns a double-quote-surrounded escaped version of <FONT SIZE="-1">STR</FONT> which can
be used as a string in C source code.
<DT>perlstring(<FONT SIZE="-1">STR</FONT>)<DD>
<A NAME="ixABH"></A>
Returns a double-quote-surrounded escaped version of <FONT SIZE="-1">STR</FONT> which can
be used as a string in Perl source code.
<DT>class(<FONT SIZE="-1">OBJ</FONT>)<DD>
<A NAME="ixABI"></A>
Returns the class of an object without the part of the classname
preceding the first <TT>&quot;::&quot;</TT>. This is used to turn <TT>&quot;B::UNOP&quot;</TT> into
<TT>&quot;UNOP&quot;</TT> for example.
<DT>threadsv_names<DD>
<A NAME="ixABJ"></A>
In a perl compiled for threads, this returns a list of the special
per-thread threadsv variables.
</DL>
<A NAME="lbAK">&nbsp;</A>
<H3>Exported utility variabiles</H3>

<A NAME="ixABK"></A>
<DL COMPACT>
<DT>@optype<DD>


<A NAME="ixABL"></A>


<PRE>
  my $op_type = $optype[$op_type_num];

</PRE>




<P>


A simple mapping of the op type number to its type (like '<FONT SIZE="-1">COP</FONT>' or '<FONT SIZE="-1">BINOP</FONT>').
<DT>@specialsv_name<DD>


<A NAME="ixABM"></A>


<PRE>
  my $sv_name = $specialsv_name[$sv_index];

</PRE>




<P>


Certain <FONT SIZE="-1">SV</FONT> types are considered 'special'.  They're represented by
B::SPECIAL and are referred to by a number from the specialsv_list.
This array maps that number back to the name of the <FONT SIZE="-1">SV</FONT> (like 'Nullsv'
or '&amp;PL_sv_undef').
</DL>
<A NAME="lbAL">&nbsp;</A>
<H2>OVERVIEW OF CLASSES</H2>

<A NAME="ixABN"></A>
The C structures used by Perl's internals to hold <FONT SIZE="-1">SV</FONT> and <FONT SIZE="-1">OP</FONT>
information (<FONT SIZE="-1">PVIV</FONT>, <FONT SIZE="-1">AV</FONT>, <FONT SIZE="-1">HV</FONT>, ..., <FONT SIZE="-1">OP</FONT>, <FONT SIZE="-1">SVOP</FONT>, <FONT SIZE="-1">UNOP</FONT>, ...) are modelled on a
class hierarchy and the <TT>&quot;B&quot;</TT> module gives access to them via a true
object hierarchy. Structure fields which point to other objects
(whether types of <FONT SIZE="-1">SV</FONT> or types of <FONT SIZE="-1">OP</FONT>) are represented by the <TT>&quot;B&quot;</TT>
module as Perl objects of the appropriate class.
<P>

The bulk of the <TT>&quot;B&quot;</TT> module is the methods for accessing fields of
these structures.
<P>

Note that all access is read-only.  You cannot modify the internals by
using this module. Also, note that the B::OP and B::SV objects created
by this module are only valid for as long as the underlying objects
exist; their creation doesn't increase the reference counts of the
underlying objects. Trying to access the fields of a freed object will
give incomprehensible results, or worse.
<A NAME="lbAM">&nbsp;</A>
<H3>SV-RELATED <FONT SIZE="-1">CLASSES</FONT></H3>

<A NAME="ixABO"></A>
B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM (5.9.5 and
earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO. These classes
correspond in the obvious way to the underlying C structures of similar names.
The inheritance hierarchy mimics the underlying C ``inheritance''. For the
5.10.x branch, (<I>ie</I> 5.10.0, 5.10.1 <I>etc</I>) this is:
<P>



<PRE>
                           B::SV
                             |
                +------------+------------+------------+
                |            |            |            |
              B::PV        B::IV        B::NV        B::RV
                  \         /           /
                   \       /           /
                    B::PVIV           /
                         \           /
                          \         /
                           \       /
                            B::PVNV
                               |
                               |
                            B::PVMG
                               |
                   +-----+-----+-----+-----+
                   |     |     |     |     |
                 B::AV B::GV B::HV B::CV B::IO
                         |           |
                         |           |
                      B::PVLV      B::FM

</PRE>


<P>

For 5.9.0 and earlier, <FONT SIZE="-1">PVLV</FONT> is a direct subclass of <FONT SIZE="-1">PVMG</FONT>, and <FONT SIZE="-1">BM</FONT> is still
present as a distinct type, so the base of this diagram is
<P>



<PRE>
                               |
                               |
                            B::PVMG
                               |
            +------+-----+-----+-----+-----+-----+
            |      |     |     |     |     |     |
         B::PVLV B::BM B::AV B::GV B::HV B::CV B::IO
                                           |
                                           |
                                         B::FM

</PRE>


<P>

For 5.11.0 and later, B::RV is abolished, and IVs can be used to store
references, and a new type B::REGEXP is introduced, giving this structure:
<P>



<PRE>
                           B::SV
                             |
                +------------+------------+
                |            |            |
              B::PV        B::IV        B::NV
                  \         /           /
                   \       /           /
                    B::PVIV           /
                         \           /
                          \         /
                           \       /
                            B::PVNV
                               |
                               |
                            B::PVMG
                               |
           +-------+-------+---+---+-------+-------+
           |       |       |       |       |       |
         B::AV   B::GV   B::HV   B::CV   B::IO B::REGEXP
                   |               |
                   |               |
                B::PVLV          B::FM

</PRE>


<P>

Access methods correspond to the underlying C macros for field access,
usually with the leading ``class indication'' prefix removed (Sv, Av,
Hv, ...). The leading prefix is only left in cases where its removal
would cause a clash in method name. For example, <TT>&quot;GvREFCNT&quot;</TT> stays
as-is since its abbreviation would clash with the ``superclass'' method
<TT>&quot;REFCNT&quot;</TT> (corresponding to the C function <TT>&quot;SvREFCNT&quot;</TT>).
<A NAME="lbAN">&nbsp;</A>
<H3>B::SV Methods</H3>

<A NAME="ixABP"></A>
<DL COMPACT>
<DT><FONT SIZE="-1">REFCNT</FONT><DD>
<A NAME="ixABQ"></A>

<DT><FONT SIZE="-1">FLAGS</FONT><DD>
<A NAME="ixABR"></A>
<DT>object_2svref<DD>
<A NAME="ixABS"></A>

Returns a reference to the regular scalar corresponding to this
B::SV object. In other words, this method is the inverse operation
to the <I>svref_2object()</I> subroutine. This scalar and other data it points
at should be considered read-only: modifying them is neither safe nor
guaranteed to have a sensible effect.
</DL>
<A NAME="lbAO">&nbsp;</A>
<H3>B::IV Methods</H3>

<A NAME="ixABT"></A>
<DL COMPACT>
<DT><FONT SIZE="-1">IV</FONT><DD>
<A NAME="ixABU"></A>
Returns the value of the <FONT SIZE="-1">IV</FONT>, <I>interpreted as
a signed integer</I>. This will be misleading
if <TT>&quot;FLAGS &amp; SVf_IVisUV&quot;</TT>. Perhaps you want the
<TT>&quot;int_value&quot;</TT> method instead?
<DT><FONT SIZE="-1">IVX</FONT><DD>
<A NAME="ixABV"></A>

<DT><FONT SIZE="-1">UVX</FONT><DD>
<A NAME="ixABW"></A>
<DT>int_value<DD>
<A NAME="ixABX"></A>

This method returns the value of the <FONT SIZE="-1">IV</FONT> as an integer.
It differs from <TT>&quot;IV&quot;</TT> in that it returns the correct
value regardless of whether it's stored signed or
unsigned.
<DT>needs64bits<DD>
<A NAME="ixABY"></A>

<DT>packiv<DD>
<A NAME="ixABZ"></A>

</DL>
<A NAME="lbAP">&nbsp;</A>
<H3>B::NV Methods</H3>

<A NAME="ixACA"></A>
<DL COMPACT>
<DT><FONT SIZE="-1">NV</FONT><DD>
<A NAME="ixACB"></A>

<DT><FONT SIZE="-1">NVX</FONT><DD>
<A NAME="ixACC"></A>

</DL>
<A NAME="lbAQ">&nbsp;</A>
<H3>B::RV Methods</H3>

<A NAME="ixACD"></A>
<DL COMPACT>
<DT><FONT SIZE="-1">RV</FONT><DD>
<A NAME="ixACE"></A>
</DL>
<A NAME="lbAR">&nbsp;</A>
<H3>B::PV Methods</H3>

<A NAME="ixACF"></A>

<DL COMPACT>
<DT><FONT SIZE="-1">PV</FONT><DD>
<A NAME="ixACG"></A>

This method is the one you usually want. It constructs a
string using the length and offset information in the struct:
for ordinary scalars it will return the string that you'd see
from Perl, even if it contains null characters.
<DT><FONT SIZE="-1">RV</FONT><DD>
<A NAME="ixACH"></A>
Same as B::RV::RV, except that it will <I>die()</I> if the <FONT SIZE="-1">PV</FONT> isn't
a reference.
<DT><FONT SIZE="-1">PVX</FONT><DD>
<A NAME="ixACI"></A>
This method is less often useful. It assumes that the string
stored in the struct is null-terminated, and disregards the
length information.


<P>


It is the appropriate method to use if you need to get the name
of a lexical variable from a padname array. Lexical variable names
are always stored with a null terminator, and the length field
(SvCUR) is overloaded for other purposes and can't be relied on here.
</DL>
<A NAME="lbAS">&nbsp;</A>
<H3>B::PVMG Methods</H3>

<A NAME="ixACJ"></A>
<DL COMPACT>
<DT><FONT SIZE="-1">MAGIC</FONT><DD>
<A NAME="ixACK"></A>

<DT>SvSTASH<DD>
<A NAME="ixACL"></A>

</DL>
<A NAME="lbAT">&nbsp;</A>
<H3>B::MAGIC Methods</H3>

<A NAME="ixACM"></A>
<DL COMPACT>
<DT><FONT SIZE="-1">MOREMAGIC</FONT><DD>
<A NAME="ixACN"></A>

<DT>precomp<DD>
<A NAME="ixACO"></A>

Only valid on r-magic, returns the string that generated the regexp.
<DT><FONT SIZE="-1">PRIVATE</FONT><DD>
<A NAME="ixACP"></A>

<DT><FONT SIZE="-1">TYPE</FONT><DD>
<A NAME="ixACQ"></A>
<DT><FONT SIZE="-1">FLAGS</FONT><DD>
<A NAME="ixACR"></A>
<DT><FONT SIZE="-1">OBJ</FONT><DD>
<A NAME="ixACS"></A>

Will <I>die()</I> if called on r-magic.
<DT><FONT SIZE="-1">PTR</FONT><DD>
<A NAME="ixACT"></A>

<DT><FONT SIZE="-1">REGEX</FONT><DD>
<A NAME="ixACU"></A>

Only valid on r-magic, returns the integer value of the <FONT SIZE="-1">REGEX</FONT> stored
in the <FONT SIZE="-1">MAGIC</FONT>.
</DL>
<A NAME="lbAU">&nbsp;</A>
<H3>B::PVLV Methods</H3>

<A NAME="ixACV"></A>
<DL COMPACT>
<DT><FONT SIZE="-1">TARGOFF</FONT><DD>
<A NAME="ixACW"></A>

<DT><FONT SIZE="-1">TARGLEN</FONT><DD>
<A NAME="ixACX"></A>
<DT><FONT SIZE="-1">TYPE</FONT><DD>
<A NAME="ixACY"></A>
<DT><FONT SIZE="-1">TARG</FONT><DD>
<A NAME="ixACZ"></A>

</DL>
<A NAME="lbAV">&nbsp;</A>
<H3>B::BM Methods</H3>

<A NAME="ixADA"></A>
<DL COMPACT>
<DT><FONT SIZE="-1">USEFUL</FONT><DD>
<A NAME="ixADB"></A>

<DT><FONT SIZE="-1">PREVIOUS</FONT><DD>
<A NAME="ixADC"></A>
<DT><FONT SIZE="-1">RARE</FONT><DD>
<A NAME="ixADD"></A>
<DT><FONT SIZE="-1">TABLE</FONT><DD>
<A NAME="ixADE"></A>

</DL>
<A NAME="lbAW">&nbsp;</A>
<H3>B::GV Methods</H3>

<A NAME="ixADF"></A>
<DL COMPACT>
<DT>is_empty<DD>
<A NAME="ixADG"></A>
This method returns <FONT SIZE="-1">TRUE</FONT> if the <FONT SIZE="-1">GP</FONT> field of the <FONT SIZE="-1">GV</FONT> is <FONT SIZE="-1">NULL</FONT>.
<DT><FONT SIZE="-1">NAME</FONT><DD>
<A NAME="ixADH"></A>

<DT><FONT SIZE="-1">SAFENAME</FONT><DD>
<A NAME="ixADI"></A>

This method returns the name of the glob, but if the first
character of the name is a control character, then it converts
it to ^X first, so that *^G would return ``^G'' rather than ``\cG''.


<P>


It's useful if you want to print out the name of a variable.
If you restrict yourself to globs which exist at compile-time
then the result ought to be unambiguous, because code like
<TT>&quot;${&quot;^G&quot;} = 1&quot;</TT> is compiled as two ops - a constant string and
a dereference (rv2gv) - so that the glob is created at runtime.


<P>


If you're working with globs at runtime, and need to disambiguate
*^G from *{``^G''}, then you should use the raw <FONT SIZE="-1">NAME</FONT> method.
<DT><FONT SIZE="-1">STASH</FONT><DD>
<A NAME="ixADJ"></A>

<DT><FONT SIZE="-1">SV</FONT><DD>
<A NAME="ixADK"></A>
<DT><FONT SIZE="-1">IO</FONT><DD>
<A NAME="ixADL"></A>
<DT><FONT SIZE="-1">FORM</FONT><DD>
<A NAME="ixADM"></A>
<DT><FONT SIZE="-1">AV</FONT><DD>
<A NAME="ixADN"></A>
<DT><FONT SIZE="-1">HV</FONT><DD>
<A NAME="ixADO"></A>
<DT><FONT SIZE="-1">EGV</FONT><DD>
<A NAME="ixADP"></A>
<DT><FONT SIZE="-1">CV</FONT><DD>
<A NAME="ixADQ"></A>
<DT><FONT SIZE="-1">CVGEN</FONT><DD>
<A NAME="ixADR"></A>
<DT><FONT SIZE="-1">LINE</FONT><DD>
<A NAME="ixADS"></A>
<DT><FONT SIZE="-1">FILE</FONT><DD>
<A NAME="ixADT"></A>
<DT><FONT SIZE="-1">FILEGV</FONT><DD>
<A NAME="ixADU"></A>
<DT>GvREFCNT<DD>
<A NAME="ixADV"></A>
<DT><FONT SIZE="-1">FLAGS</FONT><DD>
<A NAME="ixADW"></A>

</DL>
<A NAME="lbAX">&nbsp;</A>
<H3>B::IO Methods</H3>

<A NAME="ixADX"></A>
<DL COMPACT>
<DT><FONT SIZE="-1">LINES</FONT><DD>
<A NAME="ixADY"></A>

<DT><FONT SIZE="-1">PAGE</FONT><DD>
<A NAME="ixADZ"></A>
<DT><FONT SIZE="-1">PAGE_LEN</FONT><DD>
<A NAME="ixAEA"></A>
<DT><FONT SIZE="-1">LINES_LEFT</FONT><DD>
<A NAME="ixAEB"></A>
<DT><FONT SIZE="-1">TOP_NAME</FONT><DD>
<A NAME="ixAEC"></A>
<DT><FONT SIZE="-1">TOP_GV</FONT><DD>
<A NAME="ixAED"></A>
<DT><FONT SIZE="-1">FMT_NAME</FONT><DD>
<A NAME="ixAEE"></A>
<DT><FONT SIZE="-1">FMT_GV</FONT><DD>
<A NAME="ixAEF"></A>
<DT><FONT SIZE="-1">BOTTOM_NAME</FONT><DD>
<A NAME="ixAEG"></A>
<DT><FONT SIZE="-1">BOTTOM_GV</FONT><DD>
<A NAME="ixAEH"></A>
<DT><FONT SIZE="-1">SUBPROCESS</FONT><DD>
<A NAME="ixAEI"></A>
<DT>IoTYPE<DD>
<A NAME="ixAEJ"></A>
<DT>IoFLAGS<DD>
<A NAME="ixAEK"></A>
<DT>IsSTD<DD>
<A NAME="ixAEL"></A>

Takes one arguments ( 'stdin' | 'stdout' | 'stderr' ) and returns true
if the IoIFP of the object is equal to the handle whose name was
passed as argument ( i.e. <TT>$io</TT>-&gt;IsSTD('stderr') is true if
IoIFP($io) == <I>PerlIO_stdin()</I> ).
</DL>
<A NAME="lbAY">&nbsp;</A>
<H3>B::AV Methods</H3>

<A NAME="ixAEM"></A>
<DL COMPACT>
<DT><FONT SIZE="-1">FILL</FONT><DD>
<A NAME="ixAEN"></A>

<DT><FONT SIZE="-1">MAX</FONT><DD>
<A NAME="ixAEO"></A>
<DT><FONT SIZE="-1">ARRAY</FONT><DD>
<A NAME="ixAEP"></A>
<DT>ARRAYelt<DD>
<A NAME="ixAEQ"></A>

Like <TT>&quot;ARRAY&quot;</TT>, but takes an index as an argument to get only one element,
rather than a list of all of them.
<DT><FONT SIZE="-1">OFF</FONT><DD>
<A NAME="ixAER"></A>
This method is deprecated if running under Perl 5.8, and is no longer present
if running under Perl 5.9
<DT>AvFLAGS<DD>
<A NAME="ixAES"></A>
This method returns the <FONT SIZE="-1">AV</FONT> specific flags. In Perl 5.9 these are now stored
in with the main <FONT SIZE="-1">SV</FONT> flags, so this method is no longer present.
</DL>
<A NAME="lbAZ">&nbsp;</A>
<H3>B::CV Methods</H3>

<A NAME="ixAET"></A>
<DL COMPACT>
<DT><FONT SIZE="-1">STASH</FONT><DD>
<A NAME="ixAEU"></A>

<DT><FONT SIZE="-1">START</FONT><DD>
<A NAME="ixAEV"></A>
<DT><FONT SIZE="-1">ROOT</FONT><DD>
<A NAME="ixAEW"></A>
<DT><FONT SIZE="-1">GV</FONT><DD>
<A NAME="ixAEX"></A>
<DT><FONT SIZE="-1">FILE</FONT><DD>
<A NAME="ixAEY"></A>
<DT><FONT SIZE="-1">DEPTH</FONT><DD>
<A NAME="ixAEZ"></A>
<DT><FONT SIZE="-1">PADLIST</FONT><DD>
<A NAME="ixAFA"></A>
<DT><FONT SIZE="-1">OUTSIDE</FONT><DD>
<A NAME="ixAFB"></A>
<DT><FONT SIZE="-1">OUTSIDE_SEQ</FONT><DD>
<A NAME="ixAFC"></A>
<DT><FONT SIZE="-1">XSUB</FONT><DD>
<A NAME="ixAFD"></A>
<DT><FONT SIZE="-1">XSUBANY</FONT><DD>
<A NAME="ixAFE"></A>

For constant subroutines, returns the constant <FONT SIZE="-1">SV</FONT> returned by the subroutine.
<DT>CvFLAGS<DD>
<A NAME="ixAFF"></A>

<DT>const_sv<DD>
<A NAME="ixAFG"></A>

</DL>
<A NAME="lbBA">&nbsp;</A>
<H3>B::HV Methods</H3>

<A NAME="ixAFH"></A>
<DL COMPACT>
<DT><FONT SIZE="-1">FILL</FONT><DD>
<A NAME="ixAFI"></A>

<DT><FONT SIZE="-1">MAX</FONT><DD>
<A NAME="ixAFJ"></A>
<DT><FONT SIZE="-1">KEYS</FONT><DD>
<A NAME="ixAFK"></A>
<DT><FONT SIZE="-1">RITER</FONT><DD>
<A NAME="ixAFL"></A>
<DT><FONT SIZE="-1">NAME</FONT><DD>
<A NAME="ixAFM"></A>
<DT><FONT SIZE="-1">ARRAY</FONT><DD>
<A NAME="ixAFN"></A>
<DT><FONT SIZE="-1">PMROOT</FONT><DD>
<A NAME="ixAFO"></A>

This method is not present if running under Perl 5.9, as the <FONT SIZE="-1">PMROOT</FONT>
information is no longer stored directly in the hash.
</DL>
<A NAME="lbBB">&nbsp;</A>
<H3>OP-RELATED <FONT SIZE="-1">CLASSES</FONT></H3>

<A NAME="ixAFP"></A>
<TT>&quot;B::OP&quot;</TT>, <TT>&quot;B::UNOP&quot;</TT>, <TT>&quot;B::BINOP&quot;</TT>, <TT>&quot;B::LOGOP&quot;</TT>, <TT>&quot;B::LISTOP&quot;</TT>, <TT>&quot;B::PMOP&quot;</TT>,
<TT>&quot;B::SVOP&quot;</TT>, <TT>&quot;B::PADOP&quot;</TT>, <TT>&quot;B::PVOP&quot;</TT>, <TT>&quot;B::LOOP&quot;</TT>, <TT>&quot;B::COP&quot;</TT>.
<P>

These classes correspond in the obvious way to the underlying C
structures of similar names. The inheritance hierarchy mimics the
underlying C ``inheritance'':
<P>



<PRE>
                                 B::OP
                                   |
                   +---------------+--------+--------+-------+
                   |               |        |        |       |
                B::UNOP          B::SVOP B::PADOP  B::COP  B::PVOP
                 ,'  `-.
                /       `--.
           B::BINOP     B::LOGOP
               |
               |
           B::LISTOP
             ,' `.
            /     \
        B::LOOP B::PMOP

</PRE>


<P>

Access methods correspond to the underlying C structre field names,
with the leading ``class indication'' prefix (<TT>&quot;op_&quot;</TT>) removed.
<A NAME="lbBC">&nbsp;</A>
<H3>B::OP Methods</H3>

<A NAME="ixAFQ"></A>
These methods get the values of similarly named fields within the <FONT SIZE="-1">OP</FONT>
data structure.  See top of <TT>&quot;op.h&quot;</TT> for more info.
<DL COMPACT>
<DT>next<DD>
<A NAME="ixAFR"></A>

<DT>sibling<DD>
<A NAME="ixAFS"></A>
<DT>name<DD>
<A NAME="ixAFT"></A>

This returns the op name as a string (e.g. ``add'', ``rv2av'').
<DT>ppaddr<DD>
<A NAME="ixAFU"></A>
This returns the function name as a string (e.g. ``PL_ppaddr[<FONT SIZE="-1">OP_ADD</FONT>]'',
``PL_ppaddr[<FONT SIZE="-1">OP_RV2AV</FONT>]'').
<DT>desc<DD>
<A NAME="ixAFV"></A>
This returns the op description from the global C PL_op_desc array
(e.g. ``addition'' ``array deref'').
<DT>targ<DD>
<A NAME="ixAFW"></A>

<DT>type<DD>
<A NAME="ixAFX"></A>
<DT>opt<DD>
<A NAME="ixAFY"></A>
<DT>flags<DD>
<A NAME="ixAFZ"></A>
<DT>private<DD>
<A NAME="ixAGA"></A>
<DT>spare<DD>
<A NAME="ixAGB"></A>

</DL>
<A NAME="lbBD">&nbsp;</A>
<H3>B::UNOP <FONT SIZE="-1">METHOD</FONT></H3>

<A NAME="ixAGC"></A>
<DL COMPACT>
<DT>first<DD>
<A NAME="ixAGD"></A>
</DL>
<A NAME="lbBE">&nbsp;</A>
<H3>B::BINOP <FONT SIZE="-1">METHOD</FONT></H3>

<A NAME="ixAGE"></A>

<DL COMPACT>
<DT>last<DD>
<A NAME="ixAGF"></A>

</DL>
<A NAME="lbBF">&nbsp;</A>
<H3>B::LOGOP <FONT SIZE="-1">METHOD</FONT></H3>

<A NAME="ixAGG"></A>
<DL COMPACT>
<DT>other<DD>
<A NAME="ixAGH"></A>
</DL>
<A NAME="lbBG">&nbsp;</A>
<H3>B::LISTOP <FONT SIZE="-1">METHOD</FONT></H3>

<A NAME="ixAGI"></A>

<DL COMPACT>
<DT>children<DD>
<A NAME="ixAGJ"></A>

</DL>
<A NAME="lbBH">&nbsp;</A>
<H3>B::PMOP Methods</H3>

<A NAME="ixAGK"></A>
<DL COMPACT>
<DT>pmreplroot<DD>
<A NAME="ixAGL"></A>

<DT>pmreplstart<DD>
<A NAME="ixAGM"></A>
<DT>pmnext<DD>
<A NAME="ixAGN"></A>

Only up to Perl 5.9.4
<DT>pmregexp<DD>
<A NAME="ixAGO"></A>

<DT>pmflags<DD>
<A NAME="ixAGP"></A>
<DT>extflags<DD>
<A NAME="ixAGQ"></A>

Since Perl 5.9.5
<DT>precomp<DD>
<A NAME="ixAGR"></A>

<DT>pmoffset<DD>
<A NAME="ixAGS"></A>

Only when perl was compiled with ithreads.
</DL>
<A NAME="lbBI">&nbsp;</A>
<H3>B::SVOP <FONT SIZE="-1">METHOD</FONT></H3>

<A NAME="ixAGT"></A>
<DL COMPACT>
<DT>sv<DD>
<A NAME="ixAGU"></A>

<DT>gv<DD>
<A NAME="ixAGV"></A>

</DL>
<A NAME="lbBJ">&nbsp;</A>
<H3>B::PADOP <FONT SIZE="-1">METHOD</FONT></H3>

<A NAME="ixAGW"></A>
<DL COMPACT>
<DT>padix<DD>
<A NAME="ixAGX"></A>
</DL>
<A NAME="lbBK">&nbsp;</A>
<H3>B::PVOP <FONT SIZE="-1">METHOD</FONT></H3>

<A NAME="ixAGY"></A>

<DL COMPACT>
<DT>pv<DD>
<A NAME="ixAGZ"></A>

</DL>
<A NAME="lbBL">&nbsp;</A>
<H3>B::LOOP Methods</H3>

<A NAME="ixAHA"></A>
<DL COMPACT>
<DT>redoop<DD>
<A NAME="ixAHB"></A>

<DT>nextop<DD>
<A NAME="ixAHC"></A>
<DT>lastop<DD>
<A NAME="ixAHD"></A>

</DL>
<A NAME="lbBM">&nbsp;</A>
<H3>B::COP Methods</H3>

<A NAME="ixAHE"></A>
<DL COMPACT>
<DT>label<DD>
<A NAME="ixAHF"></A>

<DT>stash<DD>
<A NAME="ixAHG"></A>
<DT>stashpv<DD>
<A NAME="ixAHH"></A>
<DT>file<DD>
<A NAME="ixAHI"></A>
<DT>cop_seq<DD>
<A NAME="ixAHJ"></A>
<DT>arybase<DD>
<A NAME="ixAHK"></A>
<DT>line<DD>
<A NAME="ixAHL"></A>
<DT>warnings<DD>
<A NAME="ixAHM"></A>
<DT>io<DD>
<A NAME="ixAHN"></A>
<DT>hints<DD>
<A NAME="ixAHO"></A>
<DT>hints_hash<DD>
<A NAME="ixAHP"></A>

</DL>
<A NAME="lbBN">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixAHQ"></A>
Malcolm Beattie, <TT>&quot;<A HREF="mailto:mbeattie@sable.ox.ac.uk">mbeattie@sable.ox.ac.uk</A>&quot;</TT>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">OVERVIEW</A><DD>
<DT><A HREF="#lbAF">Utility Functions</A><DD>
<DL>
<DT><A HREF="#lbAG">Functions Returning B::SV, B::AV, B::HV, and B::CV objects</A><DD>
<DT><A HREF="#lbAH">Functions for Examining the Symbol Table</A><DD>
<DT><A HREF="#lbAI">Functions Returning B::OP objects or for walking op trees</A><DD>
<DT><A HREF="#lbAJ">Miscellaneous Utility Functions</A><DD>
<DT><A HREF="#lbAK">Exported utility variabiles</A><DD>
</DL>
<DT><A HREF="#lbAL">OVERVIEW OF CLASSES</A><DD>
<DL>
<DT><A HREF="#lbAM">SV-RELATED <FONT SIZE="-1">CLASSES</FONT></A><DD>
<DT><A HREF="#lbAN">B::SV Methods</A><DD>
<DT><A HREF="#lbAO">B::IV Methods</A><DD>
<DT><A HREF="#lbAP">B::NV Methods</A><DD>
<DT><A HREF="#lbAQ">B::RV Methods</A><DD>
<DT><A HREF="#lbAR">B::PV Methods</A><DD>
<DT><A HREF="#lbAS">B::PVMG Methods</A><DD>
<DT><A HREF="#lbAT">B::MAGIC Methods</A><DD>
<DT><A HREF="#lbAU">B::PVLV Methods</A><DD>
<DT><A HREF="#lbAV">B::BM Methods</A><DD>
<DT><A HREF="#lbAW">B::GV Methods</A><DD>
<DT><A HREF="#lbAX">B::IO Methods</A><DD>
<DT><A HREF="#lbAY">B::AV Methods</A><DD>
<DT><A HREF="#lbAZ">B::CV Methods</A><DD>
<DT><A HREF="#lbBA">B::HV Methods</A><DD>
<DT><A HREF="#lbBB">OP-RELATED <FONT SIZE="-1">CLASSES</FONT></A><DD>
<DT><A HREF="#lbBC">B::OP Methods</A><DD>
<DT><A HREF="#lbBD">B::UNOP <FONT SIZE="-1">METHOD</FONT></A><DD>
<DT><A HREF="#lbBE">B::BINOP <FONT SIZE="-1">METHOD</FONT></A><DD>
<DT><A HREF="#lbBF">B::LOGOP <FONT SIZE="-1">METHOD</FONT></A><DD>
<DT><A HREF="#lbBG">B::LISTOP <FONT SIZE="-1">METHOD</FONT></A><DD>
<DT><A HREF="#lbBH">B::PMOP Methods</A><DD>
<DT><A HREF="#lbBI">B::SVOP <FONT SIZE="-1">METHOD</FONT></A><DD>
<DT><A HREF="#lbBJ">B::PADOP <FONT SIZE="-1">METHOD</FONT></A><DD>
<DT><A HREF="#lbBK">B::PVOP <FONT SIZE="-1">METHOD</FONT></A><DD>
<DT><A HREF="#lbBL">B::LOOP Methods</A><DD>
<DT><A HREF="#lbBM">B::COP Methods</A><DD>
</DL>
<DT><A HREF="#lbBN">AUTHOR</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:12 GMT, December 24, 2015
</div></body>
</HTML>
