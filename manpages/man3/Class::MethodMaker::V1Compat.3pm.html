<!DOCTYPE html>

<HTML><head><TITLE>Manpage of Class::MethodMaker::V1Compat</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux man pages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>Class::MethodMaker::V1Compat</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2008-12-03<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Class::MethodMaker::V1Compat - V1 compatibility code for C::MM
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>
This class is for internal implementation only.  It is not a public <FONT SIZE="-1">API</FONT>.
<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
Class::MethodMaker version 2 strives for backward-compatiblity with version 1
as far as possible.  That is to say, classes built with version 1 should work
with few if any changes.  However, the calling conventions for building new
classes are significantly different: this is necessary to achieve a greater
consistency of arguments.
<P>

Version 2 takes all arguments within a single arrayref:
<P>



<PRE>
  use Class::MethodMaker
    [ scalar =&gt; 'a' ];

</PRE>


<P>

If arguments are presented as a list, then Class::MethodMaker assumes that
this is a version 1 call, and acts accordingly.  Version 1 arguments are
passed and internally rephrased to version 2 arguments, and passed off to the
version 2 engine.  Thus, the majority of version 1 calls can be upgraded to
version 2 merely by rephrasing.  However, there are a number of behaviours
that in version 1 that are internally inconsistent.  These behaviours are
mimicked in version 1 mode as far as possible, but are not reproducible in
version 2 (to allow version 2 clients to rely on a more internally consistent
interface).
<A NAME="lbAE">&nbsp;</A>
<H3>Version 2 Implementations</H3>

<A NAME="ixAAE"></A>
The nearest equivalent to each 1 component (slot) available in version 2 is
shown below using the indicated data-structures &amp; options to create a
component called <TT>&quot;a&quot;</TT> that mimicks the V1 component behaviour as closely as
possible:
<DL COMPACT>
<DT>abstract<DD>
<A NAME="ixAAF"></A>


<PRE>
  use Class::MethodMaker
    [ abstract =&gt; 'a' ];

</PRE>


<DT>boolean<DD>
<A NAME="ixAAG"></A>
Boolean is available as a backwards compatiblity hack, but there is currently
no V2 equivalent.  It is likely that some replacement mechanism will be
introduced in the future, but that it will be incompatible with the version 1
boolean.
<DT>code<DD>
<A NAME="ixAAH"></A>


<PRE>
  use Class::MethodMaker
    [ scalar =&gt; 'a' ];

</PRE>




<P>


Let's face it, the v1 store-if-it's-a-coderef-else-retrieve semantics are
rather broken.  How do you pass a coderef as argument to one of these?  It is
on the <FONT SIZE="-1">TODO</FONT> list to recognize code as fundamental restricted type (analogous
to <FONT SIZE="-1">INTEGER</FONT>), which would add in a <TT>*_invoke</TT> method.
<DT>copy<DD>
<A NAME="ixAAI"></A>


<PRE>
  use Class::MethodMaker
    [ copy =&gt; 'a' ];

</PRE>




<P>


The v2 method is the same as v1.
<DT>counter<DD>
<A NAME="ixAAJ"></A>


<PRE>
  use Class::MethodMaker
    [ scalar =&gt; [{-type =&gt; Class::MethodMaker::Constants::INTEGER}, 'a'] ];

</PRE>


<DT>copy<DD>
<A NAME="ixAAK"></A>

<DT>deep_copy<DD>
<A NAME="ixAAL"></A>



<PRE>
  use Class::MethodMaker
    [ copy =&gt; [ -deep =&gt; 'a' ] ];

</PRE>


<DT>get_concat<DD>
<A NAME="ixAAM"></A>


<PRE>
  use Class::MethodMaker
    [ scalar =&gt; [{ -store_cb =&gt; sub {
                                  defined $_[1] ? ( defined $_[3] ?
                                                    &quot;$_[3] $_[1]&quot; : $_[1] )
                                                : undef;
                                }
                 },
                 'a' ]
    ];

</PRE>


<DT>get_set<DD>
<A NAME="ixAAN"></A>


<PRE>
  use Class::MethodMaker
    [ scalar =&gt; 'a' ];

</PRE>


<DT>hash<DD>
<A NAME="ixAAO"></A>


<PRE>
  use Class::MethodMaker
    [ hash =&gt; 'a' ];

</PRE>


<DT>key_attrib<DD>
<A NAME="ixAAP"></A>
Although v1 calls will continue to work, this is not supported in v2.
<DT>key_with_create<DD>
<A NAME="ixAAQ"></A>
Although v1 calls will continue to work, this is not supported in v2.
<DT>list<DD>
<A NAME="ixAAR"></A>


<PRE>
  use Class::MethodMaker
    [ list =&gt; 'a' ];

</PRE>




<P>


Note that the <TT>&quot;*&quot;</TT> method now <I>sets</I> the whole array if given arguments.
<DT>method<DD>
<A NAME="ixAAS"></A>
See <TT>&quot;code&quot;</TT>.
<DT>new<DD>
<A NAME="ixAAT"></A>


<PRE>
  use Class::MethodMaker
    [ new =&gt; 'a' ];

</PRE>


<DT>new_hash_init<DD>
<A NAME="ixAAU"></A>


<PRE>
  use Class::MethodMaker
    [ new =&gt; [ -hash =&gt; 'a' ] ];

</PRE>


<DT>new_hash_with_init<DD>
<A NAME="ixAAV"></A>


<PRE>
  use Class::MethodMaker
    [ new =&gt; [ -hash =&gt; -init =&gt; 'a' ] ];

</PRE>


<DT>new_with_args<DD>
<A NAME="ixAAW"></A>
Although v1 calls will continue to work, this is not supported in v2, for it
is a trivial application of <TT>&quot;new_with_init&quot;</TT>.
<DT>new_with_init<DD>
<A NAME="ixAAX"></A>


<PRE>
  use Class::MethodMaker
    [ new =&gt; [ -init =&gt; 'a' ] ];

</PRE>


<DT>object<DD>
<A NAME="ixAAY"></A>


<PRE>
  use Class::MethodMaker
    [ scalar =&gt; [{ -type    =&gt; 'MyClass',
                   -forward =&gt; [qw/ method1 method2 /] }, 'a' ]
    ];

</PRE>


<DT>object_tie_hash<DD>
<A NAME="ixAAZ"></A>


<PRE>
  use Class::MethodMaker
    [ hash =&gt; [{ -type      =&gt; 'MyClass',
                 -forward   =&gt; [qw/ method1 method2 /],
                 -tie_class =&gt; 'Tie::MyTie',
                 -tie_args  =&gt; [qw/ foo bar baz /],
               }, 'a' ]
    ];

</PRE>


<DT>object_tie_list<DD>
<A NAME="ixABA"></A>


<PRE>
  use Class::MethodMaker
    [ array =&gt; [{ -type      =&gt; 'MyClass',
                  -forward   =&gt; [qw/ method1 method2 /],
                  -tie_class =&gt; 'Tie::MyTie',
                  -tie_args  =&gt; [qw/ foo bar baz /],
                }, 'a' ]
    ];

</PRE>


<DT>set_once<DD>
<A NAME="ixABB"></A>


<PRE>
  use Class::MethodMaker
    [ scalar =&gt; [{ -store_cb =&gt; sub {
                                  die &quot;Already stored $_[3]&quot;
                                    if @_ &gt; 3;
                                }
                 },
                 'a' ]
    ];

</PRE>


<DT>set_once_static<DD>
<A NAME="ixABC"></A>


<PRE>
  use Class::MethodMaker
    [ scalar =&gt; [{ -store_cb =&gt; sub {
                                  die &quot;Already stored $_[3]&quot;
                                    if @_ &gt; 3;
                                },
                   -static   =&gt; 1,
                 },
                 'a' ]
    ];

</PRE>


<DT>singleton<DD>
<A NAME="ixABD"></A>


<PRE>
  use Class::MethodMaker
    [ new =&gt; [ -singleton =&gt; -hash =&gt; -init =&gt; 'a' ] ];

</PRE>


<DT>static_get_set<DD>
<A NAME="ixABE"></A>


<PRE>
  use Class::MethodMaker
    [ scalar =&gt; [ -static =&gt; 'a' ], ];

</PRE>


<DT>static_hash<DD>
<A NAME="ixABF"></A>


<PRE>
  use Class::MethodMaker
    [ hash =&gt; [ -static =&gt; 'a' ], ];

</PRE>


<DT>static_list<DD>
<A NAME="ixABG"></A>


<PRE>
  use Class::MethodMaker
    [ list =&gt; [ -static =&gt; 'a' ], ];

</PRE>


<DT>tie_hash<DD>
<A NAME="ixABH"></A>


<PRE>
  use Class::MethodMaker
    [ hash =&gt; [ { -tie_class =&gt; 'MyTie',
                  -tie_args  =&gt; [qw/ foo bar baz /],
                } =&gt; 'a' ], ];

</PRE>


<DT>tie_list<DD>
<A NAME="ixABI"></A>


<PRE>
  use Class::MethodMaker
    [ array =&gt; [ { -tie_class =&gt; 'MyTie',
                   -tie_args  =&gt; [qw/ foo bar baz /],
                 } =&gt; 'a' ], ];

</PRE>


<DT>tie_scalar<DD>
<A NAME="ixABJ"></A>


<PRE>
  use Class::MethodMaker
    [ scalar =&gt; [ { -tie_class =&gt; 'MyTie',
                    -tie_args  =&gt; [qw/ foo bar baz /],
                  } =&gt; 'a' ], ];

</PRE>


</DL>
<A NAME="lbAF">&nbsp;</A>
<H3>Caveats &amp; Expected Breakages</H3>

<A NAME="ixABK"></A>
The following version 1 component (slot) types are not currently supported in
version 2:
<DL COMPACT>
<DT>grouped_fields<DD>
<A NAME="ixABL"></A>

<DT>hash_of_lists<DD>
<A NAME="ixABM"></A>
<DT>listed_attrib<DD>
<A NAME="ixABN"></A>
<DT>struct<DD>
<A NAME="ixABO"></A>

</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>EXAMPLES</H2>

<A NAME="ixABP"></A>
<P>
<A NAME="lbAH">&nbsp;</A>
<H2>BUGS</H2>

<A NAME="ixABQ"></A>
<P>
<A NAME="lbAI">&nbsp;</A>
<H2>REPORTING BUGS</H2>

<A NAME="ixABR"></A>
Email the development mailing list <TT>&quot;<A HREF="mailto:class-mmaker-devel@lists.sourceforge.net">class-mmaker-devel@lists.sourceforge.net</A>&quot;</TT>.
<A NAME="lbAJ">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixABS"></A>
Martyn J. Pearce
<A NAME="lbAK">&nbsp;</A>
<H2>COPYRIGHT</H2>

<A NAME="ixABT"></A>
Copyright (c) 2003, 2004 Martyn J. Pearce.  This program is free software; you
can redistribute it and/or modify it under the same terms as Perl itself.
<A NAME="lbAL">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixABU"></A>
<P>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE">Version 2 Implementations</A><DD>
<DT><A HREF="#lbAF">Caveats &amp; Expected Breakages</A><DD>
</DL>
<DT><A HREF="#lbAG">EXAMPLES</A><DD>
<DT><A HREF="#lbAH">BUGS</A><DD>
<DT><A HREF="#lbAI">REPORTING BUGS</A><DD>
<DT><A HREF="#lbAJ">AUTHOR</A><DD>
<DT><A HREF="#lbAK">COPYRIGHT</A><DD>
<DT><A HREF="#lbAL">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:15 GMT, December 24, 2015
</div></body>
</HTML>
