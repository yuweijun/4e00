<!DOCTYPE html>

<HTML><head><TITLE>Manpage of bn_internal</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>bn_internal</H1>
Section: OpenSSL (3)<BR>Updated: 2009-10-28<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

bn_mul_words, bn_mul_add_words, bn_sqr_words, bn_div_words,
bn_add_words, bn_sub_words, bn_mul_comba4, bn_mul_comba8,
bn_sqr_comba4, bn_sqr_comba8, bn_cmp_words, bn_mul_normal,
bn_mul_low_normal, bn_mul_recursive, bn_mul_part_recursive,
bn_mul_low_recursive, bn_mul_high, bn_sqr_normal, bn_sqr_recursive,
bn_expand, bn_wexpand, bn_expand2, bn_fix_top, bn_check_top,
bn_print, bn_dump, bn_set_max, bn_set_high, bn_set_low - BIGNUM
library internal functions
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
 #include &lt;<A HREF="file:/usr/include/openssl/bn.h">openssl/bn.h</A>&gt;

 BN_ULONG bn_mul_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w);
 BN_ULONG bn_mul_add_words(BN_ULONG *rp, BN_ULONG *ap, int num,
   BN_ULONG w);
 void     bn_sqr_words(BN_ULONG *rp, BN_ULONG *ap, int num);
 BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d);
 BN_ULONG bn_add_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,
   int num);
 BN_ULONG bn_sub_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,
   int num);

 void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
 void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
 void bn_sqr_comba4(BN_ULONG *r, BN_ULONG *a);
 void bn_sqr_comba8(BN_ULONG *r, BN_ULONG *a);

 int bn_cmp_words(BN_ULONG *a, BN_ULONG *b, int n);

 void bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b,
   int nb);
 void bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n);
 void bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,
   int dna,int dnb,BN_ULONG *tmp);
 void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,
   int n, int tna,int tnb, BN_ULONG *tmp);
 void bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,
   int n2, BN_ULONG *tmp);
 void bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l,
   int n2, BN_ULONG *tmp);

 void bn_sqr_normal(BN_ULONG *r, BN_ULONG *a, int n, BN_ULONG *tmp);
 void bn_sqr_recursive(BN_ULONG *r, BN_ULONG *a, int n2, BN_ULONG *tmp);

 void mul(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);
 void mul_add(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);
 void sqr(BN_ULONG r0, BN_ULONG r1, BN_ULONG a);

 BIGNUM *bn_expand(BIGNUM *a, int bits);
 BIGNUM *bn_wexpand(BIGNUM *a, int n);
 BIGNUM *bn_expand2(BIGNUM *a, int n);
 void bn_fix_top(BIGNUM *a);

 void bn_check_top(BIGNUM *a);
 void bn_print(BIGNUM *a);
 void bn_dump(BN_ULONG *d, int n);
 void bn_set_max(BIGNUM *a);
 void bn_set_high(BIGNUM *r, BIGNUM *a, int n);
 void bn_set_low(BIGNUM *r, BIGNUM *a, int n);

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
This page documents the internal functions used by the OpenSSL
<B></B><FONT SIZE="-1"><B>BIGNUM</B></FONT><B></B> implementation. They are described here to facilitate
debugging and extending the library. They are <I>not</I> to be used by
applications.
<A NAME="lbAE">&nbsp;</A>
<H3>The <FONT SIZE="-1">BIGNUM</FONT> structure</H3>

<A NAME="ixAAE"></A>


<PRE>
 typedef struct bignum_st BIGNUM;

 struct bignum_st
        {
        BN_ULONG *d;    /* Pointer to an array of 'BN_BITS2' bit chunks. */
        int top;        /* Index of last used d +1. */
        /* The next are internal book keeping for bn_expand. */
        int dmax;       /* Size of the d array. */
        int neg;        /* one if the number is negative */
        int flags;
        };

</PRE>


<P>

The integer value is stored in <B>d</B>, a <I>malloc()</I>ed array of words (<B></B><FONT SIZE="-1"><B>BN_ULONG</B></FONT><B></B>),
least significant word first. A <B></B><FONT SIZE="-1"><B>BN_ULONG</B></FONT><B></B> can be either 16, 32 or 64 bits
in size, depending on the 'number of bits' (<B></B><FONT SIZE="-1"><B>BITS2</B></FONT><B></B>) specified in
<TT>&quot;openssl/bn.h&quot;</TT>.
<P>

<B>dmax</B> is the size of the <B>d</B> array that has been allocated.  <B>top</B>
is the number of words being used, so for a value of 4, bn.d[0]=4 and
bn.top=1.  <B>neg</B> is 1 if the number is negative.  When a <B></B><FONT SIZE="-1"><B>BIGNUM</B></FONT><B></B> is
<B>0</B>, the <B>d</B> field can be <B></B><FONT SIZE="-1"><B>NULL</B></FONT><B></B> and <B>top</B> == <B>0</B>.
<P>

<B>flags</B> is a bit field of flags which are defined in <TT>&quot;openssl/bn.h&quot;</TT>. The 
flags begin with <B></B><FONT SIZE="-1"><B>BN_FLG_</B></FONT><B></B>. The macros BN_set_flags(b,n) and 
BN_get_flags(b,n) exist to enable or fetch flag(s) <B>n</B> from <B></B><FONT SIZE="-1"><B>BIGNUM</B></FONT><B></B>
structure <B>b</B>.
<P>

Various routines in this library require the use of temporary
<B></B><FONT SIZE="-1"><B>BIGNUM</B></FONT><B></B> variables during their execution.  Since dynamic memory
allocation to create <B></B><FONT SIZE="-1"><B>BIGNUM</B></FONT><B></B>s is rather expensive when used in
conjunction with repeated subroutine calls, the <B></B><FONT SIZE="-1"><B>BN_CTX</B></FONT><B></B> structure is
used.  This structure contains <B></B><FONT SIZE="-1"><B>BN_CTX_NUM</B></FONT><B></B> <B></B><FONT SIZE="-1"><B>BIGNUM</B></FONT><B></B>s, see
<I><A HREF="/manpages/index.html?3+BN_CTX_start">BN_CTX_start</A></I>(3).
<A NAME="lbAF">&nbsp;</A>
<H3>Low-level arithmetic operations</H3>

<A NAME="ixAAF"></A>
These functions are implemented in C and for several platforms in
assembly language:
<P>

bn_mul_words(<B>rp</B>, <B>ap</B>, <B>num</B>, <B>w</B>) operates on the <B>num</B> word
arrays <B>rp</B> and <B>ap</B>.  It computes <B>ap</B> * <B>w</B>, places the result
in <B>rp</B>, and returns the high word (carry).
<P>

bn_mul_add_words(<B>rp</B>, <B>ap</B>, <B>num</B>, <B>w</B>) operates on the <B>num</B>
word arrays <B>rp</B> and <B>ap</B>.  It computes <B>ap</B> * <B>w</B> + <B>rp</B>, places
the result in <B>rp</B>, and returns the high word (carry).
<P>

bn_sqr_words(<B>rp</B>, <B>ap</B>, <B>n</B>) operates on the <B>num</B> word array
<B>ap</B> and the 2*<B>num</B> word array <B>ap</B>.  It computes <B>ap</B> * <B>ap</B>
word-wise, and places the low and high bytes of the result in <B>rp</B>.
<P>

bn_div_words(<B>h</B>, <B>l</B>, <B>d</B>) divides the two word number (<B>h</B>,<B>l</B>)
by <B>d</B> and returns the result.
<P>

bn_add_words(<B>rp</B>, <B>ap</B>, <B>bp</B>, <B>num</B>) operates on the <B>num</B> word
arrays <B>ap</B>, <B>bp</B> and <B>rp</B>.  It computes <B>ap</B> + <B>bp</B>, places the
result in <B>rp</B>, and returns the high word (carry).
<P>

bn_sub_words(<B>rp</B>, <B>ap</B>, <B>bp</B>, <B>num</B>) operates on the <B>num</B> word
arrays <B>ap</B>, <B>bp</B> and <B>rp</B>.  It computes <B>ap</B> - <B>bp</B>, places the
result in <B>rp</B>, and returns the carry (1 if <B>bp</B> &gt; <B>ap</B>, 0
otherwise).
<P>

bn_mul_comba4(<B>r</B>, <B>a</B>, <B>b</B>) operates on the 4 word arrays <B>a</B> and
<B>b</B> and the 8 word array <B>r</B>.  It computes <B>a</B>*<B>b</B> and places the
result in <B>r</B>.
<P>

bn_mul_comba8(<B>r</B>, <B>a</B>, <B>b</B>) operates on the 8 word arrays <B>a</B> and
<B>b</B> and the 16 word array <B>r</B>.  It computes <B>a</B>*<B>b</B> and places the
result in <B>r</B>.
<P>

bn_sqr_comba4(<B>r</B>, <B>a</B>, <B>b</B>) operates on the 4 word arrays <B>a</B> and
<B>b</B> and the 8 word array <B>r</B>.
<P>

bn_sqr_comba8(<B>r</B>, <B>a</B>, <B>b</B>) operates on the 8 word arrays <B>a</B> and
<B>b</B> and the 16 word array <B>r</B>.
<P>

The following functions are implemented in C:
<P>

bn_cmp_words(<B>a</B>, <B>b</B>, <B>n</B>) operates on the <B>n</B> word arrays <B>a</B>
and <B>b</B>.  It returns 1, 0 and -1 if <B>a</B> is greater than, equal and
less than <B>b</B>.
<P>

bn_mul_normal(<B>r</B>, <B>a</B>, <B>na</B>, <B>b</B>, <B>nb</B>) operates on the <B>na</B>
word array <B>a</B>, the <B>nb</B> word array <B>b</B> and the <B>na</B>+<B>nb</B> word
array <B>r</B>.  It computes <B>a</B>*<B>b</B> and places the result in <B>r</B>.
<P>

bn_mul_low_normal(<B>r</B>, <B>a</B>, <B>b</B>, <B>n</B>) operates on the <B>n</B> word
arrays <B>r</B>, <B>a</B> and <B>b</B>.  It computes the <B>n</B> low words of
<B>a</B>*<B>b</B> and places the result in <B>r</B>.
<P>

bn_mul_recursive(<B>r</B>, <B>a</B>, <B>b</B>, <B>n2</B>, <B>dna</B>, <B>dnb</B>, <B>t</B>) operates
on the word arrays <B>a</B> and <B>b</B> of length <B>n2</B>+<B>dna</B> and <B>n2</B>+<B>dnb</B>
(<B>dna</B> and <B>dnb</B> are currently allowed to be 0 or negative) and the 2*<B>n2</B>
word arrays <B>r</B> and <B>t</B>.  <B>n2</B> must be a power of 2.  It computes
<B>a</B>*<B>b</B> and places the result in <B>r</B>.
<P>

bn_mul_part_recursive(<B>r</B>, <B>a</B>, <B>b</B>, <B>n</B>, <B>tna</B>, <B>tnb</B>, <B>tmp</B>)
operates on the word arrays <B>a</B> and <B>b</B> of length <B>n</B>+<B>tna</B> and
<B>n</B>+<B>tnb</B> and the 4*<B>n</B> word arrays <B>r</B> and <B>tmp</B>.
<P>

bn_mul_low_recursive(<B>r</B>, <B>a</B>, <B>b</B>, <B>n2</B>, <B>tmp</B>) operates on the
<B>n2</B> word arrays <B>r</B> and <B>tmp</B> and the <B>n2</B>/2 word arrays <B>a</B>
and <B>b</B>.
<P>

bn_mul_high(<B>r</B>, <B>a</B>, <B>b</B>, <B>l</B>, <B>n2</B>, <B>tmp</B>) operates on the
<B>n2</B> word arrays <B>r</B>, <B>a</B>, <B>b</B> and <B>l</B> (?) and the 3*<B>n2</B> word
array <B>tmp</B>.
<P>

<I>BN_mul()</I> calls <I>bn_mul_normal()</I>, or an optimized implementation if the
factors have the same size: <I>bn_mul_comba8()</I> is used if they are 8
words long, <I>bn_mul_recursive()</I> if they are larger than
<B></B><FONT SIZE="-1"><B>BN_MULL_SIZE_NORMAL</B></FONT><B></B> and the size is an exact multiple of the word
size, and <I>bn_mul_part_recursive()</I> for others that are larger than
<B></B><FONT SIZE="-1"><B>BN_MULL_SIZE_NORMAL</B></FONT><B></B>.
<P>

bn_sqr_normal(<B>r</B>, <B>a</B>, <B>n</B>, <B>tmp</B>) operates on the <B>n</B> word array
<B>a</B> and the 2*<B>n</B> word arrays <B>tmp</B> and <B>r</B>.
<P>

The implementations use the following macros which, depending on the
architecture, may use ``long long'' C operations or inline assembler.
They are defined in <TT>&quot;bn_lcl.h&quot;</TT>.
<P>

mul(<B>r</B>, <B>a</B>, <B>w</B>, <B>c</B>) computes <B>w</B>*<B>a</B>+<B>c</B> and places the
low word of the result in <B>r</B> and the high word in <B>c</B>.
<P>

mul_add(<B>r</B>, <B>a</B>, <B>w</B>, <B>c</B>) computes <B>w</B>*<B>a</B>+<B>r</B>+<B>c</B> and
places the low word of the result in <B>r</B> and the high word in <B>c</B>.
<P>

sqr(<B>r0</B>, <B>r1</B>, <B>a</B>) computes <B>a</B>*<B>a</B> and places the low word
of the result in <B>r0</B> and the high word in <B>r1</B>.
<A NAME="lbAG">&nbsp;</A>
<H3>Size changes</H3>

<A NAME="ixAAG"></A>
<I>bn_expand()</I> ensures that <B>b</B> has enough space for a <B>bits</B> bit
number.  <I>bn_wexpand()</I> ensures that <B>b</B> has enough space for an
<B>n</B> word number.  If the number has to be expanded, both macros
call <I>bn_expand2()</I>, which allocates a new <B>d</B> array and copies the
data.  They return <B></B><FONT SIZE="-1"><B>NULL</B></FONT><B></B> on error, <B>b</B> otherwise.
<P>

The <I>bn_fix_top()</I> macro reduces <B>a-&gt;top</B> to point to the most
significant non-zero word plus one when <B>a</B> has shrunk.
<A NAME="lbAH">&nbsp;</A>
<H3>Debugging</H3>

<A NAME="ixAAH"></A>
<I>bn_check_top()</I> verifies that <TT>&quot;((a)-&gt;top &gt;= 0 &amp;&amp; (a)-&gt;top
&lt;= (a)-&gt;dmax)&quot;</TT>.  A violation will cause the program to abort.
<P>

<I>bn_print()</I> prints <B>a</B> to stderr. <I>bn_dump()</I> prints <B>n</B> words at <B>d</B>
(in reverse order, i.e. most significant word first) to stderr.
<P>

<I>bn_set_max()</I> makes <B>a</B> a static number with a <B>dmax</B> of its current size.
This is used by <I>bn_set_low()</I> and <I>bn_set_high()</I> to make <B>r</B> a read-only
<B></B><FONT SIZE="-1"><B>BIGNUM</B></FONT><B></B> that contains the <B>n</B> low or high words of <B>a</B>.
<P>

If <B></B><FONT SIZE="-1"><B>BN_DEBUG</B></FONT><B></B> is not defined, <I>bn_check_top()</I>, <I>bn_print()</I>, <I>bn_dump()</I>
and <I>bn_set_max()</I> are defined as empty macros.
<A NAME="lbAI">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAI"></A>
<I><A HREF="/manpages/index.html?3+bn">bn</A></I>(3)
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE">The <FONT SIZE="-1">BIGNUM</FONT> structure</A><DD>
<DT><A HREF="#lbAF">Low-level arithmetic operations</A><DD>
<DT><A HREF="#lbAG">Size changes</A><DD>
<DT><A HREF="#lbAH">Debugging</A><DD>
</DL>
<DT><A HREF="#lbAI">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:14 GMT, December 24, 2015
</div></div>
</body>
</HTML>
