<!DOCTYPE html>

<HTML><head><TITLE>Manpage of ExtUtils::Constant::Base</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"documentation"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>ExtUtils::Constant::Base</H1>
Section: Perl Programmers Reference Guide (3pm)<BR>Updated: 2009-02-12<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

ExtUtils::Constant::Base - base class for ExtUtils::Constant objects
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
    require ExtUtils::Constant::Base;
    @ISA = 'ExtUtils::Constant::Base';

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
ExtUtils::Constant::Base provides a base implementation of methods to
generate C code to give fast constant value lookup by named string. Currently
it's mostly used ExtUtils::Constant::XS, which generates the lookup code
for the <I>constant()</I> subroutine found in many <FONT SIZE="-1">XS</FONT> modules.
<A NAME="lbAE">&nbsp;</A>
<H2>USAGE</H2>

<A NAME="ixAAE"></A>
ExtUtils::Constant::Base exports no subroutines. The following methods are
available
<DL COMPACT>
<DT>header<DD>
<A NAME="ixAAF"></A>
A method returning a scalar containing definitions needed, typically for a
C header file.
<DT>memEQ_clause args_hashref<DD>
<A NAME="ixAAG"></A>
A method to return a suitable C <TT>&quot;if&quot;</TT> statement to check whether <I>name</I>
is equal to the C variable <TT>&quot;name&quot;</TT>. If <I>checked_at</I> is defined, then it
is used to avoid <TT>&quot;memEQ&quot;</TT> for short names, or to generate a comment to
highlight the position of the character in the <TT>&quot;switch&quot;</TT> statement.


<P>


If i&lt;checked_at&gt; is a reference to a scalar, then instead it gives
the characters pre-checked at the beginning, (and the number of chars by
which the C variable name has been advanced. These need to be chopped from
the front of <I>name</I>).
<DT>dump_names arg_hashref, <FONT SIZE="-1">ITEM</FONT>...<DD>
<A NAME="ixAAH"></A>
An internal function to generate the embedded perl code that will regenerate
the constant subroutines.  <I>default_type</I>, <I>types</I> and <I></I><FONT SIZE="-1"><I>ITEM</I></FONT><I></I>s are the
same as for C_constant.  <I>indent</I> is treated as number of spaces to indent
by.  If <TT>&quot;declare_types&quot;</TT> is true a <TT>$types</TT> is always declared in the perl
code generated, if defined and false never declared, and if undefined <TT>$types</TT>
is only declared if the values in <I>types</I> as passed in cannot be inferred from
<I>default_types</I> and the <I></I><FONT SIZE="-1"><I>ITEM</I></FONT><I></I>s.
<DT>assign arg_hashref, <FONT SIZE="-1">VALUE</FONT>...<DD>
<A NAME="ixAAI"></A>
A method to return a suitable assignment clause. If <I>type</I> is aggregate
(eg <I></I><FONT SIZE="-1"><I>PVN</I></FONT><I></I> expects both pointer and length) then there should be multiple
<I></I><FONT SIZE="-1"><I>VALUE</I></FONT><I></I>s for the components. <I>pre</I> and <I>post</I> if defined give snippets
of C code to proceed and follow the assignment. <I>pre</I> will be at the start
of a block, so variables may be defined in it.
<DT>return_clause arg_hashref, <FONT SIZE="-1">ITEM</FONT><DD>
<A NAME="ixAAJ"></A>
A method to return a suitable <TT>&quot;#ifdef&quot;</TT> clause. <I></I><FONT SIZE="-1"><I>ITEM</I></FONT><I></I> is a hashref
(as passed to <TT>&quot;C_constant&quot;</TT> and <TT>&quot;match_clause&quot;</TT>. <I>indent</I> is the number
of spaces to indent, defaulting to 6.
<DT>switch_clause arg_hashref, <FONT SIZE="-1">NAMELEN</FONT>, <FONT SIZE="-1">ITEMHASH</FONT>, <FONT SIZE="-1">ITEM</FONT>...<DD>
<A NAME="ixAAK"></A>
An internal method to generate a suitable <TT>&quot;switch&quot;</TT> clause, called by
<TT>&quot;C_constant&quot;</TT> <I></I><FONT SIZE="-1"><I>ITEM</I></FONT><I></I>s are in the hash ref format as given in the description
of <TT>&quot;C_constant&quot;</TT>, and must all have the names of the same length, given by
<I></I><FONT SIZE="-1"><I>NAMELEN</I></FONT><I></I>.  <I></I><FONT SIZE="-1"><I>ITEMHASH</I></FONT><I></I> is a reference to a hash, keyed by name, values being
the hashrefs in the <I></I><FONT SIZE="-1"><I>ITEM</I></FONT><I></I> list.  (No parameters are modified, and there can
be keys in the <I></I><FONT SIZE="-1"><I>ITEMHASH</I></FONT><I></I> that are not in the list of <I></I><FONT SIZE="-1"><I>ITEM</I></FONT><I></I>s without
causing problems - the hash is passed in to save generating it afresh for
each call).
<DT>params <FONT SIZE="-1">WHAT</FONT><DD>
<A NAME="ixAAL"></A>
An ``internal'' method, subject to change, currently called to allow an
overriding class to cache information that will then be passed into all
the <TT>&quot;*param*&quot;</TT> calls. (Yes, having to read the source to make sense of this is
considered a known bug). <I></I><FONT SIZE="-1"><I>WHAT</I></FONT><I></I> is be a hashref of types the constant
function will return. In ExtUtils::Constant::XS this method is used to
returns a hashref keyed <FONT SIZE="-1">IV</FONT> <FONT SIZE="-1">NV</FONT> <FONT SIZE="-1">PV</FONT> <FONT SIZE="-1">SV</FONT> to show which combination of pointers will
be needed in the C argument list generated by
C_constant_other_params_definition and C_constant_other_params
<DT>dogfood arg_hashref, <FONT SIZE="-1">ITEM</FONT>...<DD>
<A NAME="ixAAM"></A>
An internal function to generate the embedded perl code that will regenerate
the constant subroutines.  Parameters are the same as for C_constant.


<P>


Currently the base class does nothing and returns an empty string.
<DT>normalise_items args, default_type, seen_types, seen_items, <FONT SIZE="-1">ITEM</FONT>...<DD>
<A NAME="ixAAN"></A>
Convert the items to a normalised form. For 8 bit and Unicode values converts
the item to an array of 1 or 2 items, both 8 bit and <FONT SIZE="-1">UTF-8</FONT> encoded.
<DT>C_constant arg_hashref, <FONT SIZE="-1">ITEM</FONT>...<DD>
<A NAME="ixAAO"></A>
A function that returns a <B>list</B> of C subroutine definitions that return
the value and type of constants when passed the name by the <FONT SIZE="-1">XS</FONT> wrapper.
<I></I><FONT SIZE="-1"><I>ITEM</I></FONT><I>...</I> gives a list of constant names. Each can either be a string,
which is taken as a C macro name, or a reference to a hash with the following
keys
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>name<DD>
<A NAME="ixAAP"></A>
The name of the constant, as seen by the perl code.
<DT>type<DD>
<A NAME="ixAAQ"></A>
The type of the constant (<I></I><FONT SIZE="-1"><I>IV</I></FONT><I></I>, <I></I><FONT SIZE="-1"><I>NV</I></FONT><I></I> etc)
<DT>value<DD>
<A NAME="ixAAR"></A>
A C expression for the value of the constant, or a list of C expressions if
the type is aggregate. This defaults to the <I>name</I> if not given.
<DT>macro<DD>
<A NAME="ixAAS"></A>
The C pre-processor macro to use in the <TT>&quot;#ifdef&quot;</TT>. This defaults to the
<I>name</I>, and is mainly used if <I>value</I> is an <TT>&quot;enum&quot;</TT>. If a reference an
array is passed then the first element is used in place of the <TT>&quot;#ifdef&quot;</TT>
line, and the second element in place of the <TT>&quot;#endif&quot;</TT>. This allows
pre-processor constructions such as


<P>




<PRE>
    #if defined (foo)
    #if !defined (bar)
    ...
    #endif
    #endif

</PRE>




<P>


to be used to determine if a constant is to be defined.


<P>


A ``macro'' 1 signals that the constant is always defined, so the <TT>&quot;#if&quot;</TT>/<TT>&quot;#endif&quot;</TT>
test is omitted.
<DT>default<DD>
<A NAME="ixAAT"></A>
Default value to use (instead of <TT>&quot;croak&quot;</TT>ing with ``your vendor has not
defined...'') to return if the macro isn't defined. Specify a reference to
an array with type followed by value(s).
<DT>pre<DD>
<A NAME="ixAAU"></A>
C code to use before the assignment of the value of the constant. This allows
you to use temporary variables to extract a value from part of a <TT>&quot;struct&quot;</TT>
and return this as <I>value</I>. This C code is places at the start of a block,
so you can declare variables in it.
<DT>post<DD>
<A NAME="ixAAV"></A>
C code to place between the assignment of value (to a temporary) and the
return from the function. This allows you to clear up anything in <I>pre</I>.
Rarely needed.
<DT>def_pre<DD>
<A NAME="ixAAW"></A>

<DT>def_post<DD>
<A NAME="ixAAX"></A>

Equivalents of <I>pre</I> and <I>post</I> for the default value.
<DT>utf8<DD>
<A NAME="ixAAY"></A>
Generated internally. Is zero or undefined if name is 7 bit <FONT SIZE="-1">ASCII</FONT>,
``no'' if the name is 8 bit (and so should only match if <I>SvUTF8()</I> is false),
``yes'' if the name is utf8 encoded.


<P>


The internals automatically clone any name with characters 128-255 but none
256+ (ie one that could be either in bytes or utf8) into a second entry
which is utf8 encoded.
<DT>weight<DD>
<A NAME="ixAAZ"></A>
Optional sorting weight for names, to determine the order of
linear testing when multiple names fall in the same case of a switch clause.
Higher comes earlier, undefined defaults to zero.
</DL>
</DL>

<DL COMPACT><DT><DD>


<P>


In the argument hashref, <I>package</I> is the name of the package, and is only
used in comments inside the generated C code. <I>subname</I> defaults to
<TT>&quot;constant&quot;</TT> if undefined.


<P>


<I>default_type</I> is the type returned by <TT>&quot;ITEM&quot;</TT>s that don't specify their
type. It defaults to the value of <TT>&quot;default_type()&quot;</TT>. <I>types</I> should be given
either as a comma separated list of types that the C subroutine <I>subname</I>
will generate or as a reference to a hash. <I>default_type</I> will be added to
the list if not present, as will any types given in the list of <I></I><FONT SIZE="-1"><I>ITEM</I></FONT><I></I>s. The
resultant list should be the same list of types that <TT>&quot;XS_constant&quot;</TT> is
given. [Otherwise <TT>&quot;XS_constant&quot;</TT> and <TT>&quot;C_constant&quot;</TT> may differ in the number of
parameters to the constant function. <I>indent</I> is currently unused and
ignored. In future it may be used to pass in information used to change the C
indentation style used.]  The best way to maintain consistency is to pass in a
hash reference and let this function update it.


<P>


<I>breakout</I> governs when child functions of <I>subname</I> are generated.  If there
are <I>breakout</I> or more <I></I><FONT SIZE="-1"><I>ITEM</I></FONT><I></I>s with the same length of name, then the code
to switch between them is placed into a function named <I>subname</I>_<I>len</I>, for
example <TT>&quot;constant_5&quot;</TT> for names 5 characters long.  The default <I>breakout</I> is
3.  A single <TT>&quot;ITEM&quot;</TT> is always inlined.
</DL>

</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>BUGS</H2>

<A NAME="ixABA"></A>
Not everything is documented yet.
<P>

Probably others.
<A NAME="lbAG">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixABB"></A>
Nicholas Clark &lt;<A HREF="mailto:nick@ccl4.org">nick@ccl4.org</A>&gt; based on the code in <TT>&quot;h2xs&quot;</TT> by Larry Wall and
others
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">USAGE</A><DD>
<DT><A HREF="#lbAF">BUGS</A><DD>
<DT><A HREF="#lbAG">AUTHOR</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:26 GMT, December 24, 2015
</div></div>
</body>
</HTML>
