<!DOCTYPE html>

<HTML><head><TITLE>Manpage of XML::Grove</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"documentation"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>XML::Grove</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 1999-09-09<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

XML::Grove - Perl-style XML objects
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
 use XML::Grove;

 # Basic parsing and grove building
 use XML::Grove::Builder;
 use XML::Parser::PerlSAX;
 $grove_builder = XML::Grove::Builder-&gt;new;
 $parser = XML::Parser::PerlSAX-&gt;new ( Handler =&gt; $grove_builder );
 $document = $parser-&gt;parse ( Source =&gt; { SystemId =&gt; 'filename' } );

 # Creating new objects
 $document = XML::Grove::Document-&gt;new ( Contents =&gt; [ ] );
 $element = XML::Grove::Element-&gt;new ( Name =&gt; 'tag',
                                       Attributes =&gt; { },
                                       Contents =&gt; [ ] );

 # Accessing XML objects
 $tag_name = $element-&gt;{Name};
 $contents = $element-&gt;{Contents};
 $parent = $element-&gt;{Parent};
 $characters-&gt;{Data} = 'XML is fun!';

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
XML::Grove is a tree-based object model for accessing the information
set of parsed or stored <FONT SIZE="-1">XML</FONT>, <FONT SIZE="-1">HTML</FONT>, or <FONT SIZE="-1">SGML</FONT> instances.  XML::Grove
objects are Perl hashes and arrays where you access the properties of
the objects using normal Perl syntax:
<P>



<PRE>
  $text = $characters-&gt;{Data};

</PRE>


<A NAME="lbAE">&nbsp;</A>
<H3>How To Create a Grove</H3>

<A NAME="ixAAE"></A>
There are several ways for groves to come into being, they can be read
from a file or string using a parser and a grove builder, they can be
created by your Perl code using the `<TT>&quot;new()&quot;</TT>' methods of
XML::Grove::Objects, or databases or other sources can act as groves.
<P>

The most common way to build groves is using a parser and a grove
builder.  The parser is the package that reads the characters of an
<FONT SIZE="-1">XML</FONT> file, recognizes the <FONT SIZE="-1">XML</FONT> syntax, and produces ``events'' reporting
when elements (tags), text (characters), processing instructions, and
other sequences occur.  A grove builder receives (``consumes'' or
``handles'') these events and builds XML::Grove objects.  The last
thing the parser does is return the XML::Grove::Document object that
the grove builder created, with all of it's elements and character
data.
<P>

The most common parser and grove builder are XML::Parser::PerlSAX (in
libxml-perl) and XML::Grove::Builder.  To build a grove, create the
grove builder first:
<P>



<PRE>
  $grove_builder = XML::Grove::Builder-&gt;new;

</PRE>


<P>

Then create the parser, passing it the grove builder as it's handler:
<P>



<PRE>
  $parser = XML::Parser::PerlSAX-&gt;new ( Handler =&gt; $grove_builder );

</PRE>


<P>

This associates the grove builder with the parser so that every time
you parse a document with this parser it will return an
XML::Grove::Document object.  To parse a file, use the `<TT>&quot;Source&quot;</TT>'
parameter to the `<TT>&quot;parse()&quot;</TT>' method containing a `<TT>&quot;SystemId&quot;</TT>'
parameter (<FONT SIZE="-1">URL</FONT> or path) of the file you want to parse:
<P>



<PRE>
  $document = $parser-&gt;parse ( Source =&gt; { SystemId =&gt; 'kjv.xml' } );

</PRE>


<P>

To parse a string held in a Perl variable, use the `<TT>&quot;Source&quot;</TT>'
parameter containing a `<TT>&quot;String&quot;</TT>' parameter:
<P>



<PRE>
  $document = $parser-&gt;parse ( Source =&gt; { String =&gt; $xml_text } );

</PRE>


<P>

The following are all parsers that work with XML::Grove::Builder:
<P>



<PRE>
  XML::Parser::PerlSAX (in libxml-perl, uses XML::Parser)
  XML::ESISParser      (in libxml-perl, uses James Clark's `nsgmls')
  XML::SAX2Perl        (in libxml-perl, translates SAX 1.0 to PerlSAX)

</PRE>


<P>

Most parsers supply more properties than the standard information set
below and XML::Grove will make available all the properties given by
the parser, refer to the parser documentation to find out what
additional properties it may provide.
<P>

Although there are not any available yet (August 1999), PerlSAX filters
can be used to process the output of a parser before it is passed to
XML::Grove::Builder.  XML::Grove::PerlSAX can be used to provide input
to PerlSAX filters or other PerlSAX handlers.
<A NAME="lbAF">&nbsp;</A>
<H3>Using Groves</H3>

<A NAME="ixAAF"></A>
The properties provided by parsers are available directly using Perl's
normal syntax for accessing hashes and arrays.  For example, to get
the name of an element:
<P>



<PRE>
  $element_name = $element-&gt;{Name};

</PRE>


<P>

By convention, all properties provided by parsers are in mixed case.
`<TT>&quot;Parent&quot;</TT>' properties are available using the
`<TT>&quot;Data::Grove::Parent&quot;</TT>' module.
<P>

The following is the minimal set of objects and their properties that
you are likely to get from all parsers:
<A NAME="lbAG">&nbsp;</A>
<H3>XML::Grove::Document</H3>

<A NAME="ixAAG"></A>
The Document object is parent of the root element of the parsed <FONT SIZE="-1">XML</FONT>
document.
<DL COMPACT>
<DT>Contents<DD>
<A NAME="ixAAH"></A>
An array containing the root element.
</DL>
<P>

A document's `Contents' may also contain processing instructions,
comments, and whitespace.
<P>

Some parsers provide information about the document type, the <FONT SIZE="-1">XML</FONT>
declaration, or notations and entities.  Check the parser
documentation for property names.
<A NAME="lbAH">&nbsp;</A>
<H3>XML::Grove::Element</H3>

<A NAME="ixAAI"></A>
The Element object represents elements from the <FONT SIZE="-1">XML</FONT> source.
<DL COMPACT>
<DT>Parent<DD>
<A NAME="ixAAJ"></A>
The parent object of this element.
<DT>Name<DD>
<A NAME="ixAAK"></A>
A string, the element type name of this element
<DT>Attributes<DD>
<A NAME="ixAAL"></A>
A hash of strings or arrays
<DT>Contents<DD>
<A NAME="ixAAM"></A>
An array of elements, characters, processing instructions, etc.
</DL>
<P>

In a purely minimal grove, the attributes of an element will be plain
text (Perl scalars).  Some parsers provide access to notations and
entities in attributes, in which case the attribute may contain an
array.
<A NAME="lbAI">&nbsp;</A>
<H3>XML::Grove::Characters</H3>

<A NAME="ixAAN"></A>
The Characters object represents text from the <FONT SIZE="-1">XML</FONT> source.
<DL COMPACT>
<DT>Parent<DD>
<A NAME="ixAAO"></A>
The parent object of this characters object
<DT>Data<DD>
<A NAME="ixAAP"></A>
A string, the characters
</DL>
<A NAME="lbAJ">&nbsp;</A>
<H3>XML::Grove::PI</H3>

<A NAME="ixAAQ"></A>
The <FONT SIZE="-1">PI</FONT> object represents processing instructions from the <FONT SIZE="-1">XML</FONT> source.
<DL COMPACT>
<DT>Parent<DD>
<A NAME="ixAAR"></A>
The parent object of this <FONT SIZE="-1">PI</FONT> object.
<DT>Target<DD>
<A NAME="ixAAS"></A>
A string, the processing instruction target.
<DT>Data<DD>
<A NAME="ixAAT"></A>
A string, the processing instruction data, or undef if none was supplied.
</DL>
<P>

In addition to the minimal set of objects above, XML::Grove knows
about and parsers may provide the following objects.  Refer to the
parser documentation for descriptions of the properties of these
objects.
<P>



<PRE>
  XML::Grove::
  ::Entity::External  External entity reference
  ::Entity::SubDoc    External SubDoc reference (SGML)
  ::Entity::SGML      External SGML reference (SGML)
  ::Entity            Entity reference
  ::Notation          Notation declaration
  ::Comment           &lt;!-- A Comment --&gt;
  ::SubDoc            A parsed subdocument (SGML)
  ::CData             A CDATA marked section
  ::ElementDecl       An element declaration from the DTD
  ::AttListDecl       An element's attribute declaration, from the DTD

</PRE>


<A NAME="lbAK">&nbsp;</A>
<H2>METHODS</H2>

<A NAME="ixAAU"></A>
XML::Grove by itself only provides one method, <I>new()</I>, for creating new
XML::Grove objects.  There are Data::Grove and XML::Grove extension
modules that give additional methods for working with XML::Grove
objects and new extensions can be created as needed.
<DL COMPACT>
<DT>$obj = XML::Grove::OBJECT-&gt;new( [<FONT SIZE="-1">PROPERTIES</FONT>] )<DD>


<A NAME="ixAAV"></A>
`<TT>&quot;new&quot;</TT>' creates a new XML::Grove object with the type <I></I><FONT SIZE="-1"><I>OBJECT</I></FONT><I></I>, and
with the initial <I></I><FONT SIZE="-1"><I>PROPERTIES</I></FONT><I></I>.  <I></I><FONT SIZE="-1"><I>PROPERTIES</I></FONT><I></I> may be given as either
a list of key-value pairs, a hash, or an XML::Grove object to copy.
<I></I><FONT SIZE="-1"><I>OBJECT</I></FONT><I></I> may be any of the objects listed above.
</DL>
<P>

This is a list of available extensions and the methods they provide
(as of Feb 1999).  Refer to their module documentation for more
information on how to use them.
<P>



<PRE>
  XML::Grove::AsString
    as_string       return portions of groves as a string
    attr_as_string  return an element's attribute as a string

  XML::Grove::AsCanonXML
    as_canon_xml    return XML text in canonical XML format

  XML::Grove::PerlSAX
    parse           emulate a PerlSAX parser using the grove objects

  Data::Grove::Parent
    root            return the root element of a grove
    rootpath        return an array of all objects between the root
                    element and this object, inclusive

    Data::Grove::Parent also adds `C&lt;Parent&gt;' and `C&lt;Raw&gt;' properties
    to grove objects.

  Data::Grove::Visitor
    accept          call back a subroutine using an object type name
    accept_name     call back using an element or tag name
    children_accept for each child in Contents, call back a sub
    children_accept_name  same, but using tag names
    attr_accept     call back for the objects in attributes

  XML::Grove::IDs
    get_ids         return a list of all ID attributes in grove

  XML::Grove::Path
    at_path         $el-&gt;at_path('/html/body/ul/li[4]')

  XML::Grove::Sub
    filter          run a sub against all the objects in the grove

</PRE>


<A NAME="lbAL">&nbsp;</A>
<H2>WRITING EXTENSIONS</H2>

<A NAME="ixAAW"></A>
The class `<TT>&quot;XML::Grove&quot;</TT>' is the superclass of all classes in the
XML::Grove module.  `<TT>&quot;XML::Grove&quot;</TT>' is a subclass of `<TT>&quot;Data::Grove&quot;</TT>'.
<P>

If you create an extension and you want to add a method to <I>all</I>
XML::Grove objects, then create that method in the XML::Grove
package.  Many extensions only need to add methods to
XML::Grove::Document and/or XML::Grove::Element.
<P>

When you create an extension you should definitly provide a way to
invoke your module using objects from your package too.  For example,
XML::Grove::AsString's `<TT>&quot;as_string()&quot;</TT>' method can also be called
using an XML::Grove::AsString object:
<P>



<PRE>
  $writer= new XML::Grove::AsString;
  $string = $writer-&gt;as_string ( $xml_object );

</PRE>


<A NAME="lbAM">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixAAX"></A>
Ken MacLeod, <A HREF="mailto:ken@bitsko.slc.ut.us">ken@bitsko.slc.ut.us</A>
<A NAME="lbAN">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAY"></A>
<I><A HREF="/manpages/index.html?1+perl">perl</A></I>(1), <I><A HREF="http://localhost/cgi-bin/man/man2html?3+XML::Grove">XML::Grove</A></I>(3)
<P>

Extensible Markup Language (<FONT SIZE="-1">XML</FONT>) &lt;<A HREF="http://www.w3c.org/XML">http://www.w3c.org/XML</A>&gt;
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE">How To Create a Grove</A><DD>
<DT><A HREF="#lbAF">Using Groves</A><DD>
<DT><A HREF="#lbAG">XML::Grove::Document</A><DD>
<DT><A HREF="#lbAH">XML::Grove::Element</A><DD>
<DT><A HREF="#lbAI">XML::Grove::Characters</A><DD>
<DT><A HREF="#lbAJ">XML::Grove::PI</A><DD>
</DL>
<DT><A HREF="#lbAK">METHODS</A><DD>
<DT><A HREF="#lbAL">WRITING EXTENSIONS</A><DD>
<DT><A HREF="#lbAM">AUTHOR</A><DD>
<DT><A HREF="#lbAN">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:46 GMT, December 24, 2015
</div></div>
</body>
</HTML>
