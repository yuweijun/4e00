<!DOCTYPE html>

<HTML><head><TITLE>Manpage of docs::api::APR::Bucket</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>docs::api::APR::Bucket</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2007-11-12<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

APR::Bucket - Perl API for manipulating APR Buckets
<A NAME="lbAC">&nbsp;</A>
<H2>Synopsis</H2>

<A NAME="ixAAC"></A>


<PRE>
  use APR::Bucket ();
  my $ba = $c-&gt;bucket_alloc;
  
  $b1 = APR::Bucket-&gt;new($ba, &quot;aaa&quot;);
  $b2 = APR::Bucket::eos_create($ba);
  $b3 = APR::Bucket::flush_create($ba);
  
  $b2-&gt;is_eos;
  $b3-&gt;is_flush;
  
  $len = $b1-&gt;length;
  $len = $b1-&gt;read($data);
  $type = $b1-&gt;type;
  
  $b1-&gt;insert_after($b2);
  $b1-&gt;insert_before($b3);
  $b1-&gt;remove;
  $b1-&gt;destroy;
  
  $b2-&gt;delete; # remove+destroy
  
  $b4 = APR::Bucket-&gt;new($ba, &quot;to be setaside&quot;);
  $b4-&gt;setaside($pool);

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>Description</H2>

<A NAME="ixAAD"></A>
<TT>&quot;APR::Bucket&quot;</TT> allows you to create, manipulate and delete <FONT SIZE="-1">APR</FONT>
buckets.
<P>

You will probably find the various insert methods confusing, the tip
is to read the function right to left. The following code sample helps
to visualize the operations:
<P>



<PRE>
  my $bb = APR::Brigade-&gt;new($r-&gt;pool, $ba);
  my $d1 = APR::Bucket-&gt;new($ba, &quot;d1&quot;);
  my $d2 = APR::Bucket-&gt;new($ba, &quot;d2&quot;);
  my $f1 = APR::Bucket::flush_create($ba);
  my $f2 = APR::Bucket::flush_create($ba);
  my $e1 = APR::Bucket::eos_create($ba);
                           # head-&gt;tail
  $bb-&gt;insert_head(  $d1); # head-&gt;d1-&gt;tail
  $d1-&gt;insert_after( $d2); # head-&gt;d1-&gt;d2-&gt;tail
  $d2-&gt;insert_before($f1); # head-&gt;d1-&gt;f1-&gt;d2-&gt;tail
  $d2-&gt;insert_after( $f2); # head-&gt;d1-&gt;f1-&gt;d2-&gt;f2-&gt;tail
  $bb-&gt;insert_tail(  $e1); # head-&gt;d1-&gt;f1-&gt;d2-&gt;f2-&gt;e1-&gt;tail

</PRE>


<A NAME="lbAE">&nbsp;</A>
<H2>API</H2>

<A NAME="ixAAE"></A>
<TT>&quot;APR::Bucket&quot;</TT> provides the following functions and/or methods:
<A NAME="lbAF">&nbsp;</A>
<H3>delete</H3>



<A NAME="ixAAF"></A>
Tell the bucket to remove itself from the bucket brigade it belongs
to, and destroy itself.
<P>



<PRE>
  $bucket-&gt;delete();

</PRE>


<DL COMPACT>
<DT>obj: $bucket ( APR::Bucket object )<DD>


<A NAME="ixAAG"></A>

<DT>ret: no return value<DD>
<A NAME="ixAAH"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixAAI"></A>

</DL>
<P>

If the bucket is not attached to any bucket brigade then this
operation just destroys the bucket.
<P>

<TT>&quot;delete&quot;</TT> is a convenience wrapper, internally doing:
<P>



<PRE>
  $b-&gt;remove;
  $b-&gt;destroy;

</PRE>


<P>

Examples:
<P>

Assuming that <TT>$bb</TT> already exists and filled with buckets, replace
the existing data buckets with new buckets with upcased data;
<P>



<PRE>
  for (my $b = $bb-&gt;first; $b; $b = $bb-&gt;next($b)) {
     if ($b-&gt;read(my $data)) {
          my $nb = APR::Bucket-&gt;new($bb-&gt;bucket_alloc, uc $data);
          $b-&gt;insert_before($nb);
          $b-&gt;delete;
          $b = $nb;
      }
  }

</PRE>


<A NAME="lbAG">&nbsp;</A>
<H3>destroy</H3>



<A NAME="ixAAJ"></A>
Free the resources used by a bucket. If multiple buckets refer to the
same resource it is freed when the last one goes away.
<P>



<PRE>
  $bucket-&gt;destroy();

</PRE>


<DL COMPACT>
<DT>obj: $bucket ( APR::Bucket object )<DD>


<A NAME="ixAAK"></A>

<DT>ret: no return value<DD>
<A NAME="ixAAL"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixAAM"></A>

</DL>
<P>

A bucket needs to be destroyed if it was removed from a
bucket brigade, to avoid memory leak.
<P>

If a bucket is linked to a bucket brigade, it needs to be
removed from it, before it can be destroyed.
<P>

Usually instead of calling:
<P>



<PRE>
  $b-&gt;remove;
  $b-&gt;destroy;

</PRE>


<P>

it's better to call <TT>&quot;delete&quot;</TT> which does exactly that.
<A NAME="lbAH">&nbsp;</A>
<H3>eos_create</H3>



<A NAME="ixAAN"></A>
Create an <I>EndOfStream</I> bucket.
<P>



<PRE>
  $b = APR::Bucket::eos_create($ba);

</PRE>


<DL COMPACT>
<DT>arg1: $ba ( APR::BucketAlloc object )<DD>


<A NAME="ixAAO"></A>
The freelist from which this bucket should be allocated
<DT>ret: $b ( APR::Bucket object )<DD>


<A NAME="ixAAP"></A>
The new bucket
<DT>since: 2.0.00<DD>
<A NAME="ixAAQ"></A>
</DL>
<P>

This bucket type indicates that there is no more data coming from down
the filter stack.  All filters should flush any buffered data at this
point.
<P>

Example:
<P>



<PRE>
  use APR::Bucket ();
  use Apache2::Connection ();
  my $ba = $c-&gt;bucket_alloc;
  my $eos_b = APR::Bucket::eos_create($ba);

</PRE>


<A NAME="lbAI">&nbsp;</A>
<H3>flush_create</H3>



<A NAME="ixAAR"></A>
Create a flush bucket.
<P>



<PRE>
  $b = APR::Bucket::flush_create($ba);

</PRE>


<DL COMPACT>
<DT>arg1: $ba ( APR::BucketAlloc object )<DD>


<A NAME="ixAAS"></A>
The freelist from which this bucket should be allocated
<DT>ret: $b ( APR::Bucket object )<DD>


<A NAME="ixAAT"></A>
The new bucket
<DT>since: 2.0.00<DD>
<A NAME="ixAAU"></A>
</DL>
<P>

This bucket type indicates that filters should flush their data.
There is no guarantee that they will flush it, but this is the best we
can do.
<A NAME="lbAJ">&nbsp;</A>
<H3>insert_after</H3>



<A NAME="ixAAV"></A>
Insert a list of buckets after a specified bucket
<P>



<PRE>
  $after_bucket-&gt;insert_after($add_bucket);

</PRE>


<DL COMPACT>
<DT>obj: $after_bucket ( APR::Bucket object )<DD>


<A NAME="ixAAW"></A>
The bucket to insert after
<DT>arg1: $add_bucket ( APR::Bucket object )<DD>


<A NAME="ixAAX"></A>
The buckets to insert. It says buckets, since <TT>$add_bucket</TT> may have
more buckets attached after itself.
<DT>ret: no return value<DD>
<A NAME="ixAAY"></A>

<DT>since: 2.0.00<DD>
<A NAME="ixAAZ"></A>

</DL>
<A NAME="lbAK">&nbsp;</A>
<H3>insert_before</H3>



<A NAME="ixABA"></A>
Insert a list of buckets before a specified bucket
<P>



<PRE>
  $before_bucket-&gt;insert_before($add_bucket);

</PRE>


<DL COMPACT>
<DT>obj: $before_bucket ( APR::Bucket object )<DD>


<A NAME="ixABB"></A>
The bucket to insert before
<DT>arg1: $add_bucket ( APR::Bucket object )<DD>


<A NAME="ixABC"></A>
The buckets to insert. It says buckets, since <TT>$add_bucket</TT> may have
more buckets attached after itself.
<DT>ret: no return value<DD>
<A NAME="ixABD"></A>

<DT>since: 2.0.00<DD>
<A NAME="ixABE"></A>

</DL>
<A NAME="lbAL">&nbsp;</A>
<H3>is_eos</H3>



<A NAME="ixABF"></A>
Determine if a bucket is an <FONT SIZE="-1">EOS</FONT> bucket
<P>



<PRE>
  $ret = $bucket-&gt;is_eos();

</PRE>


<DL COMPACT>
<DT>obj: $bucket ( APR::Bucket object )<DD>


<A NAME="ixABG"></A>

<DT>ret: $ret ( boolean )<DD>


<A NAME="ixABH"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixABI"></A>

</DL>
<A NAME="lbAM">&nbsp;</A>
<H3>is_flush</H3>



<A NAME="ixABJ"></A>
Determine if a bucket is a <FONT SIZE="-1">FLUSH</FONT> bucket
<P>



<PRE>
  $ret = $bucket-&gt;is_flush();

</PRE>


<DL COMPACT>
<DT>obj: $bucket ( APR::Bucket object )<DD>


<A NAME="ixABK"></A>

<DT>ret: $ret ( boolean )<DD>


<A NAME="ixABL"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixABM"></A>

</DL>
<A NAME="lbAN">&nbsp;</A>
<H3>length</H3>



<A NAME="ixABN"></A>
Get the length of the data in the bucket.
<P>



<PRE>
  $len = $b-&gt;length;

</PRE>


<DL COMPACT>
<DT>obj: $b ( APR::Bucket object )<DD>


<A NAME="ixABO"></A>

<DT>ret: $len ( integer )<DD>


<A NAME="ixABP"></A>

If the length is unknown, <TT>$len</TT> value will be -1.
<DT>since: 2.0.00<DD>
<A NAME="ixABQ"></A>
</DL>
<A NAME="lbAO">&nbsp;</A>
<H3>new</H3>



<A NAME="ixABR"></A>
Create a new bucket and initialize it with data:
<P>



<PRE>
  $nb = APR::Bucket-&gt;new($ba, $data);
  $nb =          $b-&gt;new($ba, $data);
  $nb = APR::Bucket-&gt;new($ba, $data, $offset);
  $nb = APR::Bucket-&gt;new($ba, $data, $offset, $len);

</PRE>


<DL COMPACT>
<DT>obj: $b ( APR::Bucket object or class )<DD>


<A NAME="ixABS"></A>

<DT>arg1: $ba ( APR::BucketAlloc object )<DD>


<A NAME="ixABT"></A>
<DT>arg2: $data ( string )<DD>


<A NAME="ixABU"></A>

The data to initialize with.


<P>


<B>Important:</B> in order to avoid unnecessary data copying the variable
is stored in the bucket object. That means that if you modify <TT>$data</TT>
after passing it to <TT>&quot;new()&quot;</TT> you will modify the data in the bucket as
well. To avoid that pass to <TT>&quot;new()&quot;</TT> a copy which you won't modify.
<DT>opt arg3: $offset ( number )<DD>


<A NAME="ixABV"></A>
Optional offset inside <TT>$data</TT>. Default: 0.
<DT>opt arg4: $len ( number )<DD>


<A NAME="ixABW"></A>
Optional partial length to read.


<P>


If <TT>$offset</TT> is specified, then:


<P>




<PRE>
  length $buffer - $offset;

</PRE>




<P>


will be used. Otherwise the default is to use:


<P>




<PRE>
  length $buffer;

</PRE>


<DT>ret: $nb ( APR::Bucket object )<DD>


<A NAME="ixABX"></A>
a newly created bucket object
<DT>since: 2.0.00<DD>
<A NAME="ixABY"></A>
</DL>
<P>

Examples:
<DL COMPACT>
<DT>*<DD>
Create a new bucket using a whole string:


<P>




<PRE>
  use APR::Bucket ();
  my $data = &quot;my data&quot;;
  my $b = APR::Bucket-&gt;new($ba, $data);

</PRE>




<P>


now the bucket contains the string <I>'my data'</I>.
<DT>*<DD>
Create a new bucket using a sub-string:


<P>




<PRE>
  use APR::Bucket ();
  my $data   = &quot;my data&quot;;
  my $offset = 3;
  my $b = APR::Bucket-&gt;new($ba, $data, $offset);

</PRE>




<P>


now the bucket contains the string <I>'data'</I>.
<DT>*<DD>
Create a new bucket not using the whole length and starting from an
offset:


<P>




<PRE>
  use APR::Bucket ();
  my $data   = &quot;my data&quot;;
  my $offset = 3;
  my $len    = 3;
  my $b = APR::Bucket-&gt;new($ba, $data, $offset, $len);

</PRE>




<P>


now the bucket contains the string <I>'dat'</I>.
</DL>
<A NAME="lbAP">&nbsp;</A>
<H3>read</H3>



<A NAME="ixABZ"></A>
Read the data from the bucket.
<P>



<PRE>
  $len = $b-&gt;read($buffer);
  $len = $b-&gt;read($buffer, $block);

</PRE>


<DL COMPACT>
<DT>obj: $b ( APR::Bucket object )<DD>


<A NAME="ixACA"></A>
The bucket to read from
<DT>arg1: $buffer ( <FONT SIZE="-1">SCALAR</FONT> )<DD>


<A NAME="ixACB"></A>
The buffer to fill. All previous data will be lost.
<DT>opt arg2: $block ( APR::Const :read_type constant )<DD>


<A NAME="ixACC"></A>
optional reading mode constant.


<P>


By default the read is blocking, via <TT>&quot;APR::Const::BLOCK_READ
constant&quot;</TT>.
<DT>ret: $len ( number )<DD>


<A NAME="ixACD"></A>
How many bytes were actually read


<P>


<TT>$buffer</TT> gets populated with the string that is read. It will
contain an empty string if there was nothing to read.
<DT>since: 2.0.00<DD>
<A NAME="ixACE"></A>

<DT>excpt: APR::Error<DD>


<A NAME="ixACF"></A>

</DL>
<P>

It's important to know that certain bucket types (e.g. file bucket),
may perform a split and insert extra buckets following the current
one. Therefore never call <TT>&quot;$b-&gt;remove&quot;</TT>, before
calling <TT>&quot;$b-&gt;read&quot;</TT>, or you may lose data.
<P>

Examples:
<P>

Blocking read:
<P>



<PRE>
  my $len = $b-&gt;read(my $buffer);

</PRE>


<P>

Non-blocking read:
<P>



<PRE>
  use APR::Const -compile 'NONBLOCK_READ';
  my $len = $b-&gt;read(my $buffer, APR::Const::NONBLOCK_READ);

</PRE>


<A NAME="lbAQ">&nbsp;</A>
<H3>remove</H3>



<A NAME="ixACG"></A>
Tell the bucket to remove itself from the bucket brigade it belongs
to.
<P>



<PRE>
  $bucket-&gt;remove();

</PRE>


<DL COMPACT>
<DT>obj: $bucket ( APR::Bucket object )<DD>


<A NAME="ixACH"></A>

<DT>ret: no return value<DD>
<A NAME="ixACI"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixACJ"></A>

</DL>
<P>

If the bucket is not attached to any bucket brigade then this
operation doesn't do anything.
<P>

When the bucket is removed, it's not not destroyed. Usually this is
done in order to move the bucket to another bucket brigade. Or to copy
the data way before destroying the bucket.  If the bucket wasn't moved
to another bucket brigade it must be destroyed.
<P>

Examples:
<P>

Assuming that <TT>$bb1</TT> already exists and filled with buckets, move
every odd bucket number to <TT>$bb2</TT> and every even to <TT>$bb3</TT>:
<P>



<PRE>
  my $bb2 = APR::Brigade-&gt;new($c-&gt;pool, $c-&gt;bucket_alloc);
  my $bb3 = APR::Brigade-&gt;new($c-&gt;pool, $c-&gt;bucket_alloc);
  my $count = 0;
  while (my $bucket = $bb-&gt;first) {
      $count++;
      $bucket-&gt;remove;
      $count % 2
          ? $bb2-&gt;insert_tail($bucket)
          : $bb3-&gt;insert_tail($bucket);
  }

</PRE>


<A NAME="lbAR">&nbsp;</A>
<H3>setaside</H3>



<A NAME="ixACK"></A>
Ensure the bucket's data lasts at least as long as the given pool:
<P>



<PRE>
  my $status = $b-&gt;setaside($pool);

</PRE>


<DL COMPACT>
<DT>obj: $b ( APR::Bucket object )<DD>


<A NAME="ixACL"></A>

<DT>arg1: $pool ( APR::Pool object )<DD>


<A NAME="ixACM"></A>
<DT>ret: ( APR::Const status constant )<DD>


<A NAME="ixACN"></A>

On success,
<TT>&quot;APR::Const::SUCCESS&quot;</TT> is
returned. Otherwise a failure code is returned.
<DT>excpt: APR::Error<DD>


<A NAME="ixACO"></A>
when your code deals only with mod_perl buckets, you don't have to ask
for the return value. If this method is called in the <TT>&quot;VOID&quot;</TT> context,
i.e.:


<P>




<PRE>
  $b-&gt;setaside($pool);

</PRE>




<P>


mod_perl will do the error checking on your behalf, and if the return
code is not
<TT>&quot;APR::Const::SUCCESS&quot;</TT>, an
<TT>&quot;APR::Error exception&quot;</TT> will be thrown.


<P>


However if your code doesn't know which bucket types it may need to
setaside, you may want to check the return code and deal with any
errors. For example one of the possible error codes is
<TT>&quot;APR::Const::ENOTIMPL&quot;</TT>. As of
this writing the pipe and socket buckets can't <TT>&quot;setaside()&quot;</TT>, in which
case you may want to look at the <TT>&quot;ap_save_brigade()&quot;</TT> implementation.
<DT>since: 2.0.00<DD>
<A NAME="ixACP"></A>
</DL>
<P>

Usually setaside is called by certain output filters, in order to
buffer socket writes of smaller buckets into a single write. This
method works on all bucket types (not only the mod_perl bucket type),
but as explained in the exceptions section, not all bucket types
implement this method.
<P>

When a mod_perl bucket is setaside, its data is detached from the
original perl scalar and copied into a pool bucket. That allows
downstream filters to deal with the data originally owned by a Perl
interpreter, making it possible for that interpreter to go away and do
other things, or be destroyed.
<A NAME="lbAS">&nbsp;</A>
<H3>type</H3>



<A NAME="ixACQ"></A>
Get the type of the data in the bucket.
<P>



<PRE>
  $type = $b-&gt;type;

</PRE>


<DL COMPACT>
<DT>obj: $b ( APR::Bucket object )<DD>


<A NAME="ixACR"></A>

<DT>ret: $type ( APR::BucketType object )<DD>


<A NAME="ixACS"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixACT"></A>

</DL>
<P>

You need to invoke
<TT>&quot;APR::BucketType&quot;</TT> methods to
access the data.
<P>

Example:
<P>

Create a flush bucket and read its type's name:
<P>



<PRE>
  use APR::Bucket ();
  use APR::BucketType ();
  my $b = APR::Bucket::flush_create($ba);
  my $type = $b-&gt;type;
  my $type_name =  $type-&gt;name; # FLUSH

</PRE>


<P>

The type name will be <I>'</I><FONT SIZE="-1"><I>FLUSH</I></FONT><I>'</I> in this example.
<A NAME="lbAT">&nbsp;</A>
<H2>Unsupported API</H2>

<A NAME="ixACU"></A>
<TT>&quot;APR::Socket&quot;</TT> also provides auto-generated Perl interface for a few
other methods which aren't tested at the moment and therefore their
<FONT SIZE="-1">API</FONT> is a subject to change. These methods will be finalized later as a
need arises. If you want to rely on any of the following methods
please contact the the mod_perl development mailing
list so we can help each other take the steps necessary
to shift the method to an officially supported <FONT SIZE="-1">API</FONT>.
<A NAME="lbAU">&nbsp;</A>
<H3>data</H3>



<A NAME="ixACV"></A>


<PRE>
  $data = $b-&gt;data;

</PRE>


<P>

Gives a C pointer to the address of the data in the bucket. I can't
see what use can be done of it in Perl.
<DL COMPACT>
<DT>obj: $b ( APR::Bucket object )<DD>


<A NAME="ixACW"></A>

<DT>ret: $data ( C pointer )<DD>


<A NAME="ixACX"></A>
<DT>since: subject to change<DD>
<A NAME="ixACY"></A>

</DL>
<A NAME="lbAV">&nbsp;</A>
<H3>start</H3>



<A NAME="ixACZ"></A>


<PRE>
  $start = $b-&gt;start;

</PRE>


<P>

It gives the offset to when a new bucket is created with a non-zero
offset value:
<P>



<PRE>
  my $b = APR::Bucket-&gt;new($ba, $data, $offset, $len);

</PRE>


<P>

So if the offset was 3. <TT>$start</TT> will be 3 too.
<P>

I fail to see what it can be useful for to the end user (it's mainly
used internally).
<DL COMPACT>
<DT>obj: $b ( APR::Bucket object )<DD>


<A NAME="ixADA"></A>

<DT>ret: $start ( offset number )<DD>


<A NAME="ixADB"></A>
<DT>since: subject to change<DD>
<A NAME="ixADC"></A>

</DL>
<A NAME="lbAW">&nbsp;</A>
<H2>See Also</H2>

<A NAME="ixADD"></A>
mod_perl 2.0 documentation.
<A NAME="lbAX">&nbsp;</A>
<H2>Copyright</H2>

<A NAME="ixADE"></A>
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
<A NAME="lbAY">&nbsp;</A>
<H2>Authors</H2>

<A NAME="ixADF"></A>
The mod_perl development team and numerous
contributors.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">Synopsis</A><DD>
<DT><A HREF="#lbAD">Description</A><DD>
<DT><A HREF="#lbAE">API</A><DD>
<DL>
<DT><A HREF="#lbAF">delete</A><DD>
<DT><A HREF="#lbAG">destroy</A><DD>
<DT><A HREF="#lbAH">eos_create</A><DD>
<DT><A HREF="#lbAI">flush_create</A><DD>
<DT><A HREF="#lbAJ">insert_after</A><DD>
<DT><A HREF="#lbAK">insert_before</A><DD>
<DT><A HREF="#lbAL">is_eos</A><DD>
<DT><A HREF="#lbAM">is_flush</A><DD>
<DT><A HREF="#lbAN">length</A><DD>
<DT><A HREF="#lbAO">new</A><DD>
<DT><A HREF="#lbAP">read</A><DD>
<DT><A HREF="#lbAQ">remove</A><DD>
<DT><A HREF="#lbAR">setaside</A><DD>
<DT><A HREF="#lbAS">type</A><DD>
</DL>
<DT><A HREF="#lbAT">Unsupported API</A><DD>
<DL>
<DT><A HREF="#lbAU">data</A><DD>
<DT><A HREF="#lbAV">start</A><DD>
</DL>
<DT><A HREF="#lbAW">See Also</A><DD>
<DT><A HREF="#lbAX">Copyright</A><DD>
<DT><A HREF="#lbAY">Authors</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:11 GMT, December 24, 2015
</div></body>
</HTML>
