<!DOCTYPE html>

<HTML><head><TITLE>Manpage of Resource</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>Resource</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2009-03-31<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

BSD::Resource - BSD process resource limit and priority functions
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
        use BSD::Resource;

        #
        # the process resource consumption so far
        #

        ($usertime, $systemtime,
         $maxrss, $ixrss, $idrss, $isrss, $minflt, $majflt, $nswap,
         $inblock, $oublock, $msgsnd, $msgrcv,
         $nsignals, $nvcsw, $nivcsw) = getrusage($ru_who);

        $rusage = getrusage($ru_who);

        #
        # the process resource limits
        #

        ($nowsoft, $nowhard) = getrlimit($resource);

        $rlimit = getrlimit($resource);

        $success = setrlimit($resource, $newsoft, $newhard);

        #
        # the process scheduling priority
        #

        $nowpriority = getpriority($pr_which, $pr_who);

        $success = setpriority($pr_which, $pr_who, $priority);

        # The following is not a BSD function.
        # It is a Perlish utility for the users of BSD::Resource.

        $rlimits = get_rlimits();

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
<A NAME="lbAE">&nbsp;</A>
<H3>getrusage</H3>

<A NAME="ixAAE"></A>


<PRE>
        ($usertime, $systemtime,
         $maxrss, $ixrss, $idrss, $isrss, $minflt, $majflt, $nswap,
         $inblock, $oublock, $msgsnd, $msgrcv,
         $nsignals, $nvcsw, $nivcsw) = getrusage($ru_who);

        $rusage = getrusage($ru_who);

        # $ru_who argument is optional; it defaults to RUSAGE_SELF

        $rusage = getrusage();

</PRE>


<P>

The <TT>$ru_who</TT> argument is either <TT>&quot;RUSAGE_SELF&quot;</TT> (the current process) or
<TT>&quot;RUSAGE_CHILDREN&quot;</TT> (all the child processes of the current process)
or it maybe left away in which case <TT>&quot;RUSAGE_SELF&quot;</TT> is used.
<P>

The <TT>&quot;RUSAGE_CHILDREN&quot;</TT> is the total sum of all the so far
<I>terminated</I> (either successfully or unsuccessfully) child processes:
there is no way to find out information about child processes still
running.
<P>

On some systems (those supporting both <I>getrusage()</I> with the <FONT SIZE="-1">POSIX</FONT>
threads) there can also be <TT>&quot;RUSAGE_THREAD&quot;</TT>. The BSD::Resource supports
the <TT>&quot;RUSAGE_THREAD&quot;</TT> if it is present but understands nothing more about
the <FONT SIZE="-1">POSIX</FONT> threads themselves.  Similarly for <TT>&quot;RUSAGE_BOTH&quot;</TT>: some systems
support retrieving the sums of the self and child resource consumptions
simultaneously.
<P>

In list context <I>getrusage()</I> returns the current resource usages as a
list. On failure it returns an empty list.
<P>

The elements of the list are, in order:
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>index<TT>&nbsp;&nbsp;&nbsp;</TT>name<TT>&nbsp;&nbsp;&nbsp;&nbsp;</TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>meaning usually (quite system dependent)<BR>
<P>



<PRE>
         0      utime           user time
         1      stime           system time
         2      maxrss          maximum shared memory or current resident set
         3      ixrss           integral shared memory
         4      idrss           integral or current unshared data
         5      isrss           integral or current unshared stack
         6      minflt          page reclaims
         7      majflt          page faults
         8      nswap           swaps
         9      inblock         block input operations
        10      oublock         block output operations
        11      msgsnd          messages sent
        12      msgrcv          messaged received
        13      nsignals        signals received
        14      nvcsw           voluntary context switches
        15      nivcsw          involuntary context switches

</PRE>


<P>

In scalar context <I>getrusage()</I> returns the current resource usages as a
an object. The object can be queried via methods named exactly like
the middle column, <I>name</I>, in the above table.
<P>



<PRE>
        $ru = getrusage();
        print $ru-&gt;stime, &quot;\n&quot;;

        $total_context_switches = $ru-&gt;nvcsw + $ru-&gt;nivcsw;

</PRE>


<P>

For a detailed description about the values returned by <I>getrusage()</I>
please consult your usual C programming documentation about
<I>getrusage()</I> and also the header file <TT>&quot;&lt;<A HREF="file:/usr/include/sys/resource.h">sys/resource.h</A>&gt;&quot;</TT>.
(In <B>Solaris</B>, this might be <TT>&quot;&lt;<A HREF="file:/usr/include/sys/rusage.h">sys/rusage.h</A>&gt;&quot;</TT>).
<P>

See also ``<FONT SIZE="-1">KNOWN</FONT> <FONT SIZE="-1">ISSUES</FONT>''.
<A NAME="lbAF">&nbsp;</A>
<H3>getrlimit</H3>

<A NAME="ixAAF"></A>


<PRE>
        ($nowsoft, $nowhard) = getrlimit($resource);

        $rlimit = getrlimit($resource);

</PRE>


<P>

The <TT>$resource</TT> argument can be one of
<P>



<PRE>
        $resource               usual meaning           usual unit

        RLIMIT_CPU              CPU time                seconds

        RLIMIT_FSIZE            file size               bytes

        RLIMIT_DATA             data size               bytes
        RLIMIT_STACK            stack size              bytes
        RLIMIT_CORE             coredump size           bytes
        RLIMIT_RSS              resident set size       bytes
        RLIMIT_MEMLOCK          memory locked data size bytes

        RLIMIT_NPROC            number of processes     1

        RLIMIT_NOFILE           number of open files    1
        RLIMIT_OFILE            number of open files    1
        RLIMIT_OPEN_MAX         number of open files    1

        RLIMIT_LOCKS            number of file locks    1

        RLIMIT_AS               (virtual) address space bytes
        RLIMIT_VMEM             virtual memory (space)  bytes

        RLIMIT_TCACHE           maximum number of       1
                                cached threads

        RLIMIT_AIO_MEM          maximum memory locked   bytes
                                for POSIX AIO
        RLIMIT_AIO_OPS          maximum number          1
                                for POSIX AIO ops

</PRE>


<P>

<B>What limits are available depends on the operating system</B>.
See below for <TT>&quot;get_rlimits()&quot;</TT> on how to find out which limits are
available, for the exact documentation consult the documentation of
your operatgiing system.  The two groups (<TT>&quot;NOFILE&quot;</TT>, C<TT>&quot;OFILE&quot;</TT>,
&lt;<FONT SIZE="-1">OPEN_MAX</FONT>&gt;) and (<TT>&quot;AS&quot;</TT>, <TT>&quot;VMEM&quot;</TT>) are aliases within themselves.
<P>

Two meta-resource-symbols might exist
<P>



<PRE>
        RLIM_NLIMITS
        RLIM_INFINITY

</PRE>


<P>

<TT>&quot;RLIM_NLIMITS&quot;</TT> being the number of possible (but not necessarily fully
supported) resource limits, see also the <I>get_rlimits()</I> call below.
<TT>&quot;RLIM_INFINITY&quot;</TT> is useful in <I>setrlimit()</I>, the <TT>&quot;RLIM_INFINITY&quot;</TT> is
often represented as minus one (-1).
<P>

In list context <TT>&quot;getrlimit()&quot;</TT> returns the current soft and hard
resource limits as a list.  On failure it returns an empty list.
<P>

Processes have soft and hard resource limits.  On crossing the soft
limit they receive a signal (for example the <TT>&quot;SIGXCPU&quot;</TT> or <TT>&quot;SIGXFSZ&quot;</TT>,
corresponding to the <TT>&quot;RLIMIT_CPU&quot;</TT> and <TT>&quot;RLIMIT_FSIZE&quot;</TT>, respectively).
The processes can trap and handle some of these signals, please see
``Signals'' in perlipc.  After the hard limit the processes will be
ruthlessly killed by the <TT>&quot;KILL&quot;</TT> signal which cannot be caught.
<P>

<B></B><FONT SIZE="-1"><B>NOTE</B></FONT><B></B>: the level of 'support' for a resource varies. Not all the systems
<P>



<PRE>
        a) even recognise all those limits
        b) really track the consumption of a resource
        c) care (send those signals) if a resource limit is exceeded

</PRE>


<P>

Again, please consult your usual C programming documentation.
<P>

One notable exception for the better: officially <B>HP-UX</B> does not
support <I>getrlimit()</I> at all but for the time being, it does seem to.
<P>

In scalar context <TT>&quot;getrlimit()&quot;</TT> returns the current soft limit.
On failure it returns <TT>&quot;undef&quot;</TT>.
<A NAME="lbAG">&nbsp;</A>
<H3>getpriority</H3>

<A NAME="ixAAG"></A>


<PRE>
        $nowpriority = getpriority($pr_which, $pr_who);

        # the default $pr_who is 0 (the current $pr_which)

        $nowpriority = getpriority($pr_which);

        # the default $pr_which is PRIO_PROCESS (the process priority)

        $nowpriority = getpriority();

</PRE>


<P>

<I>getpriority()</I> returns the current priority. <B></B><FONT SIZE="-1"><B>NOTE</B></FONT><B></B>: <I>getpriority()</I>
can return zero or negative values completely legally. On failure
<I>getpriority()</I> returns <TT>&quot;undef&quot;</TT> (and <TT>$!</TT> is set as usual).
<P>

The priorities returned by <I>getpriority()</I> are in the (inclusive) range
<TT>&quot;PRIO_MIN&quot;</TT>...<TT>&quot;PRIO_MAX&quot;</TT>.  The <TT>$pr_which</TT> argument can be any of
<FONT SIZE="-1">PRIO_PROCESS</FONT> (a process) <TT>&quot;PRIO_USER&quot;</TT> (a user), or <TT>&quot;PRIO_PGRP&quot;</TT> (a
process group). The <TT>$pr_who</TT> argument tells which process/user/process
group, 0 signifying the current one.
<P>

Usual values for <TT>&quot;PRIO_MIN&quot;</TT>, <TT>&quot;PRIO_MAX&quot;</TT>, are -20, 20.  A negative
value means better priority (more impolite process), a positive value
means worse priority (more polite process).
<A NAME="lbAH">&nbsp;</A>
<H3>setrlimit</H3>

<A NAME="ixAAH"></A>


<PRE>
        $success = setrlimit($resource, $newsoft, $newhard);

</PRE>


<P>

<I>setrlimit()</I> returns true on success and <TT>&quot;undef&quot;</TT> on failure.
<P>

<B></B><FONT SIZE="-1"><B>NOTE</B></FONT><B></B>: A normal user process can only lower its resource limits.
Soft or hard limit <TT>&quot;RLIM_INFINITY&quot;</TT> means as much as possible, the
real hard limits are normally buried inside the kernel and are <B>very</B>
system-dependent.
<P>

<B></B><FONT SIZE="-1"><B>NOTE</B></FONT><B></B>: Even the soft limit that is actually set might be lower than
what requested for various reasons.  One possibility is that the
actual limit on a resource might be controlled by some system variable
(e.g. in <FONT SIZE="-1">BSD</FONT> systems the <FONT SIZE="-1">RLIMIT_NPROC</FONT> can be capped by the system
variable <TT>&quot;maxprocperuid&quot;</TT>, try <TT>&quot;sysctl -a kern.maxprocperuid&quot;</TT>),
or in many environments core dumping has been disabled from normal
user processes.  Another possibility is that a limit is rounded down
to some alignment or granularity, for example the memory limits might
be rounded down to the closest 4 kilobyte boundary.  In other words,
do not expect to be able to <I>setrlimit()</I> a limit to a value and then be
able to read back the same value with <I>getrlimit()</I>.
<A NAME="lbAI">&nbsp;</A>
<H3>setpriority</H3>

<A NAME="ixAAI"></A>


<PRE>
        $success = setpriority($pr_which, $pr_who, $priority);

        # NOTE! If there are two arguments the second one is
        # the new $priority (not $pr_who) and the $pr_who is
        # defaulted to 0 (the current $pr_which)

        $success = setpriority($pr_which, $priority);

        # The $pr_who defaults to 0 (the current $pr_which) and
        # the $priority defaults to half of the PRIO_MAX, usually
        # that amounts to 10 (being a nice $pr_which).

        $success = setpriority($pr_which);

        # The $pr_which defaults to PRIO_PROCESS.

        $success = setpriority();

</PRE>


<P>

<I>setpriority()</I> is used to change the scheduling priority.  A positive
priority means a more polite process/process group/user; a negative
priority means a more impoite process/process group/user.
The priorities handled by <I>setpriority()</I> are [<TT>&quot;PRIO_MIN&quot;</TT>,<TT>&quot;PRIO_MAX&quot;</TT>].
A normal user process can only lower its priority (make it more positive).
<P>

<B></B><FONT SIZE="-1"><B>NOTE</B></FONT><B></B>: A successful call returns <TT>1</TT>, a failed one <TT>0</TT>.
<P>

See also ``<FONT SIZE="-1">KNOWN</FONT> <FONT SIZE="-1">ISSUES</FONT>''.
<A NAME="lbAJ">&nbsp;</A>
<H3>times</H3>

<A NAME="ixAAJ"></A>


<PRE>
        use BSD::Resource qw(times);

        ($user, $system, $child_user, $child_system) = times();

</PRE>


<P>

The BSD::Resource module offers a <I>times()</I> implementation that has
usually slightly better time granularity than the <I>times()</I> by Perl
core.  The time granularity of the latter is usually 1/60 seconds
while the former may achieve submilliseconds.
<P>

<B></B><FONT SIZE="-1"><B>NOTE</B></FONT><B></B>: The current implementation uses two <I>getrusage()</I> system calls:
one with <FONT SIZE="-1">RUSAGE_SELF</FONT> and one with <FONT SIZE="-1">RUSAGE_CHILDREN</FONT>.  Therefore the
operation is not `atomic': the times for the children are recorded
a little bit later.
<P>

<B></B><FONT SIZE="-1"><B>NOTE</B></FONT><B></B>: <I>times()</I> is not imported by default by BSD::Resource.
You need to tell that you want to use it.
<P>

<B></B><FONT SIZE="-1"><B>NOTE:</B></FONT><B> </B>times()<B> is not a ``real </B><FONT SIZE="-1"><B>BSD</B></FONT><B>'' function.  It is older </B><FONT SIZE="-1"><B>UNIX</B></FONT><B>.</B>
<A NAME="lbAK">&nbsp;</A>
<H3>get_rlimits</H3>

<A NAME="ixAAK"></A>


<PRE>
        $rlimits = get_rlimits();

</PRE>


<P>

<B></B><FONT SIZE="-1"><B>NOTE:</B></FONT><B> This is not a real </B><FONT SIZE="-1"><B>BSD</B></FONT><B> function. It is a convenience function.</B>
<P>

<I>get_rlimits()</I> returns a reference to hash which has the names of the
available resource limits as keys and their indices (those which
are needed as the first argument to <I>getrlimit()</I> and <I>setrlimit()</I>)
as values. For example:
<P>



<PRE>
        $r = get_rlimits();
        print &quot;ok.\n&quot; if ($r-&gt;{'RLIM_STACK'} == RLIM_STACK);

</PRE>


<A NAME="lbAL">&nbsp;</A>
<H2>ERRORS</H2>

<A NAME="ixAAL"></A>
<DL COMPACT>
<DT>*<DD>
<P>


<P>




<PRE>
        Your vendor has not defined BSD::Resource macro ...

</PRE>




<P>


The code tried to call getrlimit/setrlimit for a resource limit that
your operating system vendor/supplier does not support.  Portable code
should use <I>get_rlimits()</I> to check which resource limits are defined.
</DL>
<A NAME="lbAM">&nbsp;</A>
<H2>EXAMPLES</H2>

<A NAME="ixAAM"></A>


<PRE>
        # the user and system times so far by the process itself

        ($usertime, $systemtime) = getrusage();

        # ditto in OO way

        $ru = getrusage();

        $usertime   = $ru-&gt;utime;
        $systemtime = $ru-&gt;stime;

        # get the current priority level of this process

        $currprio = getpriority();

</PRE>


<A NAME="lbAN">&nbsp;</A>
<H2>KNOWN ISSUES</H2>

<A NAME="ixAAN"></A>
In <B></B><FONT SIZE="-1"><B>AIX</B></FONT><B></B> (at least version 3, maybe later also releases) if the <FONT SIZE="-1">BSD</FONT>
compatibility library is not installed or not found by the BSD::Resource
installation procedure and when using the <I>getpriority()</I> or <I>setpriority()</I>,
the <TT>&quot;PRIO_MIN&quot;</TT> is 0 (corresponding to -20) and <TT>&quot;PRIO_MAX&quot;</TT> is 39
(corresponding to 19, the <FONT SIZE="-1">BSD</FONT> priority 20 is unreachable).
<P>

In <B>HP-UX</B> the <I>getrusage()</I> is not Officially Supported at all but for
the time being, it does seem to be.
<P>

In Mac <FONT SIZE="-1">OS</FONT> X a normal user cannot raise the <FONT SIZE="-1">RLIM_NPROC</FONT> over the
maxprocperuid limit (the default value is 266, try the command
<TT>&quot;sysctl -a kern.maxprocperuid&quot;</TT>).
<P>

In NetBSD <FONT SIZE="-1">RLIMIT_STACK</FONT> calls fail.
<P>

Because not all <FONT SIZE="-1">UNIX</FONT> kernels are <FONT SIZE="-1">BSD</FONT> and also because of the sloppy
support of <I>getrusage()</I> by many vendors many of the <I>getrusage()</I> values
may not be correctly updated.  For example <B>Solaris 1</B> claims in
<TT>&quot;&lt;<A HREF="file:/usr/include/sys/rusage.h">sys/rusage.h</A>&gt;&quot;</TT> that the <TT>&quot;ixrss&quot;</TT> and the <TT>&quot;isrss&quot;</TT> fields
are always zero.  In <B>SunOS 5.5 and 5.6</B> the <I>getrusage()</I> leaves most
of the fiels zero and therefore <I>getrusage()</I> is not even used, instead
of that the <B>/proc</B> interface is used.  The mapping is not perfect:
the <TT>&quot;maxrss&quot;</TT> field is really the <B>current</B> resident size instead of the
maximum, the <TT>&quot;idrss&quot;</TT> is really the <B>current</B> heap size instead of the
integral data, and the <TT>&quot;isrss&quot;</TT> is really the <B>current</B> stack size
instead of the integral stack.  The ixrss has no sensible counterpart
at all so it stays zero.
<A NAME="lbAO">&nbsp;</A>
<H2>COPYRIGHT AND LICENSE</H2>

<A NAME="ixAAO"></A>
Copyright 1995-2008 Jarkko Hietaniemi All Rights Reserved
<P>

This library is free software; you may redistribute it and/or modify
it under the same terms as Perl itself.
<A NAME="lbAP">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixAAP"></A>
Jarkko Hietaniemi, <TT>&quot;<A HREF="mailto:jhi@iki.fi">jhi@iki.fi</A>&quot;</TT>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE">getrusage</A><DD>
<DT><A HREF="#lbAF">getrlimit</A><DD>
<DT><A HREF="#lbAG">getpriority</A><DD>
<DT><A HREF="#lbAH">setrlimit</A><DD>
<DT><A HREF="#lbAI">setpriority</A><DD>
<DT><A HREF="#lbAJ">times</A><DD>
<DT><A HREF="#lbAK">get_rlimits</A><DD>
</DL>
<DT><A HREF="#lbAL">ERRORS</A><DD>
<DT><A HREF="#lbAM">EXAMPLES</A><DD>
<DT><A HREF="#lbAN">KNOWN ISSUES</A><DD>
<DT><A HREF="#lbAO">COPYRIGHT AND LICENSE</A><DD>
<DT><A HREF="#lbAP">AUTHOR</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:15 GMT, December 24, 2015
</div></body>
</HTML>
