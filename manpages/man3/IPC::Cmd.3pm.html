<!DOCTYPE html>

<HTML><head><TITLE>Manpage of IPC::Cmd</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>IPC::Cmd</H1>
Section: Perl Programmers Reference Guide (3pm)<BR>Updated: 2012-06-22<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

IPC::Cmd - finding and running system commands made easy
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
    use IPC::Cmd qw[can_run run run_forked];

    my $full_path = can_run('wget') or warn 'wget is not installed!';

    ### commands can be arrayrefs or strings ###
    my $cmd = &quot;$full_path -b theregister.co.uk&quot;;
    my $cmd = [$full_path, '-b', 'theregister.co.uk'];

    ### in scalar context ###
    my $buffer;
    if( scalar run( command =&gt; $cmd,
                    verbose =&gt; 0,
                    buffer  =&gt; \$buffer,
                    timeout =&gt; 20 )
    ) {
        print &quot;fetched webpage successfully: $buffer\n&quot;;
    }


    ### in list context ###
    my( $success, $error_code, $full_buf, $stdout_buf, $stderr_buf ) =
            run( command =&gt; $cmd, verbose =&gt; 0 );

    if( $success ) {
        print &quot;this is what the command printed:\n&quot;;
        print join &quot;&quot;, @$full_buf;
    }

    ### check for features
    print &quot;IPC::Open3 available: &quot;  . IPC::Cmd-&gt;can_use_ipc_open3;      
    print &quot;IPC::Run available: &quot;    . IPC::Cmd-&gt;can_use_ipc_run;      
    print &quot;Can capture buffer: &quot;    . IPC::Cmd-&gt;can_capture_buffer;     

    ### don't have IPC::Cmd be verbose, ie don't print to stdout or
    ### stderr when running commands -- default is '0'
    $IPC::Cmd::VERBOSE = 0;

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
IPC::Cmd allows you to run commands, interactively if desired,
platform independent but have them still work.
<P>

The <TT>&quot;can_run&quot;</TT> function can tell you if a certain binary is installed
and if so where, whereas the <TT>&quot;run&quot;</TT> function can actually execute any
of the commands you give it and give you a clear return value, as well
as adhere to your verbosity settings.
<A NAME="lbAE">&nbsp;</A>
<H2>CLASS METHODS</H2>

<A NAME="ixAAE"></A>
<A NAME="lbAF">&nbsp;</A>
<H3>$ipc_run_version = IPC::Cmd-&gt;can_use_ipc_run( [<FONT SIZE="-1">VERBOSE</FONT>] )</H3>



<A NAME="ixAAF"></A>
Utility function that tells you if <TT>&quot;IPC::Run&quot;</TT> is available. 
If the verbose flag is passed, it will print diagnostic messages
if <TT>&quot;IPC::Run&quot;</TT> can not be found or loaded.
<A NAME="lbAG">&nbsp;</A>
<H3>$ipc_open3_version = IPC::Cmd-&gt;can_use_ipc_open3( [<FONT SIZE="-1">VERBOSE</FONT>] )</H3>



<A NAME="ixAAG"></A>
Utility function that tells you if <TT>&quot;IPC::Open3&quot;</TT> is available. 
If the verbose flag is passed, it will print diagnostic messages
if <TT>&quot;IPC::Open3&quot;</TT> can not be found or loaded.
<A NAME="lbAH">&nbsp;</A>
<H3>$bool = IPC::Cmd-&gt;can_capture_buffer</H3>



<A NAME="ixAAH"></A>
Utility function that tells you if <TT>&quot;IPC::Cmd&quot;</TT> is capable of
capturing buffers in it's current configuration.
<A NAME="lbAI">&nbsp;</A>
<H3>$bool = IPC::Cmd-&gt;can_use_run_forked</H3>



<A NAME="ixAAI"></A>
Utility function that tells you if <TT>&quot;IPC::Cmd&quot;</TT> is capable of
providing <TT>&quot;run_forked&quot;</TT> on the current platform.
<A NAME="lbAJ">&nbsp;</A>
<H2>FUNCTIONS</H2>

<A NAME="ixAAJ"></A>
<A NAME="lbAK">&nbsp;</A>
<H3>$path = can_run( <FONT SIZE="-1">PROGRAM</FONT> );</H3>



<A NAME="ixAAK"></A>
<TT>&quot;can_run&quot;</TT> takes but a single argument: the name of a binary you wish
to locate. <TT>&quot;can_run&quot;</TT> works much like the unix binary <TT>&quot;which&quot;</TT> or the bash
command <TT>&quot;type&quot;</TT>, which scans through your path, looking for the requested
binary .
<P>

Unlike <TT>&quot;which&quot;</TT> and <TT>&quot;type&quot;</TT>, this function is platform independent and
will also work on, for example, Win32.
<P>

It will return the full path to the binary you asked for if it was
found, or <TT>&quot;undef&quot;</TT> if it was not.
<A NAME="lbAL">&nbsp;</A>
<H3>$ok | ($ok, $err, $full_buf, $stdout_buff, $stderr_buff) = run( command =&gt; <FONT SIZE="-1">COMMAND</FONT>, [verbose =&gt; <FONT SIZE="-1">BOOL</FONT>, buffer =&gt; \$SCALAR, timeout =&gt; <FONT SIZE="-1">DIGIT</FONT>] );</H3>



<A NAME="ixAAL"></A>
<TT>&quot;run&quot;</TT> takes 4 arguments:
<DL COMPACT>
<DT>command<DD>
<A NAME="ixAAM"></A>
This is the command to execute. It may be either a string or an array
reference.
This is a required argument.


<P>


See <FONT SIZE="-1">CAVEATS</FONT> for remarks on how commands are parsed and their
limitations.
<DT>verbose<DD>
<A NAME="ixAAN"></A>
This controls whether all output of a command should also be printed
to <FONT SIZE="-1">STDOUT/STDERR</FONT> or should only be trapped in buffers (<FONT SIZE="-1">NOTE:</FONT> buffers
require <TT>&quot;IPC::Run&quot;</TT> to be installed or your system able to work with
<TT>&quot;IPC::Open3&quot;</TT>).


<P>


It will default to the global setting of <TT>$IPC::Cmd::VERBOSE</TT>,
which by default is 0.
<DT>buffer<DD>
<A NAME="ixAAO"></A>
This will hold all the output of a command. It needs to be a reference
to a scalar.
Note that this will hold both the <FONT SIZE="-1">STDOUT</FONT> and <FONT SIZE="-1">STDERR</FONT> messages, and you
have no way of telling which is which.
If you require this distinction, run the <TT>&quot;run&quot;</TT> command in list context
and inspect the individual buffers.


<P>


Of course, this requires that the underlying call supports buffers. See
the note on buffers right above.
<DT>timeout<DD>
<A NAME="ixAAP"></A>
Sets the maximum time the command is allowed to run before aborting,
using the built-in <TT>&quot;alarm()&quot;</TT> call. If the timeout is triggered, the
<TT>&quot;errorcode&quot;</TT> in the return value will be set to an object of the 
<TT>&quot;IPC::Cmd::TimeOut&quot;</TT> class. See the <TT>&quot;errorcode&quot;</TT> section below for
details.


<P>


Defaults to <TT>0</TT>, meaning no timeout is set.
</DL>
<P>

<TT>&quot;run&quot;</TT> will return a simple <TT>&quot;true&quot;</TT> or <TT>&quot;false&quot;</TT> when called in scalar
context.
In list context, you will be returned a list of the following items:
<DL COMPACT>
<DT>success<DD>
<A NAME="ixAAQ"></A>
A simple boolean indicating if the command executed without errors or
not.
<DT>error message<DD>
<A NAME="ixAAR"></A>
If the first element of the return value (success) was 0, then some
error occurred. This second element is the error message the command
you requested exited with, if available. This is generally a pretty 
printed value of <TT>$?</TT> or <TT>$@</TT>. See <TT>&quot;perldoc perlvar&quot;</TT> for details on 
what they can contain.
If the error was a timeout, the <TT>&quot;error message&quot;</TT> will be prefixed with
the string <TT>&quot;IPC::Cmd::TimeOut&quot;</TT>, the timeout class.
<DT>full_buffer<DD>
<A NAME="ixAAS"></A>
This is an arrayreference containing all the output the command
generated.
Note that buffers are only available if you have <TT>&quot;IPC::Run&quot;</TT> installed,
or if your system is able to work with <TT>&quot;IPC::Open3&quot;</TT> --- See below).
This element will be <TT>&quot;undef&quot;</TT> if this is not the case.
<DT>out_buffer<DD>
<A NAME="ixAAT"></A>
This is an arrayreference containing all the output sent to <FONT SIZE="-1">STDOUT</FONT> the
command generated.
Note that buffers are only available if you have <TT>&quot;IPC::Run&quot;</TT> installed,
or if your system is able to work with <TT>&quot;IPC::Open3&quot;</TT> --- See below).
This element will be <TT>&quot;undef&quot;</TT> if this is not the case.
<DT>error_buffer<DD>
<A NAME="ixAAU"></A>
This is an arrayreference containing all the output sent to <FONT SIZE="-1">STDERR</FONT> the
command generated.
Note that buffers are only available if you have <TT>&quot;IPC::Run&quot;</TT> installed,
or if your system is able to work with <TT>&quot;IPC::Open3&quot;</TT> --- See below).
This element will be <TT>&quot;undef&quot;</TT> if this is not the case.
</DL>
<P>

See the <TT>&quot;HOW IT WORKS&quot;</TT> Section below to see how <TT>&quot;IPC::Cmd&quot;</TT> decides
what modules or function calls to use when issuing a command.
<A NAME="lbAM">&nbsp;</A>
<H3>$hashref = run_forked( <FONT SIZE="-1">COMMAND</FONT>, { child_stdin =&gt; <FONT SIZE="-1">SCALAR</FONT>, timeout =&gt; <FONT SIZE="-1">DIGIT</FONT>, stdout_handler =&gt; <FONT SIZE="-1">CODEREF</FONT>, stderr_handler =&gt; <FONT SIZE="-1">CODEREF</FONT>} );</H3>



<A NAME="ixAAV"></A>
<TT>&quot;run_forked&quot;</TT> is used to execute some program or a coderef,
optionally feed it with some input, get its return code
and output (both stdout and stderr into seperate buffers).
In addition it allows to terminate the program
which take too long to finish.
<P>

The important and distinguishing feature of run_forked
is execution timeout which at first seems to be
quite a simple task but if you think
that the program which you're spawning
might spawn some children itself (which
in their turn could do the same and so on)
it turns out to be not a simple issue.
<P>

<TT>&quot;run_forked&quot;</TT> is designed to survive and
successfully terminate almost any long running task,
even a fork bomb in case your system has the resources
to survive during given timeout.
<P>

This is achieved by creating separate watchdog process
which spawns the specified program in a separate
process session and supervises it: optionally
feeds it with input, stores its exit code,
stdout and stderr, terminates it in case
it runs longer than specified.
<P>

Invocation requires the command to be executed or a coderef and optionally a hashref of options:
<DL COMPACT>
<DT>timeout<DD>


<A NAME="ixAAW"></A>
Specify in seconds how long the command may run for before it is killed with with <FONT SIZE="-1">SIG_KILL</FONT> (9) 
which effectively terminates it and all of its children (direct or indirect).
<DT>child_stdin<DD>


<A NAME="ixAAX"></A>
Specify some text that will be passed into <TT>&quot;STDIN&quot;</TT> of the executed program.
<DT>stdout_handler<DD>


<A NAME="ixAAY"></A>
You may provide a coderef of a subroutine that will be called a portion of data is received on 
stdout from the executing program.
<DT>stderr_handler<DD>


<A NAME="ixAAZ"></A>
You may provide a coderef of a subroutine that will be called a portion of data is received on 
stderr from the executing program.
</DL>
<P>

<TT>&quot;run_forked&quot;</TT> will return a <FONT SIZE="-1">HASHREF</FONT> with the following keys:
<DL COMPACT>
<DT>exit_code<DD>


<A NAME="ixABA"></A>
The exit code of the executed program.
<DT>timeout<DD>


<A NAME="ixABB"></A>
The number of seconds the program ran for before being terminated, or 0 if no timeout occurred.
<DT>stdout<DD>


<A NAME="ixABC"></A>
Holds the standard output of the executed command
(or empty string if there were no stdout output; it's always defined!)
<DT>stderr<DD>


<A NAME="ixABD"></A>
Holds the standard error of the executed command
(or empty string if there were no stderr output; it's always defined!)
<DT>merged<DD>


<A NAME="ixABE"></A>
Holds the standard output and error of the executed command merged into one stream
(or empty string if there were no output at all; it's always defined!)
<DT>err_msg<DD>


<A NAME="ixABF"></A>
Holds some explanation in the case of an error.
</DL>
<A NAME="lbAN">&nbsp;</A>
<H3>$q = <FONT SIZE="-1">QUOTE</FONT></H3>



<A NAME="ixABG"></A>
Returns the character used for quoting strings on this platform. This is
usually a <TT>&quot;'&quot;</TT> (single quote) on most systems, but some systems use different
quotes. For example, <TT>&quot;Win32&quot;</TT> uses <TT>&quot;&quot;&quot;</TT> (double quote).
<P>

You can use it as follows:
<P>



<PRE>
  use IPC::Cmd qw[run QUOTE];
  my $cmd = q[echo ] . QUOTE . q[foo bar] . QUOTE;

</PRE>


<P>

This makes sure that <TT>&quot;foo bar&quot;</TT> is treated as a string, rather than two
seperate arguments to the <TT>&quot;echo&quot;</TT> function.
<P>

__END__
<A NAME="lbAO">&nbsp;</A>
<H2>HOW IT WORKS</H2>

<A NAME="ixABH"></A>
<TT>&quot;run&quot;</TT> will try to execute your command using the following logic:
<DL COMPACT>
<DT>*<DD>
If you have <TT>&quot;IPC::Run&quot;</TT> installed, and the variable <TT>$IPC::Cmd::USE_IPC_RUN</TT>
is set to true (See the <TT>&quot;GLOBAL VARIABLES&quot;</TT> Section) use that to execute 
the command. You will have the full output available in buffers, interactive commands are sure to work  and you are guaranteed to have your verbosity
settings honored cleanly.
<DT>*<DD>
Otherwise, if the variable <TT>$IPC::Cmd::USE_IPC_OPEN3</TT> is set to true 
(See the <TT>&quot;GLOBAL VARIABLES&quot;</TT> Section), try to execute the command using
<TT>&quot;IPC::Open3&quot;</TT>. Buffers will be available on all platforms except <TT>&quot;Win32&quot;</TT>,
interactive commands will still execute cleanly, and also your verbosity
settings will be adhered to nicely;
<DT>*<DD>
Otherwise, if you have the verbose argument set to true, we fall back
to a simple <I>system()</I> call. We cannot capture any buffers, but
interactive commands will still work.
<DT>*<DD>
Otherwise we will try and temporarily redirect <FONT SIZE="-1">STDERR</FONT> and <FONT SIZE="-1">STDOUT</FONT>, do a
<I>system()</I> call with your command and then re-open <FONT SIZE="-1">STDERR</FONT> and <FONT SIZE="-1">STDOUT</FONT>.
This is the method of last resort and will still allow you to execute
your commands cleanly. However, no buffers will be available.
</DL>
<A NAME="lbAP">&nbsp;</A>
<H2>Global Variables</H2>

<A NAME="ixABI"></A>
The behaviour of IPC::Cmd can be altered by changing the following
global variables:
<A NAME="lbAQ">&nbsp;</A>
<H3>$IPC::Cmd::VERBOSE</H3>



<A NAME="ixABJ"></A>
This controls whether IPC::Cmd will print any output from the
commands to the screen or not. The default is 0;
<A NAME="lbAR">&nbsp;</A>
<H3>$IPC::Cmd::USE_IPC_RUN</H3>



<A NAME="ixABK"></A>
This variable controls whether IPC::Cmd will try to use IPC::Run
when available and suitable. Defaults to true if you are on <TT>&quot;Win32&quot;</TT>.
<A NAME="lbAS">&nbsp;</A>
<H3>$IPC::Cmd::USE_IPC_OPEN3</H3>



<A NAME="ixABL"></A>
This variable controls whether IPC::Cmd will try to use IPC::Open3
when available and suitable. Defaults to true.
<A NAME="lbAT">&nbsp;</A>
<H3>$IPC::Cmd::WARN</H3>



<A NAME="ixABM"></A>
This variable controls whether run time warnings should be issued, like
the failure to load an <TT>&quot;IPC::*&quot;</TT> module you explicitly requested.
<P>

Defaults to true. Turn this off at your own risk.
<A NAME="lbAU">&nbsp;</A>
<H2>Caveats</H2>

<A NAME="ixABN"></A>
<DL COMPACT>
<DT>Whitespace and IPC::Open3 / <I>system()</I><DD>
<A NAME="ixABO"></A>
When using <TT>&quot;IPC::Open3&quot;</TT> or <TT>&quot;system&quot;</TT>, if you provide a string as the
<TT>&quot;command&quot;</TT> argument, it is assumed to be appropriately escaped. You can
use the <TT>&quot;QUOTE&quot;</TT> constant to use as a portable quote character (see above).
However, if you provide and <TT>&quot;Array Reference&quot;</TT>, special rules apply:


<P>


If your command contains <TT>&quot;Special Characters&quot;</TT> (&lt; &gt; | &amp;), it will
be internally stringified before executing the command, to avoid that these
special characters are escaped and passed as arguments instead of retaining
their special meaning.


<P>


However, if the command contained arguments that contained whitespace, 
stringifying the command would loose the significance of the whitespace.
Therefor, <TT>&quot;IPC::Cmd&quot;</TT> will quote any arguments containing whitespace in your
command if the command is passed as an arrayref and contains special characters.
<DT>Whitespace and IPC::Run<DD>
<A NAME="ixABP"></A>
When using <TT>&quot;IPC::Run&quot;</TT>, if you provide a string as the <TT>&quot;command&quot;</TT> argument, 
the string will be split on whitespace to determine the individual elements 
of your command. Although this will usually just Do What You Mean, it may
break if you have files or commands with whitespace in them.


<P>


If you do not wish this to happen, you should provide an array
reference, where all parts of your command are already separated out.
Note however, if there's extra or spurious whitespace in these parts,
the parser or underlying code may not interpret it correctly, and
cause an error.


<P>


Example:
The following code


<P>




<PRE>
    gzip -cdf foo.tar.gz | tar -xf -

</PRE>




<P>


should either be passed as


<P>




<PRE>
    &quot;gzip -cdf foo.tar.gz | tar -xf -&quot;

</PRE>




<P>


or as


<P>




<PRE>
    ['gzip', '-cdf', 'foo.tar.gz', '|', 'tar', '-xf', '-']

</PRE>




<P>


But take care not to pass it as, for example


<P>




<PRE>
    ['gzip -cdf foo.tar.gz', '|', 'tar -xf -']

</PRE>




<P>


Since this will lead to issues as described above.
<DT><FONT SIZE="-1">IO</FONT> Redirect<DD>
<A NAME="ixABQ"></A>
Currently it is too complicated to parse your command for <FONT SIZE="-1">IO</FONT>
Redirections. For capturing <FONT SIZE="-1">STDOUT</FONT> or <FONT SIZE="-1">STDERR</FONT> there is a work around
however, since you can just inspect your buffers for the contents.
<DT>Interleaving <FONT SIZE="-1">STDOUT/STDERR</FONT><DD>
<A NAME="ixABR"></A>
Neither IPC::Run nor IPC::Open3 can interleave <FONT SIZE="-1">STDOUT</FONT> and <FONT SIZE="-1">STDERR</FONT>. For short
bursts of output from a program, ie this sample:


<P>




<PRE>
    for ( 1..4 ) {
        $_ % 2 ? print STDOUT $_ : print STDERR $_;
    }

</PRE>




<P>


IPC::[Run|Open3] will first read all of <FONT SIZE="-1">STDOUT</FONT>, then all of <FONT SIZE="-1">STDERR</FONT>, meaning 
the output looks like 1 line on each, namely '13' on <FONT SIZE="-1">STDOUT</FONT> and '24' on <FONT SIZE="-1">STDERR</FONT>.


<P>


It should have been 1, 2, 3, 4.


<P>


This has been recorded in rt.cpan.org as bug #37532: Unable to interleave
<FONT SIZE="-1">STDOUT</FONT> and <FONT SIZE="-1">STDERR</FONT>
</DL>
<A NAME="lbAV">&nbsp;</A>
<H2>See Also</H2>

<A NAME="ixABS"></A>
<TT>&quot;IPC::Run&quot;</TT>, <TT>&quot;IPC::Open3&quot;</TT>
<A NAME="lbAW">&nbsp;</A>
<H2>ACKNOWLEDGEMENTS</H2>

<A NAME="ixABT"></A>
Thanks to James Mastros and Martijn van der Streek for their
help in getting IPC::Open3 to behave nicely.
<P>

Thanks to Petya Kohts for the <TT>&quot;run_forked&quot;</TT> code.
<A NAME="lbAX">&nbsp;</A>
<H2>BUG REPORTS</H2>

<A NAME="ixABU"></A>
Please report bugs or other issues to &lt;<A HREF="mailto:bug-ipc-cmd@rt.cpan.org">bug-ipc-cmd@rt.cpan.org</A>&gt;.
<A NAME="lbAY">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixABV"></A>
This module by Jos Boumans &lt;<A HREF="mailto:kane@cpan.org">kane@cpan.org</A>&gt;.
<A NAME="lbAZ">&nbsp;</A>
<H2>COPYRIGHT</H2>

<A NAME="ixABW"></A>
This library is free software; you may redistribute and/or modify it 
under the same terms as Perl itself.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">CLASS METHODS</A><DD>
<DL>
<DT><A HREF="#lbAF">$ipc_run_version = IPC::Cmd-&gt;can_use_ipc_run( [<FONT SIZE="-1">VERBOSE</FONT>] )</A><DD>
<DT><A HREF="#lbAG">$ipc_open3_version = IPC::Cmd-&gt;can_use_ipc_open3( [<FONT SIZE="-1">VERBOSE</FONT>] )</A><DD>
<DT><A HREF="#lbAH">$bool = IPC::Cmd-&gt;can_capture_buffer</A><DD>
<DT><A HREF="#lbAI">$bool = IPC::Cmd-&gt;can_use_run_forked</A><DD>
</DL>
<DT><A HREF="#lbAJ">FUNCTIONS</A><DD>
<DL>
<DT><A HREF="#lbAK">$path = can_run( <FONT SIZE="-1">PROGRAM</FONT> );</A><DD>
<DT><A HREF="#lbAL">$ok | ($ok, $err, $full_buf, $stdout_buff, $stderr_buff) = run( command =&gt; <FONT SIZE="-1">COMMAND</FONT>, [verbose =&gt; <FONT SIZE="-1">BOOL</FONT>, buffer =&gt; \$SCALAR, timeout =&gt; <FONT SIZE="-1">DIGIT</FONT>] );</A><DD>
<DT><A HREF="#lbAM">$hashref = run_forked( <FONT SIZE="-1">COMMAND</FONT>, { child_stdin =&gt; <FONT SIZE="-1">SCALAR</FONT>, timeout =&gt; <FONT SIZE="-1">DIGIT</FONT>, stdout_handler =&gt; <FONT SIZE="-1">CODEREF</FONT>, stderr_handler =&gt; <FONT SIZE="-1">CODEREF</FONT>} );</A><DD>
<DT><A HREF="#lbAN">$q = <FONT SIZE="-1">QUOTE</FONT></A><DD>
</DL>
<DT><A HREF="#lbAO">HOW IT WORKS</A><DD>
<DT><A HREF="#lbAP">Global Variables</A><DD>
<DL>
<DT><A HREF="#lbAQ">$IPC::Cmd::VERBOSE</A><DD>
<DT><A HREF="#lbAR">$IPC::Cmd::USE_IPC_RUN</A><DD>
<DT><A HREF="#lbAS">$IPC::Cmd::USE_IPC_OPEN3</A><DD>
<DT><A HREF="#lbAT">$IPC::Cmd::WARN</A><DD>
</DL>
<DT><A HREF="#lbAU">Caveats</A><DD>
<DT><A HREF="#lbAV">See Also</A><DD>
<DT><A HREF="#lbAW">ACKNOWLEDGEMENTS</A><DD>
<DT><A HREF="#lbAX">BUG REPORTS</A><DD>
<DT><A HREF="#lbAY">AUTHOR</A><DD>
<DT><A HREF="#lbAZ">COPYRIGHT</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:30 GMT, December 24, 2015
</div></div>
</body>
</HTML>
