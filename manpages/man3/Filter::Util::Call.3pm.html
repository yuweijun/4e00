<!DOCTYPE html>

<HTML><head><TITLE>Manpage of Filter::Util::Call</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>Filter::Util::Call</H1>
Section: Perl Programmers Reference Guide (3pm)<BR>Updated: 2009-04-15<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Filter::Util::Call - Perl Source Filter Utility Module
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
    use Filter::Util::Call ;

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
This module provides you with the framework to write <I>Source Filters</I>
in Perl.
<P>

An alternate interface to Filter::Util::Call is now available. See
Filter::Simple for more details.
<P>

A <I>Perl Source Filter</I> is implemented as a Perl module. The structure
of the module can take one of two broadly similar formats. To
distinguish between them, the first will be referred to as <I>method
filter</I> and the second as <I>closure filter</I>.
<P>

Here is a skeleton for the <I>method filter</I>:
<P>



<PRE>
    package MyFilter ;

    use Filter::Util::Call ;

    sub import
    {
        my($type, @arguments) = @_ ;
        filter_add([]) ;
    }

    sub filter
    {
        my($self) = @_ ;
        my($status) ;

        $status = filter_read() ;
        $status ;
    }

    1 ;

</PRE>


<P>

and this is the equivalent skeleton for the <I>closure filter</I>:
<P>



<PRE>
    package MyFilter ;

    use Filter::Util::Call ;

    sub import
    {
        my($type, @arguments) = @_ ;

        filter_add(
            sub 
            {
                my($status) ;
                $status = filter_read() ;
                $status ;
            } )
    }

    1 ;

</PRE>


<P>

To make use of either of the two filter modules above, place the line
below in a Perl source file.
<P>



<PRE>
    use MyFilter;

</PRE>


<P>

In fact, the skeleton modules shown above are fully functional <I>Source
Filters</I>, albeit fairly useless ones. All they does is filter the
source stream without modifying it at all.
<P>

As you can see both modules have a broadly similar structure. They both
make use of the <TT>&quot;Filter::Util::Call&quot;</TT> module and both have an <TT>&quot;import&quot;</TT>
method. The difference between them is that the <I>method filter</I>
requires a <I>filter</I> method, whereas the <I>closure filter</I> gets the
equivalent of a <I>filter</I> method with the anonymous sub passed to
<I>filter_add</I>.
<P>

To make proper use of the <I>closure filter</I> shown above you need to
have a good understanding of the concept of a <I>closure</I>. See
perlref for more details on the mechanics of <I>closures</I>.
<A NAME="lbAE">&nbsp;</A>
<H3><B>use Filter::Util::Call</B></H3>

<A NAME="ixAAE"></A>
The following functions are exported by <TT>&quot;Filter::Util::Call&quot;</TT>:
<P>



<PRE>
    filter_add()
    filter_read()
    filter_read_exact()
    filter_del()

</PRE>


<A NAME="lbAF">&nbsp;</A>
<H3><B></B>import()<B></B></H3>

<A NAME="ixAAF"></A>
The <TT>&quot;import&quot;</TT> method is used to create an instance of the filter. It is
called indirectly by Perl when it encounters the <TT>&quot;use MyFilter&quot;</TT> line
in a source file (See ``import'' in perlfunc for more details on
<TT>&quot;import&quot;</TT>).
<P>

It will always have at least one parameter automatically passed by Perl
- this corresponds to the name of the package. In the example above it
will be <TT>&quot;MyFilter&quot;</TT>.
<P>

Apart from the first parameter, import can accept an optional list of
parameters. These can be used to pass parameters to the filter. For
example:
<P>



<PRE>
    use MyFilter qw(a b c) ;

</PRE>


<P>

will result in the <TT>@_</TT> array having the following values:
<P>



<PRE>
    @_ [0] =&gt; &quot;MyFilter&quot;
    @_ [1] =&gt; &quot;a&quot;
    @_ [2] =&gt; &quot;b&quot;
    @_ [3] =&gt; &quot;c&quot;

</PRE>


<P>

Before terminating, the <TT>&quot;import&quot;</TT> function must explicitly install the
filter by calling <TT>&quot;filter_add&quot;</TT>.
<P>

<B></B>filter_add()<B></B>
<P>

The function, <TT>&quot;filter_add&quot;</TT>, actually installs the filter. It takes one
parameter which should be a reference. The kind of reference used will
dictate which of the two filter types will be used.
<P>

If a <FONT SIZE="-1">CODE</FONT> reference is used then a <I>closure filter</I> will be assumed.
<P>

If a <FONT SIZE="-1">CODE</FONT> reference is not used, a <I>method filter</I> will be assumed.
In a <I>method filter</I>, the reference can be used to store context
information. The reference will be <I>blessed</I> into the package by
<TT>&quot;filter_add&quot;</TT>.
<P>

See the filters at the end of this documents for examples of using
context information using both <I>method filters</I> and <I>closure
filters</I>.
<A NAME="lbAG">&nbsp;</A>
<H3><B></B>filter()<B> and anonymous sub</B></H3>

<A NAME="ixAAG"></A>
Both the <TT>&quot;filter&quot;</TT> method used with a <I>method filter</I> and the
anonymous sub used with a <I>closure filter</I> is where the main
processing for the filter is done.
<P>

The big difference between the two types of filter is that the <I>method
filter</I> uses the object passed to the method to store any context data,
whereas the <I>closure filter</I> uses the lexical variables that are
maintained by the closure.
<P>

Note that the single parameter passed to the <I>method filter</I>,
<TT>$self</TT>, is the same reference that was passed to <TT>&quot;filter_add&quot;</TT>
blessed into the filter's package. See the example filters later on for
details of using <TT>$self</TT>.
<P>

Here is a list of the common features of the anonymous sub and the
<TT>&quot;filter()&quot;</TT> method.
<DL COMPACT>
<DT><B>$_</B><DD>


<A NAME="ixAAH"></A>
Although <TT>$_</TT> doesn't actually appear explicitly in the sample filters
above, it is implicitly used in a number of places.


<P>


Firstly, when either <TT>&quot;filter&quot;</TT> or the anonymous sub are called, a local
copy of <TT>$_</TT> will automatically be created. It will always contain the
empty string at this point.


<P>


Next, both <TT>&quot;filter_read&quot;</TT> and <TT>&quot;filter_read_exact&quot;</TT> will append any
source data that is read to the end of <TT>$_</TT>.


<P>


Finally, when <TT>&quot;filter&quot;</TT> or the anonymous sub are finished processing,
they are expected to return the filtered source using <TT>$_</TT>.


<P>


This implicit use of <TT>$_</TT> greatly simplifies the filter.
<DT><B>$status</B><DD>


<A NAME="ixAAI"></A>
The status value that is returned by the user's <TT>&quot;filter&quot;</TT> method or
anonymous sub and the <TT>&quot;filter_read&quot;</TT> and <TT>&quot;read_exact&quot;</TT> functions take
the same set of values, namely:


<P>




<PRE>
    &lt; 0  Error
    = 0  EOF
    &gt; 0  OK

</PRE>


<DT><B>filter_read</B> and <B>filter_read_exact</B><DD>
<A NAME="ixAAJ"></A>
These functions are used by the filter to obtain either a line or block
from the next filter in the chain or the actual source file if there
aren't any other filters.


<P>


The function <TT>&quot;filter_read&quot;</TT> takes two forms:


<P>




<PRE>
    $status = filter_read() ;
    $status = filter_read($size) ;

</PRE>




<P>


The first form is used to request a <I>line</I>, the second requests a
<I>block</I>.


<P>


In line mode, <TT>&quot;filter_read&quot;</TT> will append the next source line to the
end of the <TT>$_</TT> scalar.


<P>


In block mode, <TT>&quot;filter_read&quot;</TT> will append a block of data which is &lt;=
<TT>$size</TT> to the end of the <TT>$_</TT> scalar. It is important to emphasise
the that <TT>&quot;filter_read&quot;</TT> will not necessarily read a block which is
<I>precisely</I> <TT>$size</TT> bytes.


<P>


If you need to be able to read a block which has an exact size, you can
use the function <TT>&quot;filter_read_exact&quot;</TT>. It works identically to
<TT>&quot;filter_read&quot;</TT> in block mode, except it will try to read a block which
is exactly <TT>$size</TT> bytes in length. The only circumstances when it
will not return a block which is <TT>$size</TT> bytes long is on <FONT SIZE="-1">EOF</FONT> or
error.


<P>


It is <I>very</I> important to check the value of <TT>$status</TT> after <I>every</I>
call to <TT>&quot;filter_read&quot;</TT> or <TT>&quot;filter_read_exact&quot;</TT>.
<DT><B>filter_del</B><DD>
<A NAME="ixAAK"></A>
The function, <TT>&quot;filter_del&quot;</TT>, is used to disable the current filter. It
does not affect the running of the filter. All it does is tell Perl not
to call filter any more.


<P>


See ``Example 4: Using filter_del'' for details.
</DL>
<A NAME="lbAH">&nbsp;</A>
<H2>EXAMPLES</H2>

<A NAME="ixAAL"></A>
Here are a few examples which illustrate the key concepts - as such
most of them are of little practical use.
<P>

The <TT>&quot;examples&quot;</TT> sub-directory has copies of all these filters
implemented both as <I>method filters</I> and as <I>closure filters</I>.
<A NAME="lbAI">&nbsp;</A>
<H3>Example 1: A simple filter.</H3>

<A NAME="ixAAM"></A>
Below is a <I>method filter</I> which is hard-wired to replace all
occurrences of the string <TT>&quot;Joe&quot;</TT> to <TT>&quot;Jim&quot;</TT>. Not particularly
Useful, but it is the first example and I wanted to keep it simple.
<P>



<PRE>
    package Joe2Jim ;

    use Filter::Util::Call ;

    sub import
    {
        my($type) = @_ ;

        filter_add(bless []) ;
    }

    sub filter
    {
        my($self) = @_ ;
        my($status) ;

        s/Joe/Jim/g
            if ($status = filter_read()) &gt; 0 ;
        $status ;
    }

    1 ;

</PRE>


<P>

Here is an example of using the filter:
<P>



<PRE>
    use Joe2Jim ;
    print &quot;Where is Joe?\n&quot; ;

</PRE>


<P>

And this is what the script above will print:
<P>



<PRE>
    Where is Jim?

</PRE>


<A NAME="lbAJ">&nbsp;</A>
<H3>Example 2: Using the context</H3>

<A NAME="ixAAN"></A>
The previous example was not particularly useful. To make it more
general purpose we will make use of the context data and allow any
arbitrary <I>from</I> and <I>to</I> strings to be used. This time we will use a
<I>closure filter</I>. To reflect its enhanced role, the filter is called
<TT>&quot;Subst&quot;</TT>.
<P>



<PRE>
    package Subst ;

    use Filter::Util::Call ;
    use Carp ;

    sub import
    {
        croak(&quot;usage: use Subst qw(from to)&quot;)
            unless @_ == 3 ;
        my ($self, $from, $to) = @_ ;
        filter_add(
            sub 
            {
                my ($status) ;
                s/$from/$to/
                    if ($status = filter_read()) &gt; 0 ;
                $status ;
            })
    }
    1 ;

</PRE>


<P>

and is used like this:
<P>



<PRE>
    use Subst qw(Joe Jim) ;
    print &quot;Where is Joe?\n&quot; ;

</PRE>


<A NAME="lbAK">&nbsp;</A>
<H3>Example 3: Using the context within the filter</H3>

<A NAME="ixAAO"></A>
Here is a filter which a variation of the <TT>&quot;Joe2Jim&quot;</TT> filter. As well as
substituting all occurrences of <TT>&quot;Joe&quot;</TT> to <TT>&quot;Jim&quot;</TT> it keeps a count
of the number of substitutions made in the context object.
<P>

Once <FONT SIZE="-1">EOF</FONT> is detected (<TT>$status</TT> is zero) the filter will insert an
extra line into the source stream. When this extra line is executed it
will print a count of the number of substitutions actually made.
Note that <TT>$status</TT> is set to <TT>1</TT> in this case.
<P>



<PRE>
    package Count ;

    use Filter::Util::Call ;

    sub filter
    {
        my ($self) = @_ ;
        my ($status) ;

        if (($status = filter_read()) &gt; 0 ) {
            s/Joe/Jim/g ;
            ++ $$self ;
        }
        elsif ($$self &gt;= 0) { # EOF
            $_ = &quot;print q[Made ${$self} substitutions\n]&quot; ;
            $status = 1 ;
            $$self = -1 ;
        }

        $status ;
    }

    sub import
    {
        my ($self) = @_ ;
        my ($count) = 0 ;
        filter_add(\$count) ;
    }

    1 ;

</PRE>


<P>

Here is a script which uses it:
<P>



<PRE>
    use Count ;
    print &quot;Hello Joe\n&quot; ;
    print &quot;Where is Joe\n&quot; ;

</PRE>


<P>

Outputs:
<P>



<PRE>
    Hello Jim
    Where is Jim
    Made 2 substitutions

</PRE>


<A NAME="lbAL">&nbsp;</A>
<H3>Example 4: Using filter_del</H3>

<A NAME="ixAAP"></A>
Another variation on a theme. This time we will modify the <TT>&quot;Subst&quot;</TT>
filter to allow a starting and stopping pattern to be specified as well
as the <I>from</I> and <I>to</I> patterns. If you know the <I>vi</I> editor, it is
the equivalent of this command:
<P>



<PRE>
    :/start/,/stop/s/from/to/

</PRE>


<P>

When used as a filter we want to invoke it like this:
<P>



<PRE>
    use NewSubst qw(start stop from to) ;

</PRE>


<P>

Here is the module.
<P>



<PRE>
    package NewSubst ;

    use Filter::Util::Call ;
    use Carp ;

    sub import
    {
        my ($self, $start, $stop, $from, $to) = @_ ;
        my ($found) = 0 ;
        croak(&quot;usage: use Subst qw(start stop from to)&quot;)
            unless @_ == 5 ;

        filter_add( 
            sub 
            {
                my ($status) ;

                if (($status = filter_read()) &gt; 0) {

                    $found = 1
                        if $found == 0 and /$start/ ;

                    if ($found) {
                        s/$from/$to/ ;
                        filter_del() if /$stop/ ;
                    }

                }
                $status ;
            } )

    }

    1 ;

</PRE>


<A NAME="lbAM">&nbsp;</A>
<H2>Filter::Simple</H2>

<A NAME="ixAAQ"></A>
If you intend using the Filter::Call functionality, I would strongly
recommend that you check out Damian Conway's excellent Filter::Simple
module. Damian's module provides a much cleaner interface than
Filter::Util::Call. Although it doesn't allow the fine control that
Filter::Util::Call does, it should be adequate for the majority of
applications. It's available at
<P>



<PRE>
   <A HREF="http://www.cpan.org/modules/by-author/Damian_Conway/Filter-Simple.tar.gz">http://www.cpan.org/modules/by-author/Damian_Conway/Filter-Simple.tar.gz</A>
   <A HREF="http://www.csse.monash.edu.au/~damian/CPAN/Filter-Simple.tar.gz">http://www.csse.monash.edu.au/~damian/CPAN/Filter-Simple.tar.gz</A>

</PRE>


<A NAME="lbAN">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixAAR"></A>
Paul Marquess
<A NAME="lbAO">&nbsp;</A>
<H2>DATE</H2>

<A NAME="ixAAS"></A>
26th January 1996
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE"><B>use Filter::Util::Call</B></A><DD>
<DT><A HREF="#lbAF"><B></B>import()<B></B></A><DD>
<DT><A HREF="#lbAG"><B></B>filter()<B> and anonymous sub</B></A><DD>
</DL>
<DT><A HREF="#lbAH">EXAMPLES</A><DD>
<DL>
<DT><A HREF="#lbAI">Example 1: A simple filter.</A><DD>
<DT><A HREF="#lbAJ">Example 2: Using the context</A><DD>
<DT><A HREF="#lbAK">Example 3: Using the context within the filter</A><DD>
<DT><A HREF="#lbAL">Example 4: Using filter_del</A><DD>
</DL>
<DT><A HREF="#lbAM">Filter::Simple</A><DD>
<DT><A HREF="#lbAN">AUTHOR</A><DD>
<DT><A HREF="#lbAO">DATE</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:27 GMT, December 24, 2015
</div></body>
</HTML>
