<!DOCTYPE html>

<HTML><head><TITLE>Manpage of Term::ReadLine</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"documentation"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>Term::ReadLine</H1>
Section: Perl Programmers Reference Guide (3pm)<BR>Updated: 2009-07-03<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Term::ReadLine - Perl interface to various <TT>&quot;readline&quot;</TT> packages.
If no real package is found, substitutes stubs instead of basic functions.
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
  use Term::ReadLine;
  my $term = Term::ReadLine-&gt;new('Simple Perl calc');
  my $prompt = &quot;Enter your arithmetic expression: &quot;;
  my $OUT = $term-&gt;OUT || \*STDOUT;
  while ( defined ($_ = $term-&gt;readline($prompt)) ) {
    my $res = eval($_);
    warn $@ if $@;
    print $OUT $res, &quot;\n&quot; unless $@;
    $term-&gt;addhistory($_) if /\S/;
  }

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
This package is just a front end to some other packages. It's a stub to
set up a common interface to the various ReadLine implementations found on
<FONT SIZE="-1">CPAN</FONT> (under the <TT>&quot;Term::ReadLine::*&quot;</TT> namespace).
<A NAME="lbAE">&nbsp;</A>
<H2>Minimal set of supported functions</H2>

<A NAME="ixAAE"></A>
All the supported functions should be called as methods, i.e., either as
<P>



<PRE>
  $term = Term::ReadLine-&gt;new('name');

</PRE>


<P>

or as
<P>



<PRE>
  $term-&gt;addhistory('row');

</PRE>


<P>

where <TT>$term</TT> is a return value of Term::ReadLine-&gt;<I>new()</I>.
<DL COMPACT>
<DT>ReadLine<DD>


<A NAME="ixAAF"></A>
returns the actual package that executes the commands. Among possible
values are <TT>&quot;Term::ReadLine::Gnu&quot;</TT>, <TT>&quot;Term::ReadLine::Perl&quot;</TT>,
<TT>&quot;Term::ReadLine::Stub&quot;</TT>.
<DT>new<DD>


<A NAME="ixAAG"></A>
returns the handle for subsequent calls to following
functions. Argument is the name of the application. Optionally can be
followed by two arguments for <TT>&quot;IN&quot;</TT> and <TT>&quot;OUT&quot;</TT> filehandles. These
arguments should be globs.
<DT>readline<DD>


<A NAME="ixAAH"></A>
gets an input line, <I>possibly</I> with actual <TT>&quot;readline&quot;</TT>
support. Trailing newline is removed. Returns <TT>&quot;undef&quot;</TT> on <TT>&quot;EOF&quot;</TT>.
<DT>addhistory<DD>


<A NAME="ixAAI"></A>
adds the line to the history of input, from where it can be used if
the actual <TT>&quot;readline&quot;</TT> is present.
<DT>IN, OUT<DD>


<A NAME="ixAAJ"></A>
return the filehandles for input and output or <TT>&quot;undef&quot;</TT> if <TT>&quot;readline&quot;</TT>
input and output cannot be used for Perl.
<DT>MinLine<DD>


<A NAME="ixAAK"></A>
If argument is specified, it is an advice on minimal size of line to
be included into history.  <TT>&quot;undef&quot;</TT> means do not include anything into
history. Returns the old value.
<DT>findConsole<DD>


<A NAME="ixAAL"></A>
returns an array with two strings that give most appropriate names for
files for input and output using conventions <TT>&quot;&lt;$in&quot;</TT>, <TT>&quot;&gt;out&quot;</TT>.
<DT>Attribs<DD>
<A NAME="ixAAM"></A>
returns a reference to a hash which describes internal configuration
of the package. Names of keys in this hash conform to standard
conventions with the leading <TT>&quot;rl_&quot;</TT> stripped.
<DT>Features<DD>


<A NAME="ixAAN"></A>
Returns a reference to a hash with keys being features present in
current implementation. Several optional features are used in the
minimal interface: <TT>&quot;appname&quot;</TT> should be present if the first argument
to <TT>&quot;new&quot;</TT> is recognized, and <TT>&quot;minline&quot;</TT> should be present if
<TT>&quot;MinLine&quot;</TT> method is not dummy.  <TT>&quot;autohistory&quot;</TT> should be present if
lines are put into history automatically (maybe subject to
<TT>&quot;MinLine&quot;</TT>), and <TT>&quot;addhistory&quot;</TT> if <TT>&quot;addhistory&quot;</TT> method is not dummy.


<P>


If <TT>&quot;Features&quot;</TT> method reports a feature <TT>&quot;attribs&quot;</TT> as present, the
method <TT>&quot;Attribs&quot;</TT> is not dummy.
</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>Additional supported functions</H2>

<A NAME="ixAAO"></A>
Actually <TT>&quot;Term::ReadLine&quot;</TT> can use some other package, that will
support a richer set of commands.
<P>

All these commands are callable via method interface and have names
which conform to standard conventions with the leading <TT>&quot;rl_&quot;</TT> stripped.
<P>

The stub package included with the perl distribution allows some
additional methods:
<DL COMPACT>
<DT>tkRunning<DD>


<A NAME="ixAAP"></A>
makes Tk event loop run when waiting for user input (i.e., during
<TT>&quot;readline&quot;</TT> method).
<DT>ornaments<DD>


<A NAME="ixAAQ"></A>
makes the command line stand out by using termcap data.  The argument
to <TT>&quot;ornaments&quot;</TT> should be 0, 1, or a string of a form
<TT>&quot;aa,bb,cc,dd&quot;</TT>.  Four components of this string should be names of
<I>terminal capacities</I>, first two will be issued to make the prompt
standout, last two to make the input line standout.
<DT>newTTY<DD>


<A NAME="ixAAR"></A>
takes two arguments which are input filehandle and output filehandle.
Switches to use these filehandles.
</DL>
<P>

One can check whether the currently loaded ReadLine package supports
these methods by checking for corresponding <TT>&quot;Features&quot;</TT>.
<A NAME="lbAG">&nbsp;</A>
<H2>EXPORTS</H2>

<A NAME="ixAAS"></A>
None
<A NAME="lbAH">&nbsp;</A>
<H2>ENVIRONMENT</H2>

<A NAME="ixAAT"></A>
The environment variable <TT>&quot;PERL_RL&quot;</TT> governs which ReadLine clone is
loaded. If the value is false, a dummy interface is used. If the value
is true, it should be tail of the name of the package to use, such as
<TT>&quot;Perl&quot;</TT> or <TT>&quot;Gnu&quot;</TT>.
<P>

As a special case, if the value of this variable is space-separated,
the tail might be used to disable the ornaments by setting the tail to
be <TT>&quot;o=0&quot;</TT> or <TT>&quot;ornaments=0&quot;</TT>.  The head should be as described above, say
<P>

If the variable is not set, or if the head of space-separated list is
empty, the best available package is loaded.
<P>



<PRE>
  export &quot;PERL_RL=Perl o=0&quot;     # Use Perl ReadLine without ornaments
  export &quot;PERL_RL= o=0&quot;         # Use best available ReadLine without ornaments

</PRE>


<P>

(Note that processing of <TT>&quot;PERL_RL&quot;</TT> for ornaments is in the discretion of the 
particular used <TT>&quot;Term::ReadLine::*&quot;</TT> package).
<A NAME="lbAI">&nbsp;</A>
<H2>CAVEATS</H2>

<A NAME="ixAAU"></A>
It seems that using Term::ReadLine from Emacs minibuffer doesn't work
quite right and one will get an error message like
<P>



<PRE>
    Cannot open /dev/tty for read at ...

</PRE>


<P>

One possible workaround for this is to explicitly open /dev/tty like this
<P>



<PRE>
    open (FH, &quot;/dev/tty&quot; )
      or eval 'sub Term::ReadLine::findConsole { (&quot;&amp;STDIN&quot;, &quot;&amp;STDERR&quot;) }';
    die $@ if $@;
    close (FH);

</PRE>


<P>

or you can try using the 4-argument form of Term::ReadLine-&gt;<I>new()</I>.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">Minimal set of supported functions</A><DD>
<DT><A HREF="#lbAF">Additional supported functions</A><DD>
<DT><A HREF="#lbAG">EXPORTS</A><DD>
<DT><A HREF="#lbAH">ENVIRONMENT</A><DD>
<DT><A HREF="#lbAI">CAVEATS</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:43 GMT, December 24, 2015
</div></div>
</body>
</HTML>
