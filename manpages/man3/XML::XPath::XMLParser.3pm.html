<!DOCTYPE html>

<HTML><head><TITLE>Manpage of XPath::XMLParser</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux man pages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>XPath::XMLParser</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2001-03-14<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

XML::XPath::XMLParser - The default XML parsing class that produces a node tree
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
    my $parser = XML::XPath::XMLParser-&gt;new(
                filename =&gt; $self-&gt;get_filename,
                xml =&gt; $self-&gt;get_xml,
                ioref =&gt; $self-&gt;get_ioref,
                parser =&gt; $self-&gt;get_parser,
            );
    my $root_node = $parser-&gt;parse;

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
This module generates a node tree for use as the context node for XPath processing.
It aims to be a quick parser, nothing fancy, and yet has to store more information
than most parsers. To achieve this I've used array refs everywhere - no hashes.
I don't have any performance figures for the speedups achieved, so I make no
appologies for anyone not used to using arrays instead of hashes. I think they
make good sense here where we know the attributes of each type of node.
<A NAME="lbAE">&nbsp;</A>
<H2>Node Structure</H2>

<A NAME="ixAAE"></A>
All nodes have the same first 2 entries in the array: node_parent
and node_pos. The type of the node is determined using the <I>ref()</I> function.
The node_parent always contains an entry for the parent of the current
node - except for the root node which has undef in there. And node_pos is the
position of this node in the array that it is in (think: 
<TT>$node</TT> == <TT>$node</TT>-&gt;[node_parent]-&gt;[node_children]-&gt;[$node-&gt;[node_pos]] )
<P>

Nodes are structured as follows:
<A NAME="lbAF">&nbsp;</A>
<H3>Root Node</H3>

<A NAME="ixAAF"></A>
The root node is just an element node with no parent.
<P>



<PRE>
    [
      undef, # node_parent - check for undef to identify root node
      undef, # node_pos
      undef, # node_prefix
      [ ... ], # node_children (see below)
    ]

</PRE>


<A NAME="lbAG">&nbsp;</A>
<H3>Element Node</H3>

<A NAME="ixAAG"></A>


<PRE>
    [
      $parent, # node_parent
      &lt;position in current array&gt;, # node_pos
      'xxx', # node_prefix - namespace prefix on this element
      [ ... ], # node_children
      'yyy', # node_name - element tag name
      [ ... ], # node_attribs - attributes on this element
      [ ... ], # node_namespaces - namespaces currently in scope
    ]

</PRE>


<A NAME="lbAH">&nbsp;</A>
<H3>Attribute Node</H3>

<A NAME="ixAAH"></A>


<PRE>
    [
      $parent, # node_parent - the element node
      &lt;position in current array&gt;, # node_pos
      'xxx', # node_prefix - namespace prefix on this element
      'href', # node_key - attribute name
      '<A HREF="ftp://ftp.com/',">ftp://ftp.com/',</A> # node_value - value in the node
    ]

</PRE>


<A NAME="lbAI">&nbsp;</A>
<H3>Namespace Nodes</H3>

<A NAME="ixAAI"></A>
Each element has an associated set of namespace nodes that are currently
in scope. Each namespace node stores a prefix and the expanded name (retrieved
from the xmlns:prefix=``...'' attribute).
<P>



<PRE>
    [
      $parent,
      &lt;pos&gt;,
      'a', # node_prefix - the namespace as it was written as a prefix
      '<A HREF="http://my.namespace.com',">http://my.namespace.com',</A> # node_expanded - the expanded name.
    ]

</PRE>


<A NAME="lbAJ">&nbsp;</A>
<H3>Text Nodes</H3>

<A NAME="ixAAJ"></A>


<PRE>
    [
      $parent,
      &lt;pos&gt;,
      'This is some text' # node_text - the text in the node
    ]

</PRE>


<A NAME="lbAK">&nbsp;</A>
<H3>Comment Nodes</H3>

<A NAME="ixAAK"></A>


<PRE>
    [
      $parent,
      &lt;pos&gt;,
      'This is a comment' # node_comment
    ]

</PRE>


<A NAME="lbAL">&nbsp;</A>
<H3>Processing Instruction Nodes</H3>

<A NAME="ixAAL"></A>


<PRE>
    [
      $parent,
      &lt;pos&gt;,
      'target', # node_target
      'data', # node_data
    ]

</PRE>


<A NAME="lbAM">&nbsp;</A>
<H2>Usage</H2>

<A NAME="ixAAM"></A>
If you feel the need to use this module outside of XML::XPath (for example
you might use this module directly so that you can cache parsed trees), you
can follow the following <FONT SIZE="-1">API:</FONT>
<A NAME="lbAN">&nbsp;</A>
<H3>new</H3>

<A NAME="ixAAN"></A>
The new method takes either no parameters, or any of the following parameters:
<P>



<PRE>
        filename
        xml
        parser
        ioref

</PRE>


<P>

This uses the familiar hash syntax, so an example might be:
<P>



<PRE>
    use XML::XPath::XMLParser;
    
    my $parser = XML::XPath::XMLParser-&gt;new(filename =&gt; 'example.xml');

</PRE>


<P>

The parameters represent a filename, a string containing <FONT SIZE="-1">XML</FONT>, an XML::Parser
instance and an open filehandle ref respectively. You can also set or get all
of these properties using the get_ and set_ functions that have the same
name as the property: e.g. get_filename, set_ioref, etc.
<A NAME="lbAO">&nbsp;</A>
<H3>parse</H3>

<A NAME="ixAAO"></A>
The parse method generally takes no parameters, however you are free to
pass either an open filehandle reference or an <FONT SIZE="-1">XML</FONT> string if you so require.
The return value is a tree that XML::XPath can use. The parse method will
die if there is an error in your <FONT SIZE="-1">XML</FONT>, so be sure to use perl's exception
handling mechanism (eval{};) if you want to avoid this.
<A NAME="lbAP">&nbsp;</A>
<H3>parsefile</H3>

<A NAME="ixAAP"></A>
The parsefile method is identical to <I>parse()</I> except it expects a single
parameter that is a string naming a file to open and parse. Again it
returns a tree and also dies if there are <FONT SIZE="-1">XML</FONT> errors.
<A NAME="lbAQ">&nbsp;</A>
<H2>NOTICES</H2>

<A NAME="ixAAQ"></A>
This file is distributed as part of the XML::XPath module, and is copyright
2000 Fastnet Software Ltd. Please see the documentation for the module as a
whole for licencing information.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">Node Structure</A><DD>
<DL>
<DT><A HREF="#lbAF">Root Node</A><DD>
<DT><A HREF="#lbAG">Element Node</A><DD>
<DT><A HREF="#lbAH">Attribute Node</A><DD>
<DT><A HREF="#lbAI">Namespace Nodes</A><DD>
<DT><A HREF="#lbAJ">Text Nodes</A><DD>
<DT><A HREF="#lbAK">Comment Nodes</A><DD>
<DT><A HREF="#lbAL">Processing Instruction Nodes</A><DD>
</DL>
<DT><A HREF="#lbAM">Usage</A><DD>
<DL>
<DT><A HREF="#lbAN">new</A><DD>
<DT><A HREF="#lbAO">parse</A><DD>
<DT><A HREF="#lbAP">parsefile</A><DD>
</DL>
<DT><A HREF="#lbAQ">NOTICES</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:46 GMT, December 24, 2015
</div></body>
</HTML>
