<!DOCTYPE html>

<HTML><head><TITLE>Manpage of EVP_EncryptInit</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux man pages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>EVP_EncryptInit</H1>
Section: OpenSSL (3)<BR>Updated: 2012-08-23<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

EVP_CIPHER_CTX_init, EVP_EncryptInit_ex, EVP_EncryptUpdate,
EVP_EncryptFinal_ex, EVP_DecryptInit_ex, EVP_DecryptUpdate,
EVP_DecryptFinal_ex, EVP_CipherInit_ex, EVP_CipherUpdate,
EVP_CipherFinal_ex, EVP_CIPHER_CTX_set_key_length,
EVP_CIPHER_CTX_ctrl, EVP_CIPHER_CTX_cleanup, EVP_EncryptInit,
EVP_EncryptFinal, EVP_DecryptInit, EVP_DecryptFinal,
EVP_CipherInit, EVP_CipherFinal, EVP_get_cipherbyname,
EVP_get_cipherbynid, EVP_get_cipherbyobj, EVP_CIPHER_nid,
EVP_CIPHER_block_size, EVP_CIPHER_key_length, EVP_CIPHER_iv_length,
EVP_CIPHER_flags, EVP_CIPHER_mode, EVP_CIPHER_type, EVP_CIPHER_CTX_cipher,
EVP_CIPHER_CTX_nid, EVP_CIPHER_CTX_block_size, EVP_CIPHER_CTX_key_length,
EVP_CIPHER_CTX_iv_length, EVP_CIPHER_CTX_get_app_data,
EVP_CIPHER_CTX_set_app_data, EVP_CIPHER_CTX_type, EVP_CIPHER_CTX_flags,
EVP_CIPHER_CTX_mode, EVP_CIPHER_param_to_asn1, EVP_CIPHER_asn1_to_param,
EVP_CIPHER_CTX_set_padding - EVP cipher routines
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
 #include &lt;<A HREF="file:/usr/include/openssl/evp.h">openssl/evp.h</A>&gt;

 void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);

 int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         ENGINE *impl, unsigned char *key, unsigned char *iv);
 int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
 int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl);

 int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         ENGINE *impl, unsigned char *key, unsigned char *iv);
 int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
 int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);

 int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         ENGINE *impl, unsigned char *key, unsigned char *iv, int enc);
 int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
 int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);

 int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         unsigned char *key, unsigned char *iv);
 int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl);

 int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         unsigned char *key, unsigned char *iv);
 int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);

 int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         unsigned char *key, unsigned char *iv, int enc);
 int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);

 int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);
 int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);
 int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
 int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);

 const EVP_CIPHER *EVP_get_cipherbyname(const char *name);
 #define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))
 #define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))

 #define EVP_CIPHER_nid(e)              ((e)-&gt;nid)
 #define EVP_CIPHER_block_size(e)       ((e)-&gt;block_size)
 #define EVP_CIPHER_key_length(e)       ((e)-&gt;key_len)
 #define EVP_CIPHER_iv_length(e)                ((e)-&gt;iv_len)
 #define EVP_CIPHER_flags(e)            ((e)-&gt;flags)
 #define EVP_CIPHER_mode(e)             ((e)-&gt;flags) &amp; EVP_CIPH_MODE)
 int EVP_CIPHER_type(const EVP_CIPHER *ctx);

 #define EVP_CIPHER_CTX_cipher(e)       ((e)-&gt;cipher)
 #define EVP_CIPHER_CTX_nid(e)          ((e)-&gt;cipher-&gt;nid)
 #define EVP_CIPHER_CTX_block_size(e)   ((e)-&gt;cipher-&gt;block_size)
 #define EVP_CIPHER_CTX_key_length(e)   ((e)-&gt;key_len)
 #define EVP_CIPHER_CTX_iv_length(e)    ((e)-&gt;cipher-&gt;iv_len)
 #define EVP_CIPHER_CTX_get_app_data(e) ((e)-&gt;app_data)
 #define EVP_CIPHER_CTX_set_app_data(e,d) ((e)-&gt;app_data=(char *)(d))
 #define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))
 #define EVP_CIPHER_CTX_flags(e)                ((e)-&gt;cipher-&gt;flags)
 #define EVP_CIPHER_CTX_mode(e)         ((e)-&gt;cipher-&gt;flags &amp; EVP_CIPH_MODE)

 int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
 int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);

 const EVP_CIPHER *EVP_des_ede3(void);
 const EVP_CIPHER *EVP_des_ede3_ecb(void);
 const EVP_CIPHER *EVP_des_ede3_cfb64(void);
 const EVP_CIPHER *EVP_des_ede3_cfb1(void);
 const EVP_CIPHER *EVP_des_ede3_cfb8(void);
 const EVP_CIPHER *EVP_des_ede3_ofb(void);
 const EVP_CIPHER *EVP_des_ede3_cbc(void);
 const EVP_CIPHER *EVP_aes_128_ecb(void);
 const EVP_CIPHER *EVP_aes_128_cbc(void);
 const EVP_CIPHER *EVP_aes_128_cfb1(void);
 const EVP_CIPHER *EVP_aes_128_cfb8(void);
 const EVP_CIPHER *EVP_aes_128_cfb128(void);
 const EVP_CIPHER *EVP_aes_128_ofb(void);
 const EVP_CIPHER *EVP_aes_192_ecb(void);
 const EVP_CIPHER *EVP_aes_192_cbc(void);
 const EVP_CIPHER *EVP_aes_192_cfb1(void);
 const EVP_CIPHER *EVP_aes_192_cfb8(void);
 const EVP_CIPHER *EVP_aes_192_cfb128(void);
 const EVP_CIPHER *EVP_aes_192_ofb(void);
 const EVP_CIPHER *EVP_aes_256_ecb(void);
 const EVP_CIPHER *EVP_aes_256_cbc(void);
 const EVP_CIPHER *EVP_aes_256_cfb1(void);
 const EVP_CIPHER *EVP_aes_256_cfb8(void);
 const EVP_CIPHER *EVP_aes_256_cfb128(void);
 const EVP_CIPHER *EVP_aes_256_ofb(void);

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
The <FONT SIZE="-1">EVP</FONT> cipher routines are a high level interface to certain
symmetric ciphers.
<P>

<I>EVP_CIPHER_CTX_init()</I> initializes cipher contex <B>ctx</B>.
<P>

<I>EVP_EncryptInit_ex()</I> sets up cipher context <B>ctx</B> for encryption
with cipher <B>type</B> from <FONT SIZE="-1">ENGINE</FONT> <B>impl</B>. <B>ctx</B> must be initialized
before calling this function. <B>type</B> is normally supplied
by a function such as <I>EVP_des_cbc()</I>. If <B>impl</B> is <FONT SIZE="-1">NULL</FONT> then the
default implementation is used. <B>key</B> is the symmetric key to use
and <B>iv</B> is the <FONT SIZE="-1">IV</FONT> to use (if necessary), the actual number of bytes
used for the key and <FONT SIZE="-1">IV</FONT> depends on the cipher. It is possible to set
all parameters to <FONT SIZE="-1">NULL</FONT> except <B>type</B> in an initial call and supply
the remaining parameters in subsequent calls, all of which have <B>type</B>
set to <FONT SIZE="-1">NULL</FONT>. This is done when the default cipher parameters are not
appropriate.
<P>

<I>EVP_EncryptUpdate()</I> encrypts <B>inl</B> bytes from the buffer <B>in</B> and
writes the encrypted version to <B>out</B>. This function can be called
multiple times to encrypt successive blocks of data. The amount
of data written depends on the block alignment of the encrypted data:
as a result the amount of data written may be anything from zero bytes
to (inl + cipher_block_size - 1) so <B>outl</B> should contain sufficient
room. The actual number of bytes written is placed in <B>outl</B>.
<P>

If padding is enabled (the default) then <I>EVP_EncryptFinal_ex()</I> encrypts
the ``final'' data, that is any data that remains in a partial block.
It uses standard block padding (aka <FONT SIZE="-1">PKCS</FONT> padding). The encrypted
final data is written to <B>out</B> which should have sufficient space for
one cipher block. The number of bytes written is placed in <B>outl</B>. After
this function is called the encryption operation is finished and no further
calls to <I>EVP_EncryptUpdate()</I> should be made.
<P>

If padding is disabled then <I>EVP_EncryptFinal_ex()</I> will not encrypt any more
data and it will return an error if any data remains in a partial block:
that is if the total data length is not a multiple of the block size.
<P>

<I>EVP_DecryptInit_ex()</I>, <I>EVP_DecryptUpdate()</I> and <I>EVP_DecryptFinal_ex()</I> are the
corresponding decryption operations. <I>EVP_DecryptFinal()</I> will return an
error code if padding is enabled and the final block is not correctly
formatted. The parameters and restrictions are identical to the encryption
operations except that if padding is enabled the decrypted data buffer <B>out</B>
passed to <I>EVP_DecryptUpdate()</I> should have sufficient room for
(<B>inl</B> + cipher_block_size) bytes unless the cipher block size is 1 in
which case <B>inl</B> bytes is sufficient.
<P>

<I>EVP_CipherInit_ex()</I>, <I>EVP_CipherUpdate()</I> and <I>EVP_CipherFinal_ex()</I> are
functions that can be used for decryption or encryption. The operation
performed depends on the value of the <B>enc</B> parameter. It should be set
to 1 for encryption, 0 for decryption and -1 to leave the value unchanged
(the actual value of 'enc' being supplied in a previous call).
<P>

<I>EVP_CIPHER_CTX_cleanup()</I> clears all information from a cipher context
and free up any allocated memory associate with it. It should be called
after all operations using a cipher are complete so sensitive information
does not remain in memory.
<P>

<I>EVP_EncryptInit()</I>, <I>EVP_DecryptInit()</I> and <I>EVP_CipherInit()</I> behave in a
similar way to <I>EVP_EncryptInit_ex()</I>, EVP_DecryptInit_ex and
<I>EVP_CipherInit_ex()</I> except the <B>ctx</B> paramter does not need to be
initialized and they always use the default cipher implementation.
<P>

<I>EVP_EncryptFinal()</I>, <I>EVP_DecryptFinal()</I> and <I>EVP_CipherFinal()</I> behave in a
similar way to <I>EVP_EncryptFinal_ex()</I>, <I>EVP_DecryptFinal_ex()</I> and
<I>EVP_CipherFinal_ex()</I> except <B>ctx</B> is automatically cleaned up 
after the call.
<P>

<I>EVP_get_cipherbyname()</I>, <I>EVP_get_cipherbynid()</I> and <I>EVP_get_cipherbyobj()</I>
return an <FONT SIZE="-1">EVP_CIPHER</FONT> structure when passed a cipher name, a <FONT SIZE="-1">NID</FONT> or an
<FONT SIZE="-1">ASN1_OBJECT</FONT> structure.
<P>

<I>EVP_CIPHER_nid()</I> and <I>EVP_CIPHER_CTX_nid()</I> return the <FONT SIZE="-1">NID</FONT> of a cipher when
passed an <B></B><FONT SIZE="-1"><B>EVP_CIPHER</B></FONT><B></B> or <B></B><FONT SIZE="-1"><B>EVP_CIPHER_CTX</B></FONT><B></B> structure.  The actual <FONT SIZE="-1">NID</FONT>
value is an internal value which may not have a corresponding <FONT SIZE="-1">OBJECT</FONT>
<FONT SIZE="-1">IDENTIFIER</FONT>.
<P>

<I>EVP_CIPHER_CTX_set_padding()</I> enables or disables padding. By default
encryption operations are padded using standard block padding and the
padding is checked and removed when decrypting. If the <B>pad</B> parameter
is zero then no padding is performed, the total amount of data encrypted
or decrypted must then be a multiple of the block size or an error will
occur.
<P>

<I>EVP_CIPHER_key_length()</I> and <I>EVP_CIPHER_CTX_key_length()</I> return the key
length of a cipher when passed an <B></B><FONT SIZE="-1"><B>EVP_CIPHER</B></FONT><B></B> or <B></B><FONT SIZE="-1"><B>EVP_CIPHER_CTX</B></FONT><B></B>
structure. The constant <B></B><FONT SIZE="-1"><B>EVP_MAX_KEY_LENGTH</B></FONT><B></B> is the maximum key length
for all ciphers. Note: although <I>EVP_CIPHER_key_length()</I> is fixed for a
given cipher, the value of <I>EVP_CIPHER_CTX_key_length()</I> may be different
for variable key length ciphers.
<P>

<I>EVP_CIPHER_CTX_set_key_length()</I> sets the key length of the cipher ctx.
If the cipher is a fixed length cipher then attempting to set the key
length to any value other than the fixed value is an error.
<P>

<I>EVP_CIPHER_iv_length()</I> and <I>EVP_CIPHER_CTX_iv_length()</I> return the <FONT SIZE="-1">IV</FONT>
length of a cipher when passed an <B></B><FONT SIZE="-1"><B>EVP_CIPHER</B></FONT><B></B> or <B></B><FONT SIZE="-1"><B>EVP_CIPHER_CTX</B></FONT><B></B>.
It will return zero if the cipher does not use an <FONT SIZE="-1">IV</FONT>.  The constant
<B></B><FONT SIZE="-1"><B>EVP_MAX_IV_LENGTH</B></FONT><B></B> is the maximum <FONT SIZE="-1">IV</FONT> length for all ciphers.
<P>

<I>EVP_CIPHER_block_size()</I> and <I>EVP_CIPHER_CTX_block_size()</I> return the block
size of a cipher when passed an <B></B><FONT SIZE="-1"><B>EVP_CIPHER</B></FONT><B></B> or <B></B><FONT SIZE="-1"><B>EVP_CIPHER_CTX</B></FONT><B></B>
structure. The constant <B></B><FONT SIZE="-1"><B>EVP_MAX_IV_LENGTH</B></FONT><B></B> is also the maximum block
length for all ciphers.
<P>

<I>EVP_CIPHER_type()</I> and <I>EVP_CIPHER_CTX_type()</I> return the type of the passed
cipher or context. This ``type'' is the actual <FONT SIZE="-1">NID</FONT> of the cipher <FONT SIZE="-1">OBJECT</FONT>
<FONT SIZE="-1">IDENTIFIER</FONT> as such it ignores the cipher parameters and 40 bit <FONT SIZE="-1">RC2</FONT> and
128 bit <FONT SIZE="-1">RC2</FONT> have the same <FONT SIZE="-1">NID</FONT>. If the cipher does not have an object
identifier or does not have <FONT SIZE="-1">ASN1</FONT> support this function will return
<B>NID_undef</B>.
<P>

<I>EVP_CIPHER_CTX_cipher()</I> returns the <B></B><FONT SIZE="-1"><B>EVP_CIPHER</B></FONT><B></B> structure when passed
an <B></B><FONT SIZE="-1"><B>EVP_CIPHER_CTX</B></FONT><B></B> structure.
<P>

<I>EVP_CIPHER_mode()</I> and <I>EVP_CIPHER_CTX_mode()</I> return the block cipher mode:
<FONT SIZE="-1">EVP_CIPH_ECB_MODE</FONT>, <FONT SIZE="-1">EVP_CIPH_CBC_MODE</FONT>, <FONT SIZE="-1">EVP_CIPH_CFB_MODE</FONT> or
<FONT SIZE="-1">EVP_CIPH_OFB_MODE</FONT>. If the cipher is a stream cipher then
<FONT SIZE="-1">EVP_CIPH_STREAM_CIPHER</FONT> is returned.
<P>

<I>EVP_CIPHER_param_to_asn1()</I> sets the AlgorithmIdentifier ``parameter'' based
on the passed cipher. This will typically include any parameters and an
<FONT SIZE="-1">IV</FONT>. The cipher <FONT SIZE="-1">IV</FONT> (if any) must be set when this call is made. This call
should be made before the cipher is actually ``used'' (before any
<I>EVP_EncryptUpdate()</I>, <I>EVP_DecryptUpdate()</I> calls for example). This function
may fail if the cipher does not have any <FONT SIZE="-1">ASN1</FONT> support.
<P>

<I>EVP_CIPHER_asn1_to_param()</I> sets the cipher parameters based on an <FONT SIZE="-1">ASN1</FONT>
AlgorithmIdentifier ``parameter''. The precise effect depends on the cipher
In the case of <FONT SIZE="-1">RC2</FONT>, for example, it will set the <FONT SIZE="-1">IV</FONT> and effective key length.
This function should be called after the base cipher type is set but before
the key is set. For example <I>EVP_CipherInit()</I> will be called with the <FONT SIZE="-1">IV</FONT> and
key set to <FONT SIZE="-1">NULL</FONT>, <I>EVP_CIPHER_asn1_to_param()</I> will be called and finally
<I>EVP_CipherInit()</I> again with all parameters except the key set to <FONT SIZE="-1">NULL</FONT>. It is
possible for this function to fail if the cipher does not have any <FONT SIZE="-1">ASN1</FONT> support
or the parameters cannot be set (for example the <FONT SIZE="-1">RC2</FONT> effective key length
is not supported.
<P>

<I>EVP_CIPHER_CTX_ctrl()</I> allows various cipher specific parameters to be determined
and set. Currently only the <FONT SIZE="-1">RC2</FONT> effective key length and the number of rounds of
<FONT SIZE="-1">RC5</FONT> can be set.
<A NAME="lbAE">&nbsp;</A>
<H2>RETURN VALUES</H2>

<A NAME="ixAAE"></A>
<I>EVP_EncryptInit_ex()</I>, <I>EVP_EncryptUpdate()</I> and <I>EVP_EncryptFinal_ex()</I>
return 1 for success and 0 for failure.
<P>

<I>EVP_DecryptInit_ex()</I> and <I>EVP_DecryptUpdate()</I> return 1 for success and 0 for failure.
<I>EVP_DecryptFinal_ex()</I> returns 0 if the decrypt failed or 1 for success.
<P>

<I>EVP_CipherInit_ex()</I> and <I>EVP_CipherUpdate()</I> return 1 for success and 0 for failure.
<I>EVP_CipherFinal_ex()</I> returns 0 for a decryption failure or 1 for success.
<P>

<I>EVP_CIPHER_CTX_cleanup()</I> returns 1 for success and 0 for failure.
<P>

<I>EVP_get_cipherbyname()</I>, <I>EVP_get_cipherbynid()</I> and <I>EVP_get_cipherbyobj()</I>
return an <B></B><FONT SIZE="-1"><B>EVP_CIPHER</B></FONT><B></B> structure or <FONT SIZE="-1">NULL</FONT> on error.
<P>

<I>EVP_CIPHER_nid()</I> and <I>EVP_CIPHER_CTX_nid()</I> return a <FONT SIZE="-1">NID</FONT>.
<P>

<I>EVP_CIPHER_block_size()</I> and <I>EVP_CIPHER_CTX_block_size()</I> return the block
size.
<P>

<I>EVP_CIPHER_key_length()</I> and <I>EVP_CIPHER_CTX_key_length()</I> return the key
length.
<P>

<I>EVP_CIPHER_CTX_set_padding()</I> always returns 1.
<P>

<I>EVP_CIPHER_iv_length()</I> and <I>EVP_CIPHER_CTX_iv_length()</I> return the <FONT SIZE="-1">IV</FONT>
length or zero if the cipher does not use an <FONT SIZE="-1">IV</FONT>.
<P>

<I>EVP_CIPHER_type()</I> and <I>EVP_CIPHER_CTX_type()</I> return the <FONT SIZE="-1">NID</FONT> of the cipher's
<FONT SIZE="-1">OBJECT</FONT> <FONT SIZE="-1">IDENTIFIER</FONT> or NID_undef if it has no defined <FONT SIZE="-1">OBJECT</FONT> <FONT SIZE="-1">IDENTIFIER</FONT>.
<P>

<I>EVP_CIPHER_CTX_cipher()</I> returns an <B></B><FONT SIZE="-1"><B>EVP_CIPHER</B></FONT><B></B> structure.
<P>

<I>EVP_CIPHER_param_to_asn1()</I> and <I>EVP_CIPHER_asn1_to_param()</I> return 1 for 
success or zero for failure.
<A NAME="lbAF">&nbsp;</A>
<H2>CIPHER LISTING</H2>

<A NAME="ixAAF"></A>
All algorithms have a fixed key length unless otherwise stated.
<DL COMPACT>
<DT><I>EVP_enc_null()</I><DD>
<A NAME="ixAAG"></A>
Null cipher: does nothing.
<DT>EVP_des_cbc(void), EVP_des_ecb(void), EVP_des_cfb(void), EVP_des_ofb(void)<DD>
<A NAME="ixAAH"></A>
<FONT SIZE="-1">DES</FONT> in <FONT SIZE="-1">CBC</FONT>, <FONT SIZE="-1">ECB</FONT>, <FONT SIZE="-1">CFB</FONT> and <FONT SIZE="-1">OFB</FONT> modes respectively.
<DT>EVP_des_ede_cbc(void), <I>EVP_des_ede()</I>, EVP_des_ede_ofb(void),  EVP_des_ede_cfb(void)<DD>
<A NAME="ixAAI"></A>
Two key triple <FONT SIZE="-1">DES</FONT> in <FONT SIZE="-1">CBC</FONT>, <FONT SIZE="-1">ECB</FONT>, <FONT SIZE="-1">CFB</FONT> and <FONT SIZE="-1">OFB</FONT> modes respectively.
<DT>EVP_des_ede3_cbc(void), <I>EVP_des_ede3()</I>, EVP_des_ede3_ofb(void),  EVP_des_ede3_cfb(void)<DD>
<A NAME="ixAAJ"></A>
Three key triple <FONT SIZE="-1">DES</FONT> in <FONT SIZE="-1">CBC</FONT>, <FONT SIZE="-1">ECB</FONT>, <FONT SIZE="-1">CFB</FONT> and <FONT SIZE="-1">OFB</FONT> modes respectively.
<DT>EVP_desx_cbc(void)<DD>
<A NAME="ixAAK"></A>
<FONT SIZE="-1">DESX</FONT> algorithm in <FONT SIZE="-1">CBC</FONT> mode.
<DT>EVP_aes_128_cbc(void), <I>EVP_aes_128_ecb()</I>, EVP_aes_128_ofb(void), EVP_aes_128_cfb1(void), EVP_aes_128_cfb8(void), EVP_aes_128_cfb128(void)<DD>
<A NAME="ixAAL"></A>
<FONT SIZE="-1">AES</FONT> with 128 bit key length in <FONT SIZE="-1">CBC</FONT>, <FONT SIZE="-1">ECB</FONT>, <FONT SIZE="-1">OFB</FONT> and <FONT SIZE="-1">CFB</FONT> modes respectively.
<DT>EVP_aes_192_cbc(void), <I>EVP_aes_192_ecb()</I>, EVP_aes_192_ofb(void), EVP_aes_192_cfb1(void), EVP_aes_192_cfb8(void), EVP_aes_192_cfb128(void)<DD>
<A NAME="ixAAM"></A>
<FONT SIZE="-1">AES</FONT> with 192 bit key length in <FONT SIZE="-1">CBC</FONT>, <FONT SIZE="-1">ECB</FONT>, <FONT SIZE="-1">OFB</FONT> and <FONT SIZE="-1">CFB</FONT> modes respectively.
<DT>EVP_aes_256_cbc(void), <I>EVP_aes_256_ecb()</I>, EVP_aes_256_ofb(void), EVP_aes_256_cfb1(void), EVP_aes_256_cfb8(void), EVP_aes_256_cfb128(void)<DD>
<A NAME="ixAAN"></A>
<FONT SIZE="-1">AES</FONT> with 256 bit key length in <FONT SIZE="-1">CBC</FONT>, <FONT SIZE="-1">ECB</FONT>, <FONT SIZE="-1">OFB</FONT> and <FONT SIZE="-1">CFB</FONT> modes respectively.
<DT>EVP_rc4(void)<DD>
<A NAME="ixAAO"></A>
<FONT SIZE="-1">RC4</FONT> stream cipher. This is a variable key length cipher with default key length 128 bits.
<DT>EVP_rc4_40(void)<DD>
<A NAME="ixAAP"></A>
<FONT SIZE="-1">RC4</FONT> stream cipher with 40 bit key length. This is obsolete and new code should use <I>EVP_rc4()</I>
and the <I>EVP_CIPHER_CTX_set_key_length()</I> function.
<DT><I>EVP_idea_cbc()</I> EVP_idea_ecb(void), EVP_idea_cfb(void), EVP_idea_ofb(void), EVP_idea_cbc(void)<DD>
<A NAME="ixAAQ"></A>
<FONT SIZE="-1">IDEA</FONT> encryption algorithm in <FONT SIZE="-1">CBC</FONT>, <FONT SIZE="-1">ECB</FONT>, <FONT SIZE="-1">CFB</FONT> and <FONT SIZE="-1">OFB</FONT> modes respectively.
<DT>EVP_rc2_cbc(void), EVP_rc2_ecb(void), EVP_rc2_cfb(void), EVP_rc2_ofb(void)<DD>
<A NAME="ixAAR"></A>
<FONT SIZE="-1">RC2</FONT> encryption algorithm in <FONT SIZE="-1">CBC</FONT>, <FONT SIZE="-1">ECB</FONT>, <FONT SIZE="-1">CFB</FONT> and <FONT SIZE="-1">OFB</FONT> modes respectively. This is a variable key
length cipher with an additional parameter called ``effective key bits'' or ``effective key length''.
By default both are set to 128 bits.
<DT>EVP_rc2_40_cbc(void), EVP_rc2_64_cbc(void)<DD>
<A NAME="ixAAS"></A>
<FONT SIZE="-1">RC2</FONT> algorithm in <FONT SIZE="-1">CBC</FONT> mode with a default key length and effective key length of 40 and 64 bits.
These are obsolete and new code should use <I>EVP_rc2_cbc()</I>, <I>EVP_CIPHER_CTX_set_key_length()</I> and
<I>EVP_CIPHER_CTX_ctrl()</I> to set the key length and effective key length.
<DT>EVP_bf_cbc(void), EVP_bf_ecb(void), EVP_bf_cfb(void), EVP_bf_ofb(void);<DD>
<A NAME="ixAAT"></A>
Blowfish encryption algorithm in <FONT SIZE="-1">CBC</FONT>, <FONT SIZE="-1">ECB</FONT>, <FONT SIZE="-1">CFB</FONT> and <FONT SIZE="-1">OFB</FONT> modes respectively. This is a variable key
length cipher.
<DT>EVP_cast5_cbc(void), EVP_cast5_ecb(void), EVP_cast5_cfb(void), EVP_cast5_ofb(void)<DD>
<A NAME="ixAAU"></A>
<FONT SIZE="-1">CAST</FONT> encryption algorithm in <FONT SIZE="-1">CBC</FONT>, <FONT SIZE="-1">ECB</FONT>, <FONT SIZE="-1">CFB</FONT> and <FONT SIZE="-1">OFB</FONT> modes respectively. This is a variable key
length cipher.
<DT>EVP_rc5_32_12_16_cbc(void), EVP_rc5_32_12_16_ecb(void), EVP_rc5_32_12_16_cfb(void), EVP_rc5_32_12_16_ofb(void)<DD>
<A NAME="ixAAV"></A>
<FONT SIZE="-1">RC5</FONT> encryption algorithm in <FONT SIZE="-1">CBC</FONT>, <FONT SIZE="-1">ECB</FONT>, <FONT SIZE="-1">CFB</FONT> and <FONT SIZE="-1">OFB</FONT> modes respectively. This is a variable key length
cipher with an additional ``number of rounds'' parameter. By default the key length is set to 128
bits and 12 rounds.
</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>NOTES</H2>

<A NAME="ixAAW"></A>
Where possible the <B></B><FONT SIZE="-1"><B>EVP</B></FONT><B></B> interface to symmetric ciphers should be used in
preference to the low level interfaces. This is because the code then becomes
transparent to the cipher used and much more flexible.
<P>

<FONT SIZE="-1">PKCS</FONT> padding works by adding <B>n</B> padding bytes of value <B>n</B> to make the total 
length of the encrypted data a multiple of the block size. Padding is always
added so if the data is already a multiple of the block size <B>n</B> will equal
the block size. For example if the block size is 8 and 11 bytes are to be
encrypted then 5 padding bytes of value 5 will be added.
<P>

When decrypting the final block is checked to see if it has the correct form.
<P>

Although the decryption operation can produce an error if padding is enabled,
it is not a strong test that the input data or key is correct. A random block
has better than 1 in 256 chance of being of the correct format and problems with
the input data earlier on will not produce a final decrypt error.
<P>

If padding is disabled then the decryption operation will always succeed if
the total amount of data decrypted is a multiple of the block size.
<P>

The functions <I>EVP_EncryptInit()</I>, <I>EVP_EncryptFinal()</I>, <I>EVP_DecryptInit()</I>,
<I>EVP_CipherInit()</I> and <I>EVP_CipherFinal()</I> are obsolete but are retained for
compatibility with existing code. New code should use <I>EVP_EncryptInit_ex()</I>,
<I>EVP_EncryptFinal_ex()</I>, <I>EVP_DecryptInit_ex()</I>, <I>EVP_DecryptFinal_ex()</I>,
<I>EVP_CipherInit_ex()</I> and <I>EVP_CipherFinal_ex()</I> because they can reuse an
existing context without allocating and freeing it up on each call.
<A NAME="lbAH">&nbsp;</A>
<H2>BUGS</H2>

<A NAME="ixAAX"></A>
For <FONT SIZE="-1">RC5</FONT> the number of rounds can currently only be set to 8, 12 or 16. This is
a limitation of the current <FONT SIZE="-1">RC5</FONT> code rather than the <FONT SIZE="-1">EVP</FONT> interface.
<P>

<FONT SIZE="-1">EVP_MAX_KEY_LENGTH</FONT> and <FONT SIZE="-1">EVP_MAX_IV_LENGTH</FONT> only refer to the internal ciphers with
default key lengths. If custom ciphers exceed these values the results are
unpredictable. This is because it has become standard practice to define a 
generic key as a fixed unsigned char array containing <FONT SIZE="-1">EVP_MAX_KEY_LENGTH</FONT> bytes.
<P>

The <FONT SIZE="-1">ASN1</FONT> code is incomplete (and sometimes inaccurate) it has only been tested
for certain common S/MIME ciphers (<FONT SIZE="-1">RC2</FONT>, <FONT SIZE="-1">DES</FONT>, triple <FONT SIZE="-1">DES</FONT>) in <FONT SIZE="-1">CBC</FONT> mode.
<A NAME="lbAI">&nbsp;</A>
<H2>EXAMPLES</H2>

<A NAME="ixAAY"></A>
Get the number of rounds used in <FONT SIZE="-1">RC5:</FONT>
<P>



<PRE>
 int nrounds;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC5_ROUNDS, 0, &amp;nrounds);

</PRE>


<P>

Get the <FONT SIZE="-1">RC2</FONT> effective key length:
<P>



<PRE>
 int key_bits;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC2_KEY_BITS, 0, &amp;key_bits);

</PRE>


<P>

Set the number of rounds used in <FONT SIZE="-1">RC5:</FONT>
<P>



<PRE>
 int nrounds;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC5_ROUNDS, nrounds, NULL);

</PRE>


<P>

Set the effective key length used in <FONT SIZE="-1">RC2:</FONT>
<P>



<PRE>
 int key_bits;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC2_KEY_BITS, key_bits, NULL);

</PRE>


<P>

Encrypt a string using blowfish:
<P>



<PRE>
 int do_crypt(char *outfile)
        {
        unsigned char outbuf[1024];
        int outlen, tmplen;
        /* Bogus key and IV: we'd normally set these from
         * another source.
         */
        unsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
        unsigned char iv[] = {1,2,3,4,5,6,7,8};
        char intext[] = &quot;Some Crypto Text&quot;;
        EVP_CIPHER_CTX ctx;
        FILE *out;
        EVP_CIPHER_CTX_init(&amp;ctx);
        EVP_EncryptInit_ex(&amp;ctx, EVP_bf_cbc(), NULL, key, iv);

        if(!EVP_EncryptUpdate(&amp;ctx, outbuf, &amp;outlen, intext, strlen(intext)))
                {
                /* Error */
                return 0;
                }
        /* Buffer passed to EVP_EncryptFinal() must be after data just
         * encrypted to avoid overwriting it.
         */
        if(!EVP_EncryptFinal_ex(&amp;ctx, outbuf + outlen, &amp;tmplen))
                {
                /* Error */
                return 0;
                }
        outlen += tmplen;
        EVP_CIPHER_CTX_cleanup(&amp;ctx);
        /* Need binary mode for fopen because encrypted data is
         * binary data. Also cannot use strlen() on it because
         * it wont be null terminated and may contain embedded
         * nulls.
         */
        out = fopen(outfile, &quot;wb&quot;);
        fwrite(outbuf, 1, outlen, out);
        fclose(out);
        return 1;
        }

</PRE>


<P>

The ciphertext from the above example can be decrypted using the <B>openssl</B>
utility with the command line:
<P>



<PRE>
 S&lt;openssl bf -in cipher.bin -K 000102030405060708090A0B0C0D0E0F -iv 0102030405060708 -d&gt;

</PRE>


<P>

General encryption, decryption function example using <FONT SIZE="-1">FILE</FONT> I/O and <FONT SIZE="-1">RC2</FONT> with an
80 bit key:
<P>



<PRE>
 int do_crypt(FILE *in, FILE *out, int do_encrypt)
        {
        /* Allow enough space in output buffer for additional block */
        inbuf[1024], outbuf[1024 + EVP_MAX_BLOCK_LENGTH];
        int inlen, outlen;
        /* Bogus key and IV: we'd normally set these from
         * another source.
         */
        unsigned char key[] = &quot;0123456789&quot;;
        unsigned char iv[] = &quot;12345678&quot;;
        /* Don't set key or IV because we will modify the parameters */
        EVP_CIPHER_CTX_init(&amp;ctx);
        EVP_CipherInit_ex(&amp;ctx, EVP_rc2(), NULL, NULL, NULL, do_encrypt);
        EVP_CIPHER_CTX_set_key_length(&amp;ctx, 10);
        /* We finished modifying parameters so now we can set key and IV */
        EVP_CipherInit_ex(&amp;ctx, NULL, NULL, key, iv, do_encrypt);

        for(;;) 
                {
                inlen = fread(inbuf, 1, 1024, in);
                if(inlen &lt;= 0) break;
                if(!EVP_CipherUpdate(&amp;ctx, outbuf, &amp;outlen, inbuf, inlen))
                        {
                        /* Error */
                        EVP_CIPHER_CTX_cleanup(&amp;ctx);
                        return 0;
                        }
                fwrite(outbuf, 1, outlen, out);
                }
        if(!EVP_CipherFinal_ex(&amp;ctx, outbuf, &amp;outlen))
                {
                /* Error */
                EVP_CIPHER_CTX_cleanup(&amp;ctx);
                return 0;
                }
        fwrite(outbuf, 1, outlen, out);

        EVP_CIPHER_CTX_cleanup(&amp;ctx);
        return 1;
        }

</PRE>


<A NAME="lbAJ">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAZ"></A>
<I><A HREF="/manpages/index.html?3+evp">evp</A></I>(3)
<A NAME="lbAK">&nbsp;</A>
<H2>HISTORY</H2>

<A NAME="ixABA"></A>
<I>EVP_CIPHER_CTX_init()</I>, <I>EVP_EncryptInit_ex()</I>, <I>EVP_EncryptFinal_ex()</I>,
<I>EVP_DecryptInit_ex()</I>, <I>EVP_DecryptFinal_ex()</I>, <I>EVP_CipherInit_ex()</I>,
<I>EVP_CipherFinal_ex()</I> and <I>EVP_CIPHER_CTX_set_padding()</I> appeared in
OpenSSL 0.9.7.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">RETURN VALUES</A><DD>
<DT><A HREF="#lbAF">CIPHER LISTING</A><DD>
<DT><A HREF="#lbAG">NOTES</A><DD>
<DT><A HREF="#lbAH">BUGS</A><DD>
<DT><A HREF="#lbAI">EXAMPLES</A><DD>
<DT><A HREF="#lbAJ">SEE ALSO</A><DD>
<DT><A HREF="#lbAK">HISTORY</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:25 GMT, December 24, 2015
</div></body>
</HTML>
