<!DOCTYPE html>

<HTML><head><TITLE>Manpage of Encode::Encoder</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>Encode::Encoder</H1>
Section: Perl Programmers Reference Guide (3pm)<BR>Updated: 2009-02-12<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Encode::Encoder -- Object Oriented Encoder
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
  use Encode::Encoder;
  # Encode::encode(&quot;ISO-8859-1&quot;, $data); 
  Encode::Encoder-&gt;new($data)-&gt;iso_8859_1; # OOP way
  # shortcut
  use Encode::Encoder qw(encoder);
  encoder($data)-&gt;iso_8859_1;
  # you can stack them!
  encoder($data)-&gt;iso_8859_1-&gt;base64;  # provided base64() is defined
  # you can use it as a decoder as well
  encoder($base64)-&gt;bytes('base64')-&gt;latin1;
  # stringified
  print encoder($data)-&gt;utf8-&gt;latin1;  # prints the string in latin1
  # numified
  encoder(&quot;\x{abcd}\x{ef}g&quot;)-&gt;utf8 == 6; # true. bytes::length($data)

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>ABSTRACT</H2>

<A NAME="ixAAD"></A>
<B>Encode::Encoder</B> allows you to use Encode in an object-oriented
style.  This is not only more intuitive than a functional approach,
but also handier when you want to stack encodings.  Suppose you want
your <FONT SIZE="-1">UTF-8</FONT> string converted to Latin1 then Base64: you can simply say
<P>



<PRE>
  my $base64 = encoder($utf8)-&gt;latin1-&gt;base64;

</PRE>


<P>

instead of
<P>



<PRE>
  my $latin1 = encode(&quot;latin1&quot;, $utf8);
  my $base64 = encode_base64($utf8);

</PRE>


<P>

or the lazier and more convoluted
<P>



<PRE>
  my $base64 = encode_base64(encode(&quot;latin1&quot;, $utf8));

</PRE>


<A NAME="lbAE">&nbsp;</A>
<H2>Description</H2>

<A NAME="ixAAE"></A>
Here is how to use this module.
<DL COMPACT>
<DT>*<DD>
There are at least two instance variables stored in a hash reference,
{data} and {encoding}.
<DT>*<DD>
When there is no method, it takes the method name as the name of the
encoding and encodes the instance <I>data</I> with <I>encoding</I>.  If successful,
the instance <I>encoding</I> is set accordingly.
<DT>*<DD>
You can retrieve the result via -&gt;data but usually you don't have to 
because the stringify operator (&quot;&quot;) is overridden to do exactly that.
</DL>
<A NAME="lbAF">&nbsp;</A>
<H3>Predefined Methods</H3>

<A NAME="ixAAF"></A>
This module predefines the methods below:
<DL COMPACT>
<DT>$e = Encode::Encoder-&gt;new([$data, $encoding]);<DD>


<A NAME="ixAAG"></A>
returns an encoder object.  Its data is initialized with <TT>$data</TT> if
present, and its encoding is set to <TT>$encoding</TT> if present.


<P>


When <TT>$encoding</TT> is omitted, it defaults to utf8 if <TT>$data</TT> is already in
utf8 or &quot;&quot; (empty string) otherwise.
<DT><I>encoder()</I><DD>
<A NAME="ixAAH"></A>
is an alias of Encode::Encoder-&gt;<I>new()</I>.  This one is exported on demand.
<DT>$e-&gt;data([$data])<DD>


<A NAME="ixAAI"></A>
When <TT>$data</TT> is present, sets the instance data to <TT>$data</TT> and returns the
object itself.  Otherwise, the current instance data is returned.
<DT>$e-&gt;encoding([$encoding])<DD>


<A NAME="ixAAJ"></A>
When <TT>$encoding</TT> is present, sets the instance encoding to <TT>$encoding</TT> and
returns the object itself.  Otherwise, the current instance encoding is
returned.
<DT>$e-&gt;bytes([$encoding])<DD>


<A NAME="ixAAK"></A>
decodes instance data from <TT>$encoding</TT>, or the instance encoding if
omitted.  If the conversion is successful, the instance encoding
will be set to &quot;&quot;.


<P>


The name <I>bytes</I> was deliberately picked to avoid namespace tainting
--- this module may be used as a base class so method names that appear
in Encode::Encoding are avoided.
</DL>
<A NAME="lbAG">&nbsp;</A>
<H3>Example: base64 transcoder</H3>

<A NAME="ixAAL"></A>
This module is designed to work with Encode::Encoding.
To make the Base64 transcoder example above really work, you could
write a module like this:
<P>



<PRE>
  package Encode::Base64;
  use base 'Encode::Encoding';
  __PACKAGE__-&gt;Define('base64');
  use MIME::Base64;
  sub encode{ 
      my ($obj, $data) = @_; 
      return encode_base64($data);
  }
  sub decode{
      my ($obj, $data) = @_; 
      return decode_base64($data);
  }
  1;
  __END__

</PRE>


<P>

And your caller module would be something like this:
<P>



<PRE>
  use Encode::Encoder;
  use Encode::Base64;

  # now you can really do the following

  encoder($data)-&gt;iso_8859_1-&gt;base64;
  encoder($base64)-&gt;bytes('base64')-&gt;latin1;

</PRE>


<A NAME="lbAH">&nbsp;</A>
<H3>Operator Overloading</H3>

<A NAME="ixAAM"></A>
This module overloads two operators, stringify (&quot;&quot;) and numify (0+).
<P>

Stringify dumps the data inside the object.
<P>

Numify returns the number of bytes in the instance data.
<P>

They come in handy when you want to print or find the size of data.
<A NAME="lbAI">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAN"></A>
Encode,
Encode::Encoding
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">ABSTRACT</A><DD>
<DT><A HREF="#lbAE">Description</A><DD>
<DL>
<DT><A HREF="#lbAF">Predefined Methods</A><DD>
<DT><A HREF="#lbAG">Example: base64 transcoder</A><DD>
<DT><A HREF="#lbAH">Operator Overloading</A><DD>
</DL>
<DT><A HREF="#lbAI">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:23 GMT, December 24, 2015
</div></body>
</HTML>
