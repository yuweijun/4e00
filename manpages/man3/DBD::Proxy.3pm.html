<!DOCTYPE html>

<HTML><head><TITLE>Manpage of DBD::Proxy</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>DBD::Proxy</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2007-10-10<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

DBD::Proxy - A proxy driver for the DBI
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
  use DBI;

  $dbh = DBI-&gt;connect(&quot;dbi:Proxy:hostname=$host;port=$port;dsn=$db&quot;,
                      $user, $passwd);

  # See the DBI module documentation for full details

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
DBD::Proxy is a Perl module for connecting to a database via a remote
<FONT SIZE="-1">DBI</FONT> driver. See DBD::Gofer for an alternative with different trade-offs.
<P>

This is of course not needed for <FONT SIZE="-1">DBI</FONT> drivers which already
support connecting to a remote database, but there are engines which
don't offer network connectivity.
<P>

Another application is offering database access through a firewall, as
the driver offers query based restrictions. For example you can
restrict queries to exactly those that are used in a given <FONT SIZE="-1">CGI</FONT>
application.
<P>

Speaking of <FONT SIZE="-1">CGI</FONT>, another application is (or rather, will be) to reduce
the database connect/disconnect overhead from <FONT SIZE="-1">CGI</FONT> scripts by using
proxying the connect_cached method. The proxy server will hold the
database connections open in a cache. The <FONT SIZE="-1">CGI</FONT> script then trades the
database connect/disconnect overhead for the DBD::Proxy
connect/disconnect overhead which is typically much less.
<I>Note that the connect_cached method is new and still experimental.</I>
<A NAME="lbAE">&nbsp;</A>
<H2>CONNECTING TO THE DATABASE</H2>

<A NAME="ixAAE"></A>
Before connecting to a remote database, you must ensure, that a Proxy
server is running on the remote machine. There's no default port, so
you have to ask your system administrator for the port number. See
DBI::ProxyServer for details.
<P>

Say, your Proxy server is running on machine ``alpha'', port 3334, and
you'd like to connect to an <FONT SIZE="-1">ODBC</FONT> database called ``mydb'' as user ``joe''
with password ``hello''. When using <FONT SIZE="-1">DBD::ODBC</FONT> directly, you'd do a
<P>



<PRE>
  $dbh = DBI-&gt;connect(&quot;DBI:ODBC:mydb&quot;, &quot;joe&quot;, &quot;hello&quot;);

</PRE>


<P>

With DBD::Proxy this becomes
<P>



<PRE>
  $dsn = &quot;DBI:Proxy:hostname=alpha;port=3334;dsn=DBI:ODBC:mydb&quot;;
  $dbh = DBI-&gt;connect($dsn, &quot;joe&quot;, &quot;hello&quot;);

</PRE>


<P>

You see, this is mainly the same. The DBD::Proxy module will create a
connection to the Proxy server on ``alpha'' which in turn will connect
to the <FONT SIZE="-1">ODBC</FONT> database.
<P>

Refer to the <FONT SIZE="-1">DBI</FONT> documentation on the <TT>&quot;connect&quot;</TT> method for a way
to automatically use DBD::Proxy without having to change your code.
<P>

DBD::Proxy's <FONT SIZE="-1">DSN</FONT> string has the format
<P>



<PRE>
  $dsn = &quot;DBI:Proxy:key1=val1; ... ;keyN=valN;dsn=valDSN&quot;;

</PRE>


<P>

In other words, it is a collection of key/value pairs. The following
keys are recognized:
<DL COMPACT>
<DT>hostname<DD>
<A NAME="ixAAF"></A>

<DT>port<DD>
<A NAME="ixAAG"></A>

Hostname and port of the Proxy server; these keys must be present,
no defaults. Example:


<P>




<PRE>
    hostname=alpha;port=3334

</PRE>


<DT>dsn<DD>
<A NAME="ixAAH"></A>
The value of this attribute will be used as a dsn name by the Proxy
server. Thus it must have the format <TT>&quot;DBI:driver:...&quot;</TT>, in particular
it will contain colons. The <I>dsn</I> value may contain semicolons, hence
this key *must* be the last and it's value will be the complete
remaining part of the dsn. Example:


<P>




<PRE>
    dsn=DBI:ODBC:mydb

</PRE>


<DT>cipher<DD>
<A NAME="ixAAI"></A>

<DT>key<DD>
<A NAME="ixAAJ"></A>
<DT>usercipher<DD>
<A NAME="ixAAK"></A>
<DT>userkey<DD>
<A NAME="ixAAL"></A>

By using these fields you can enable encryption. If you set,
for example,


<P>




<PRE>
    cipher=$class;key=$key

</PRE>




<P>


(note the semicolon) then DBD::Proxy will create a new cipher object
by executing


<P>




<PRE>
    $cipherRef = $class-&gt;new(pack(&quot;H*&quot;, $key));

</PRE>




<P>


and pass this object to the RPC::PlClient module when creating a
client. See RPC::PlClient. Example:


<P>




<PRE>
    cipher=IDEA;key=97cd2375efa329aceef2098babdc9721

</PRE>




<P>


The usercipher/userkey attributes allow you to use two phase encryption:
The cipher/key encryption will be used in the login and authorisation
phase. Once the client is authorised, he will change to usercipher/userkey
encryption. Thus the cipher/key pair is a <B>host</B> based secret, typically
less secure than the usercipher/userkey secret and readable by anyone.
The usercipher/userkey secret is <B>your</B> private secret.


<P>


Of course encryption requires an appropriately configured server. See
&lt;DBD::ProxyServer/CONFIGURATION <FONT SIZE="-1">FILE</FONT>&gt;.
<DT>debug<DD>
<A NAME="ixAAM"></A>
Turn on debugging mode
<DT>stderr<DD>
<A NAME="ixAAN"></A>
This attribute will set the corresponding attribute of the RPC::PlClient
object, thus logging will not use <I>syslog()</I>, but redirected to stderr.
This is the default under Windows.


<P>




<PRE>
    stderr=1

</PRE>


<DT>logfile<DD>
<A NAME="ixAAO"></A>
Similar to the stderr attribute, but output will be redirected to the
given file.


<P>




<PRE>
    logfile=/dev/null

</PRE>


<DT>RowCacheSize<DD>
<A NAME="ixAAP"></A>
The DBD::Proxy driver supports this attribute (which is <FONT SIZE="-1">DBI</FONT> standard,
as of <FONT SIZE="-1">DBI</FONT> 1.02). It's used to reduce network round-trips by fetching
multiple rows in one go. The current default value is 20, but this may
change.
<DT>proxy_no_finish<DD>
<A NAME="ixAAQ"></A>
This attribute can be used to reduce network traffic: If the
application is calling <TT>$sth</TT>-&gt;<I>finish()</I> then the proxy tells the server
to finish the remote statement handle. Of course this slows down things
quite a lot, but is prefectly good for reducing memory usage with
persistent connections.


<P>


However, if you set the <I>proxy_no_finish</I> attribute to a <FONT SIZE="-1">TRUE</FONT> value,
either in the database handle or in the statement handle, then <I>finish()</I>
calls will be supressed. This is what you want, for example, in small
and fast <FONT SIZE="-1">CGI</FONT> applications.
<DT>proxy_quote<DD>
<A NAME="ixAAR"></A>
This attribute can be used to reduce network traffic: By default calls
to <TT>$dbh</TT>-&gt;<I>quote()</I> are passed to the remote driver.  Of course this slows
down things quite a lot, but is the safest default behaviour.


<P>


However, if you set the <I>proxy_quote</I> attribute to the value '<TT>&quot;local&quot;</TT>'
either in the database handle or in the statement handle, and the call
to quote has only one parameter, then the local default <FONT SIZE="-1">DBI</FONT> quote
method will be used (which will be faster but may be wrong).
</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>KNOWN ISSUES</H2>

<A NAME="ixAAS"></A>
<A NAME="lbAG">&nbsp;</A>
<H3>Unproxied method calls</H3>

<A NAME="ixAAT"></A>
If a method isn't being proxied, try declaring a stub sub in the appropriate
package (DBD::Proxy::db for a dbh method, and DBD::Proxy::st for an sth method).
For example:
<P>



<PRE>
    sub DBD::Proxy::db::selectall_arrayref;

</PRE>


<P>

That will enable selectall_arrayref to be proxied.
<P>

Currently many methods aren't explicitly proxied and so you get the <FONT SIZE="-1">DBI</FONT>'s
default methods executed on the client.
<P>

Some of those methods, like selectall_arrayref, may then call other methods
that are proxied (selectall_arrayref calls fetchall_arrayref which calls fetch
which is proxied). So things may appear to work but operate more slowly than
the could.
<P>

This may all change in a later version.
<A NAME="lbAH">&nbsp;</A>
<H3>Complex handle attributes</H3>

<A NAME="ixAAU"></A>
Sometimes handles are having complex attributes like hash refs or
array refs and not simple strings or integers. For example, with
<FONT SIZE="-1">DBD::CSV</FONT>, you would like to write something like
<P>



<PRE>
  $dbh-&gt;{&quot;csv_tables&quot;}-&gt;{&quot;passwd&quot;} =
        { &quot;sep_char&quot; =&gt; &quot;:&quot;, &quot;eol&quot; =&gt; &quot;\n&quot;;

</PRE>


<P>

The above example would advice the <FONT SIZE="-1">CSV</FONT> driver to assume the file
``passwd'' to be in the format of the /etc/passwd file: Colons as
separators and a line feed without carriage return as line
terminator.
<P>

Surprisingly this example doesn't work with the proxy driver. To understand
the reasons, you should consider the following: The Perl compiler is
executing the above example in two steps:
<DL COMPACT>
<DT>1.<DD>
The first step is fetching the value of the key ``csv_tables'' in the
handle <TT>$dbh</TT>. The value returned is complex, a hash ref.
<DT>2.<DD>
The second step is storing some value (the right hand side of the
assignment) as the key ``passwd'' in the hash ref from step 1.
</DL>
<P>

This becomes a little bit clearer, if we rewrite the above code:
<P>



<PRE>
  $tables = $dbh-&gt;{&quot;csv_tables&quot;};
  $tables-&gt;{&quot;passwd&quot;} = { &quot;sep_char&quot; =&gt; &quot;:&quot;, &quot;eol&quot; =&gt; &quot;\n&quot;;

</PRE>


<P>

While the examples work fine without the proxy, the fail due to a
subtile difference in step 1: By <FONT SIZE="-1">DBI</FONT> magic, the hash ref
<TT>$dbh</TT>-&gt;{'csv_tables'} is returned from the server to the client.
The client creates a local copy. This local copy is the result of
step 1. In other words, step 2 modifies a local copy of the hash ref,
but not the server's hash ref.
<P>

The workaround is storing the modified local copy back to the server:
<P>



<PRE>
  $tables = $dbh-&gt;{&quot;csv_tables&quot;};
  $tables-&gt;{&quot;passwd&quot;} = { &quot;sep_char&quot; =&gt; &quot;:&quot;, &quot;eol&quot; =&gt; &quot;\n&quot;;
  $dbh-&gt;{&quot;csv_tables&quot;} = $tables;

</PRE>


<A NAME="lbAI">&nbsp;</A>
<H2>AUTHOR AND COPYRIGHT</H2>

<A NAME="ixAAV"></A>
This module is Copyright (c) 1997, 1998
<P>



<PRE>
    Jochen Wiedmann
    Am Eisteich 9
    72555 Metzingen
    Germany

    Email: <A HREF="mailto:joe@ispsoft.de">joe@ispsoft.de</A>
    Phone: +49 7123 14887

</PRE>


<P>

The DBD::Proxy module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. In particular permission
is granted to Tim Bunce for distributing this as a part of the <FONT SIZE="-1">DBI</FONT>.
<A NAME="lbAJ">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAW"></A>
<FONT SIZE="-1">DBI</FONT>, RPC::PlClient, Storable
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">CONNECTING TO THE DATABASE</A><DD>
<DT><A HREF="#lbAF">KNOWN ISSUES</A><DD>
<DL>
<DT><A HREF="#lbAG">Unproxied method calls</A><DD>
<DT><A HREF="#lbAH">Complex handle attributes</A><DD>
</DL>
<DT><A HREF="#lbAI">AUTHOR AND COPYRIGHT</A><DD>
<DT><A HREF="#lbAJ">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:22 GMT, December 24, 2015
</div></div>
</body>
</HTML>
