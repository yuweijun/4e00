<!DOCTYPE html>

<HTML><head><TITLE>Manpage of ecdsa</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>ecdsa</H1>
Section: OpenSSL (3)<BR>Updated: 2005-05-19<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

ecdsa - Elliptic Curve Digital Signature Algorithm
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
 #include &lt;<A HREF="file:/usr/include/openssl/ecdsa.h">openssl/ecdsa.h</A>&gt;

 ECDSA_SIG*     ECDSA_SIG_new(void);
 void           ECDSA_SIG_free(ECDSA_SIG *sig);
 int            i2d_ECDSA_SIG(const ECDSA_SIG *sig, unsigned char **pp);
 ECDSA_SIG*     d2i_ECDSA_SIG(ECDSA_SIG **sig, const unsigned char **pp, 
                long len);

 ECDSA_SIG*     ECDSA_do_sign(const unsigned char *dgst, int dgst_len,
                        EC_KEY *eckey);
 ECDSA_SIG*     ECDSA_do_sign_ex(const unsigned char *dgst, int dgstlen, 
                        const BIGNUM *kinv, const BIGNUM *rp,
                        EC_KEY *eckey);
 int            ECDSA_do_verify(const unsigned char *dgst, int dgst_len,
                        const ECDSA_SIG *sig, EC_KEY* eckey);
 int            ECDSA_sign_setup(EC_KEY *eckey, BN_CTX *ctx,
                        BIGNUM **kinv, BIGNUM **rp);
 int            ECDSA_sign(int type, const unsigned char *dgst,
                        int dgstlen, unsigned char *sig,
                        unsigned int *siglen, EC_KEY *eckey);
 int            ECDSA_sign_ex(int type, const unsigned char *dgst,
                        int dgstlen, unsigned char *sig,
                        unsigned int *siglen, const BIGNUM *kinv, 
                        const BIGNUM *rp, EC_KEY *eckey);
 int            ECDSA_verify(int type, const unsigned char *dgst,
                        int dgstlen, const unsigned char *sig,
                        int siglen, EC_KEY *eckey);
 int            ECDSA_size(const EC_KEY *eckey);

 const ECDSA_METHOD*    ECDSA_OpenSSL(void);
 void           ECDSA_set_default_method(const ECDSA_METHOD *meth);
 const ECDSA_METHOD*    ECDSA_get_default_method(void);
 int            ECDSA_set_method(EC_KEY *eckey,const ECDSA_METHOD *meth);

 int            ECDSA_get_ex_new_index(long argl, void *argp,
                        CRYPTO_EX_new *new_func,
                        CRYPTO_EX_dup *dup_func,
                        CRYPTO_EX_free *free_func);
 int            ECDSA_set_ex_data(EC_KEY *d, int idx, void *arg);
 void*          ECDSA_get_ex_data(EC_KEY *d, int idx);

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
The <B></B><FONT SIZE="-1"><B>ECDSA_SIG</B></FONT><B></B> structure consists of two BIGNUMs for the
r and s value of a <FONT SIZE="-1">ECDSA</FONT> signature (see X9.62 or <FONT SIZE="-1">FIPS</FONT> 186-2).
<P>



<PRE>
 struct
        {
        BIGNUM *r;
        BIGNUM *s;
 } ECDSA_SIG;

</PRE>


<P>

<I>ECDSA_SIG_new()</I> allocates a new <B></B><FONT SIZE="-1"><B>ECDSA_SIG</B></FONT><B></B> structure (note: this
function also allocates the BIGNUMs) and initialize it.
<P>

<I>ECDSA_SIG_free()</I> frees the <B></B><FONT SIZE="-1"><B>ECDSA_SIG</B></FONT><B></B> structure <B>sig</B>.
<P>

<I>i2d_ECDSA_SIG()</I> creates the <FONT SIZE="-1">DER</FONT> encoding of the <FONT SIZE="-1">ECDSA</FONT> signature
<B>sig</B> and writes the encoded signature to <B>*pp</B> (note: if <B>pp</B>
is <FONT SIZE="-1">NULL</FONT> <B>i2d_ECDSA_SIG</B> returns the expected length in bytes of 
the <FONT SIZE="-1">DER</FONT> encoded signature). <B>i2d_ECDSA_SIG</B> returns the length
of the <FONT SIZE="-1">DER</FONT> encoded signature (or 0 on error).
<P>

<I>d2i_ECDSA_SIG()</I> decodes a <FONT SIZE="-1">DER</FONT> encoded <FONT SIZE="-1">ECDSA</FONT> signature and returns
the decoded signature in a newly allocated <B></B><FONT SIZE="-1"><B>ECDSA_SIG</B></FONT><B></B> structure.
<B>*sig</B> points to the buffer containing the <FONT SIZE="-1">DER</FONT> encoded signature
of size <B>len</B>.
<P>

<I>ECDSA_size()</I> returns the maximum length of a <FONT SIZE="-1">DER</FONT> encoded
<FONT SIZE="-1">ECDSA</FONT> signature created with the private <FONT SIZE="-1">EC</FONT> key <B>eckey</B>.
<P>

<I>ECDSA_sign_setup()</I> may be used to precompute parts of the
signing operation. <B>eckey</B> is the private <FONT SIZE="-1">EC</FONT> key and <B>ctx</B>
is a pointer to <B></B><FONT SIZE="-1"><B>BN_CTX</B></FONT><B></B> structure (or <FONT SIZE="-1">NULL</FONT>). The precomputed
values or returned in <B>kinv</B> and <B>rp</B> and can be used in a
later call to <B>ECDSA_sign_ex</B> or <B>ECDSA_do_sign_ex</B>.
<P>

<I>ECDSA_sign()</I> is wrapper function for ECDSA_sign_ex with <B>kinv</B>
and <B>rp</B> set to <FONT SIZE="-1">NULL</FONT>.
<P>

<I>ECDSA_sign_ex()</I> computes a digital signature of the <B>dgstlen</B> bytes
hash value <B>dgst</B> using the private <FONT SIZE="-1">EC</FONT> key <B>eckey</B> and the optional
pre-computed values <B>kinv</B> and <B>rp</B>. The <FONT SIZE="-1">DER</FONT> encoded signatures is
stored in <B>sig</B> and it's length is returned in <B>sig_len</B>. Note: <B>sig</B>
must point to <B>ECDSA_size</B> bytes of memory. The parameter <B>type</B>
is ignored.
<P>

<I>ECDSA_verify()</I> verifies that the signature in <B>sig</B> of size
<B>siglen</B> is a valid <FONT SIZE="-1">ECDSA</FONT> signature of the hash value
value <B>dgst</B> of size <B>dgstlen</B> using the public key <B>eckey</B>.
The parameter <B>type</B> is ignored.
<P>

<I>ECDSA_do_sign()</I> is wrapper function for ECDSA_do_sign_ex with <B>kinv</B>
and <B>rp</B> set to <FONT SIZE="-1">NULL</FONT>.
<P>

<I>ECDSA_do_sign_ex()</I> computes a digital signature of the <B>dgst_len</B>
bytes hash value <B>dgst</B> using the private key <B>eckey</B> and the
optional pre-computed values <B>kinv</B> and <B>rp</B>. The signature is
returned in a newly allocated <B></B><FONT SIZE="-1"><B>ECDSA_SIG</B></FONT><B></B> structure (or <FONT SIZE="-1">NULL</FONT> on error).
<P>

<I>ECDSA_do_verify()</I> verifies that the signature <B>sig</B> is a valid
<FONT SIZE="-1">ECDSA</FONT> signature of the hash value <B>dgst</B> of size <B>dgst_len</B>
using the public key <B>eckey</B>.
<A NAME="lbAE">&nbsp;</A>
<H2>RETURN VALUES</H2>

<A NAME="ixAAE"></A>
<I>ECDSA_size()</I> returns the maximum length signature or 0 on error.
<P>

<I>ECDSA_sign_setup()</I> and <I>ECDSA_sign()</I> return 1 if successful or -1
on error.
<P>

<I>ECDSA_verify()</I> and <I>ECDSA_do_verify()</I> return 1 for a valid
signature, 0 for an invalid signature and -1 on error.
The error codes can be obtained by <I><A HREF="/manpages/index.html?3+ERR_get_error">ERR_get_error</A></I>(3).
<A NAME="lbAF">&nbsp;</A>
<H2>EXAMPLES</H2>

<A NAME="ixAAF"></A>
Creating a <FONT SIZE="-1">ECDSA</FONT> signature of given <FONT SIZE="-1">SHA-1</FONT> hash value using the
named curve secp192k1.
<P>

First step: create a <FONT SIZE="-1">EC_KEY</FONT> object (note: this part is <B>not</B> <FONT SIZE="-1">ECDSA</FONT>
specific)
<P>



<PRE>
 int        ret;
 ECDSA_SIG *sig;
 EC_KEY    *eckey = EC_KEY_new();
 if (eckey == NULL)
        {
        /* error */
        }
 key-&gt;group = EC_GROUP_new_by_nid(NID_secp192k1);
 if (key-&gt;group == NULL)
        {
        /* error */
        }
 if (!EC_KEY_generate_key(eckey))
        {
        /* error */
        }

</PRE>


<P>

Second step: compute the <FONT SIZE="-1">ECDSA</FONT> signature of a <FONT SIZE="-1">SHA-1</FONT> hash value 
using <B>ECDSA_do_sign</B>
<P>



<PRE>
 sig = ECDSA_do_sign(digest, 20, eckey);
 if (sig == NULL)
        {
        /* error */
        }

</PRE>


<P>

or using <B>ECDSA_sign</B>
<P>



<PRE>
 unsigned char *buffer, *pp;
 int            buf_len;
 buf_len = ECDSA_size(eckey);
 buffer  = OPENSSL_malloc(buf_len);
 pp = buffer;
 if (!ECDSA_sign(0, dgst, dgstlen, pp, &amp;buf_len, eckey);
        {
        /* error */
        }

</PRE>


<P>

Third step: verify the created <FONT SIZE="-1">ECDSA</FONT> signature using <B>ECDSA_do_verify</B>
<P>



<PRE>
 ret = ECDSA_do_verify(digest, 20, sig, eckey);

</PRE>


<P>

or using <B>ECDSA_verify</B>
<P>



<PRE>
 ret = ECDSA_verify(0, digest, 20, buffer, buf_len, eckey);

</PRE>


<P>

and finally evaluate the return value:
<P>



<PRE>
 if (ret == -1)
        {
        /* error */
        }
 else if (ret == 0)
        {
        /* incorrect signature */
        }
 else   /* ret == 1 */
        {
        /* signature ok */
        }

</PRE>


<A NAME="lbAG">&nbsp;</A>
<H2>CONFORMING TO</H2>

<A NAME="ixAAG"></A>
<FONT SIZE="-1">ANSI</FONT> X9.62, <FONT SIZE="-1">US</FONT> Federal Information Processing Standard <FONT SIZE="-1">FIPS</FONT> 186-2
(Digital Signature Standard, <FONT SIZE="-1">DSS</FONT>)
<A NAME="lbAH">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAH"></A>
<I><A HREF="/manpages/index.html?3+dsa">dsa</A></I>(3), <I><A HREF="http://localhost/cgi-bin/man/man2html?3+rsa">rsa</A></I>(3)
<A NAME="lbAI">&nbsp;</A>
<H2>HISTORY</H2>

<A NAME="ixAAI"></A>
The ecdsa implementation was first introduced in OpenSSL 0.9.8
<A NAME="lbAJ">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixAAJ"></A>
Nils Larsch for the OpenSSL project (<A HREF="http://www.openssl.org).">http://www.openssl.org).</A>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">RETURN VALUES</A><DD>
<DT><A HREF="#lbAF">EXAMPLES</A><DD>
<DT><A HREF="#lbAG">CONFORMING TO</A><DD>
<DT><A HREF="#lbAH">SEE ALSO</A><DD>
<DT><A HREF="#lbAI">HISTORY</A><DD>
<DT><A HREF="#lbAJ">AUTHOR</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:23 GMT, December 24, 2015
</div></div>
</body>
</HTML>
