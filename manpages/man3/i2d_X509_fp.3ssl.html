<!DOCTYPE html>

<HTML><head><TITLE>Manpage of d2i_X509</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>d2i_X509</H1>
Section: OpenSSL (3)<BR>Updated: 2009-09-12<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio,
i2d_X509_fp - X509 encode and decode functions
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
 #include &lt;<A HREF="file:/usr/include/openssl/x509.h">openssl/x509.h</A>&gt;

 X509 *d2i_X509(X509 **px, const unsigned char **in, int len);
 int i2d_X509(X509 *x, unsigned char **out);

 X509 *d2i_X509_bio(BIO *bp, X509 **x);
 X509 *d2i_X509_fp(FILE *fp, X509 **x);

 int i2d_X509_bio(BIO *bp, X509 *x);
 int i2d_X509_fp(FILE *fp, X509 *x);

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
The X509 encode and decode routines encode and parse an
<B>X509</B> structure, which represents an X509 certificate.
<P>

<I>d2i_X509()</I> attempts to decode <B>len</B> bytes at <B>*in</B>. If 
successful a pointer to the <B>X509</B> structure is returned. If an error
occurred then <B></B><FONT SIZE="-1"><B>NULL</B></FONT><B></B> is returned. If <B>px</B> is not <B></B><FONT SIZE="-1"><B>NULL</B></FONT><B></B> then the
returned structure is written to <B>*px</B>. If <B>*px</B> is not <B></B><FONT SIZE="-1"><B>NULL</B></FONT><B></B>
then it is assumed that <B>*px</B> contains a valid <B>X509</B>
structure and an attempt is made to reuse it. If the call is
successful <B>*in</B> is incremented to the byte following the
parsed data.
<P>

<I>i2d_X509()</I> encodes the structure pointed to by <B>x</B> into <FONT SIZE="-1">DER</FONT> format.
If <B>out</B> is not <B></B><FONT SIZE="-1"><B>NULL</B></FONT><B></B> is writes the <FONT SIZE="-1">DER</FONT> encoded data to the buffer
at <B>*out</B>, and increments it to point after the data just written.
If the return value is negative an error occurred, otherwise it
returns the length of the encoded data.
<P>

For OpenSSL 0.9.7 and later if <B>*out</B> is <B></B><FONT SIZE="-1"><B>NULL</B></FONT><B></B> memory will be
allocated for a buffer and the encoded data written to it. In this
case <B>*out</B> is not incremented and it points to the start of the
data just written.
<P>

<I>d2i_X509_bio()</I> is similar to <I>d2i_X509()</I> except it attempts
to parse data from <FONT SIZE="-1">BIO</FONT> <B>bp</B>.
<P>

<I>d2i_X509_fp()</I> is similar to <I>d2i_X509()</I> except it attempts
to parse data from <FONT SIZE="-1">FILE</FONT> pointer <B>fp</B>.
<P>

<I>i2d_X509_bio()</I> is similar to <I>i2d_X509()</I> except it writes
the encoding of the structure <B>x</B> to <FONT SIZE="-1">BIO</FONT> <B>bp</B> and it
returns 1 for success and 0 for failure.
<P>

<I>i2d_X509_fp()</I> is similar to <I>i2d_X509()</I> except it writes
the encoding of the structure <B>x</B> to <FONT SIZE="-1">BIO</FONT> <B>bp</B> and it
returns 1 for success and 0 for failure.
<A NAME="lbAE">&nbsp;</A>
<H2>NOTES</H2>

<A NAME="ixAAE"></A>
The letters <B>i</B> and <B>d</B> in for example <B>i2d_X509</B> stand for
``internal'' (that is an internal C structure) and ``<FONT SIZE="-1">DER</FONT>''. So that
<B>i2d_X509</B> converts from internal to <FONT SIZE="-1">DER</FONT>.
<P>

The functions can also understand <B></B><FONT SIZE="-1"><B>BER</B></FONT><B></B> forms.
<P>

The actual X509 structure passed to <I>i2d_X509()</I> must be a valid
populated <B>X509</B> structure it can <B>not</B> simply be fed with an
empty structure such as that returned by <I>X509_new()</I>.
<P>

The encoded data is in binary form and may contain embedded zeroes.
Therefore any <FONT SIZE="-1">FILE</FONT> pointers or BIOs should be opened in binary mode.
Functions such as <B></B>strlen()<B></B> will <B>not</B> return the correct length
of the encoded structure.
<P>

The ways that <B>*in</B> and <B>*out</B> are incremented after the operation
can trap the unwary. See the <B></B><FONT SIZE="-1"><B>WARNINGS</B></FONT><B></B> section for some common
errors.
<P>

The reason for the auto increment behaviour is to reflect a typical
usage of <FONT SIZE="-1">ASN1</FONT> functions: after one structure is encoded or decoded
another will processed after it.
<A NAME="lbAF">&nbsp;</A>
<H2>EXAMPLES</H2>

<A NAME="ixAAF"></A>
Allocate and encode the <FONT SIZE="-1">DER</FONT> encoding of an X509 structure:
<P>



<PRE>
 int len;
 unsigned char *buf, *p;

 len = i2d_X509(x, NULL);

 buf = OPENSSL_malloc(len);

 if (buf == NULL)
        /* error */

 p = buf;

 i2d_X509(x, &amp;p);

</PRE>


<P>

If you are using OpenSSL 0.9.7 or later then this can be
simplified to:
<P>



<PRE>
 int len;
 unsigned char *buf;

 buf = NULL;

 len = i2d_X509(x, &amp;buf);

 if (len &lt; 0)
        /* error */

</PRE>


<P>

Attempt to decode a buffer:
<P>



<PRE>
 X509 *x;

 unsigned char *buf, *p;

 int len;

 /* Something to setup buf and len */

 p = buf;

 x = d2i_X509(NULL, &amp;p, len);

 if (x == NULL)
    /* Some error */

</PRE>


<P>

Alternative technique:
<P>



<PRE>
 X509 *x;

 unsigned char *buf, *p;

 int len;

 /* Something to setup buf and len */

 p = buf;

 x = NULL;

 if(!d2i_X509(&amp;x, &amp;p, len))
    /* Some error */

</PRE>


<A NAME="lbAG">&nbsp;</A>
<H2>WARNINGS</H2>

<A NAME="ixAAG"></A>
The use of temporary variable is mandatory. A common
mistake is to attempt to use a buffer directly as follows:
<P>



<PRE>
 int len;
 unsigned char *buf;

 len = i2d_X509(x, NULL);

 buf = OPENSSL_malloc(len);

 if (buf == NULL)
        /* error */

 i2d_X509(x, &amp;buf);

 /* Other stuff ... */

 OPENSSL_free(buf);

</PRE>


<P>

This code will result in <B>buf</B> apparently containing garbage because
it was incremented after the call to point after the data just written.
Also <B>buf</B> will no longer contain the pointer allocated by <B></B>OPENSSL_malloc()<B></B>
and the subsequent call to <B></B>OPENSSL_free()<B></B> may well crash.
<P>

The auto allocation feature (setting buf to <FONT SIZE="-1">NULL</FONT>) only works on OpenSSL
0.9.7 and later. Attempts to use it on earlier versions will typically
cause a segmentation violation.
<P>

Another trap to avoid is misuse of the <B>xp</B> argument to <B></B>d2i_X509()<B></B>:
<P>



<PRE>
 X509 *x;

 if (!d2i_X509(&amp;x, &amp;p, len))
        /* Some error */

</PRE>


<P>

This will probably crash somewhere in <B></B>d2i_X509()<B></B>. The reason for this
is that the variable <B>x</B> is uninitialized and an attempt will be made to
interpret its (invalid) value as an <B>X509</B> structure, typically causing
a segmentation violation. If <B>x</B> is set to <FONT SIZE="-1">NULL</FONT> first then this will not
happen.
<A NAME="lbAH">&nbsp;</A>
<H2>BUGS</H2>

<A NAME="ixAAH"></A>
In some versions of OpenSSL the ``reuse'' behaviour of <I>d2i_X509()</I> when 
<B>*px</B> is valid is broken and some parts of the reused structure may
persist if they are not present in the new one. As a result the use
of this ``reuse'' behaviour is strongly discouraged.
<P>

<I>i2d_X509()</I> will not return an error in many versions of OpenSSL,
if mandatory fields are not initialized due to a programming error
then the encoded structure may contain invalid data or omit the
fields entirely and will not be parsed by <I>d2i_X509()</I>. This may be
fixed in future so code should not assume that <I>i2d_X509()</I> will
always succeed.
<A NAME="lbAI">&nbsp;</A>
<H2>RETURN VALUES</H2>

<A NAME="ixAAI"></A>
<I>d2i_X509()</I>, <I>d2i_X509_bio()</I> and <I>d2i_X509_fp()</I> return a valid <B>X509</B> structure
or <B></B><FONT SIZE="-1"><B>NULL</B></FONT><B></B> if an error occurs. The error code that can be obtained by
<I><A HREF="/manpages/index.html?3+ERR_get_error">ERR_get_error</A></I>(3).
<P>

<I>i2d_X509()</I> returns the number of bytes successfully encoded or a negative
value if an error occurs. The error code can be obtained by
<I><A HREF="/manpages/index.html?3+ERR_get_error">ERR_get_error</A></I>(3).
<P>

<I>i2d_X509_bio()</I> and <I>i2d_X509_fp()</I> return 1 for success and 0 if an error 
occurs The error code can be obtained by <I><A HREF="/manpages/index.html?3+ERR_get_error">ERR_get_error</A></I>(3).
<A NAME="lbAJ">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAJ"></A>
<I><A HREF="/manpages/index.html?3+ERR_get_error">ERR_get_error</A></I>(3)
<A NAME="lbAK">&nbsp;</A>
<H2>HISTORY</H2>

<A NAME="ixAAK"></A>
d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio and i2d_X509_fp
are available in all versions of SSLeay and OpenSSL.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">NOTES</A><DD>
<DT><A HREF="#lbAF">EXAMPLES</A><DD>
<DT><A HREF="#lbAG">WARNINGS</A><DD>
<DT><A HREF="#lbAH">BUGS</A><DD>
<DT><A HREF="#lbAI">RETURN VALUES</A><DD>
<DT><A HREF="#lbAJ">SEE ALSO</A><DD>
<DT><A HREF="#lbAK">HISTORY</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:29 GMT, December 24, 2015
</div></div>
</body>
</HTML>
