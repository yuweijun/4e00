<!DOCTYPE html>

<HTML><head><TITLE>Manpage of List::Util</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"documentation"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>List::Util</H1>
Section: Perl Programmers Reference Guide (3pm)<BR>Updated: 2009-07-03<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

List::Util - A selection of general-utility list subroutines
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
    use List::Util qw(first max maxstr min minstr reduce shuffle sum);

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
<TT>&quot;List::Util&quot;</TT> contains a selection of subroutines that people have
expressed would be nice to have in the perl core, but the usage would
not really be high enough to warrant the use of a keyword, and the size
so small such that being individual extensions would be wasteful.
<P>

By default <TT>&quot;List::Util&quot;</TT> does not export any subroutines. The
subroutines defined are
<DL COMPACT>
<DT>first <FONT SIZE="-1">BLOCK</FONT> <FONT SIZE="-1">LIST</FONT><DD>
<A NAME="ixAAE"></A>
Similar to <TT>&quot;grep&quot;</TT> in that it evaluates <FONT SIZE="-1">BLOCK</FONT> setting <TT>$_</TT> to each element
of <FONT SIZE="-1">LIST</FONT> in turn. <TT>&quot;first&quot;</TT> returns the first element where the result from
<FONT SIZE="-1">BLOCK</FONT> is a true value. If <FONT SIZE="-1">BLOCK</FONT> never returns true or <FONT SIZE="-1">LIST</FONT> was empty then
<TT>&quot;undef&quot;</TT> is returned.


<P>




<PRE>
    $foo = first { defined($_) } @list    # first defined value in @list
    $foo = first { $_ &gt; $value } @list    # first value in @list which
                                          # is greater than $value

</PRE>




<P>


This function could be implemented using <TT>&quot;reduce&quot;</TT> like this


<P>




<PRE>
    $foo = reduce { defined($a) ? $a : wanted($b) ? $b : undef } undef, @list

</PRE>




<P>


for example <I>wanted()</I> could be <I>defined()</I> which would return the first
defined value in <TT>@list</TT>
<DT>max <FONT SIZE="-1">LIST</FONT><DD>
<A NAME="ixAAF"></A>
Returns the entry in the list with the highest numerical value. If the
list is empty then <TT>&quot;undef&quot;</TT> is returned.


<P>




<PRE>
    $foo = max 1..10                # 10
    $foo = max 3,9,12               # 12
    $foo = max @bar, @baz           # whatever

</PRE>




<P>


This function could be implemented using <TT>&quot;reduce&quot;</TT> like this


<P>




<PRE>
    $foo = reduce { $a &gt; $b ? $a : $b } 1..10

</PRE>


<DT>maxstr <FONT SIZE="-1">LIST</FONT><DD>
<A NAME="ixAAG"></A>
Similar to <TT>&quot;max&quot;</TT>, but treats all the entries in the list as strings
and returns the highest string as defined by the <TT>&quot;gt&quot;</TT> operator.
If the list is empty then <TT>&quot;undef&quot;</TT> is returned.


<P>




<PRE>
    $foo = maxstr 'A'..'Z'          # 'Z'
    $foo = maxstr &quot;hello&quot;,&quot;world&quot;   # &quot;world&quot;
    $foo = maxstr @bar, @baz        # whatever

</PRE>




<P>


This function could be implemented using <TT>&quot;reduce&quot;</TT> like this


<P>




<PRE>
    $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'

</PRE>


<DT>min <FONT SIZE="-1">LIST</FONT><DD>
<A NAME="ixAAH"></A>
Similar to <TT>&quot;max&quot;</TT> but returns the entry in the list with the lowest
numerical value. If the list is empty then <TT>&quot;undef&quot;</TT> is returned.


<P>




<PRE>
    $foo = min 1..10                # 1
    $foo = min 3,9,12               # 3
    $foo = min @bar, @baz           # whatever

</PRE>




<P>


This function could be implemented using <TT>&quot;reduce&quot;</TT> like this


<P>




<PRE>
    $foo = reduce { $a &lt; $b ? $a : $b } 1..10

</PRE>


<DT>minstr <FONT SIZE="-1">LIST</FONT><DD>
<A NAME="ixAAI"></A>
Similar to <TT>&quot;min&quot;</TT>, but treats all the entries in the list as strings
and returns the lowest string as defined by the <TT>&quot;lt&quot;</TT> operator.
If the list is empty then <TT>&quot;undef&quot;</TT> is returned.


<P>




<PRE>
    $foo = minstr 'A'..'Z'          # 'A'
    $foo = minstr &quot;hello&quot;,&quot;world&quot;   # &quot;hello&quot;
    $foo = minstr @bar, @baz        # whatever

</PRE>




<P>


This function could be implemented using <TT>&quot;reduce&quot;</TT> like this


<P>




<PRE>
    $foo = reduce { $a lt $b ? $a : $b } 'A'..'Z'

</PRE>


<DT>reduce <FONT SIZE="-1">BLOCK</FONT> <FONT SIZE="-1">LIST</FONT><DD>
<A NAME="ixAAJ"></A>
Reduces <FONT SIZE="-1">LIST</FONT> by calling <FONT SIZE="-1">BLOCK</FONT>, in a scalar context, multiple times,
setting <TT>$a</TT> and <TT>$b</TT> each time. The first call will be with <TT>$a</TT>
and <TT>$b</TT> set to the first two elements of the list, subsequent
calls will be done by setting <TT>$a</TT> to the result of the previous
call and <TT>$b</TT> to the next element in the list.


<P>


Returns the result of the last call to <FONT SIZE="-1">BLOCK</FONT>. If <FONT SIZE="-1">LIST</FONT> is empty then
<TT>&quot;undef&quot;</TT> is returned. If <FONT SIZE="-1">LIST</FONT> only contains one element then that
element is returned and <FONT SIZE="-1">BLOCK</FONT> is not executed.


<P>




<PRE>
    $foo = reduce { $a &lt; $b ? $a : $b } 1..10       # min
    $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
    $foo = reduce { $a + $b } 1 .. 10               # sum
    $foo = reduce { $a . $b } @bar                  # concat

</PRE>




<P>


If your algorithm requires that <TT>&quot;reduce&quot;</TT> produce an identity value, then
make sure that you always pass that identity value as the first argument to prevent
<TT>&quot;undef&quot;</TT> being returned


<P>




<PRE>
  $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value

</PRE>


<DT>shuffle <FONT SIZE="-1">LIST</FONT><DD>
<A NAME="ixAAK"></A>
Returns the elements of <FONT SIZE="-1">LIST</FONT> in a random order


<P>




<PRE>
    @cards = shuffle 0..51      # 0..51 in a random order

</PRE>


<DT>sum <FONT SIZE="-1">LIST</FONT><DD>
<A NAME="ixAAL"></A>
Returns the sum of all the elements in <FONT SIZE="-1">LIST</FONT>. If <FONT SIZE="-1">LIST</FONT> is empty then
<TT>&quot;undef&quot;</TT> is returned.


<P>




<PRE>
    $foo = sum 1..10                # 55
    $foo = sum 3,9,12               # 24
    $foo = sum @bar, @baz           # whatever

</PRE>




<P>


This function could be implemented using <TT>&quot;reduce&quot;</TT> like this


<P>




<PRE>
    $foo = reduce { $a + $b } 1..10

</PRE>




<P>


If your algorithm requires that <TT>&quot;sum&quot;</TT> produce an identity of 0, then
make sure that you always pass <TT>0</TT> as the first argument to prevent
<TT>&quot;undef&quot;</TT> being returned


<P>




<PRE>
  $foo = sum 0, @values;

</PRE>


</DL>
<A NAME="lbAE">&nbsp;</A>
<H2>KNOWN BUGS</H2>

<A NAME="ixAAM"></A>
With perl versions prior to 5.005 there are some cases where reduce
will return an incorrect result. This will show up as test 7 of
reduce.t failing.
<A NAME="lbAF">&nbsp;</A>
<H2>SUGGESTED ADDITIONS</H2>

<A NAME="ixAAN"></A>
The following are additions that have been requested, but I have been reluctant
to add due to them being very simple to implement in perl
<P>



<PRE>
  # One argument is true

  sub any { $_ &amp;&amp; return 1 for @_; 0 }

  # All arguments are true

  sub all { $_ || return 0 for @_; 1 }

  # All arguments are false

  sub none { $_ &amp;&amp; return 0 for @_; 1 }

  # One argument is false

  sub notall { $_ || return 1 for @_; 0 }

  # How many elements are true

  sub true { scalar grep { $_ } @_ }

  # How many elements are false

  sub false { scalar grep { !$_ } @_ }

</PRE>


<A NAME="lbAG">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAO"></A>
Scalar::Util, List::MoreUtils
<A NAME="lbAH">&nbsp;</A>
<H2>COPYRIGHT</H2>

<A NAME="ixAAP"></A>
Copyright (c) 1997-2007 Graham Barr &lt;<A HREF="mailto:gbarr@pobox.com">gbarr@pobox.com</A>&gt;. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">KNOWN BUGS</A><DD>
<DT><A HREF="#lbAF">SUGGESTED ADDITIONS</A><DD>
<DT><A HREF="#lbAG">SEE ALSO</A><DD>
<DT><A HREF="#lbAH">COPYRIGHT</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:32 GMT, December 24, 2015
</div></div>
</body>
</HTML>
