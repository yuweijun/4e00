<!DOCTYPE html>

<HTML><head><TITLE>Manpage of Encode::Unicode</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"documentation"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>Encode::Unicode</H1>
Section: Perl Programmers Reference Guide (3pm)<BR>Updated: 2009-04-14<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Encode::Unicode -- Various Unicode Transformation Formats
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
    use Encode qw/encode decode/;
    $ucs2 = encode(&quot;UCS-2BE&quot;, $utf8);
    $utf8 = decode(&quot;UCS-2BE&quot;, $ucs2);

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>ABSTRACT</H2>

<A NAME="ixAAD"></A>
This module implements all Character Encoding Schemes of Unicode that
are officially documented by Unicode Consortium (except, of course,
for <FONT SIZE="-1">UTF-8</FONT>, which is a native format in perl).
<DL COMPACT>
<DT>&lt;<A HREF="http://www.unicode.org/glossary/">http://www.unicode.org/glossary/</A>&gt; says:<DD>
<A NAME="ixAAE"></A>
<I>Character Encoding Scheme</I> A character encoding form plus byte
serialization. There are Seven character encoding schemes in Unicode:
<FONT SIZE="-1">UTF-8</FONT>, <FONT SIZE="-1">UTF-16</FONT>, <FONT SIZE="-1">UTF-16BE</FONT>, <FONT SIZE="-1">UTF-16LE</FONT>, <FONT SIZE="-1">UTF-32</FONT> (<FONT SIZE="-1">UCS-4</FONT>), <FONT SIZE="-1">UTF-32BE</FONT> (<FONT SIZE="-1">UCS-4BE</FONT>) and
<FONT SIZE="-1">UTF-32LE</FONT> (<FONT SIZE="-1">UCS-4LE</FONT>), and <FONT SIZE="-1">UTF-7</FONT>.


<P>


Since <FONT SIZE="-1">UTF-7</FONT> is a 7-bit (re)encoded version of <FONT SIZE="-1">UTF-16BE</FONT>, It is not part of
Unicode's Character Encoding Scheme.  It is separately implemented in
Encode::Unicode::UTF7.  For details see Encode::Unicode::UTF7.
<DT>Quick Reference<DD>
<A NAME="ixAAF"></A>


<PRE>
                Decodes from ord(N)           Encodes chr(N) to...
       octet/char BOM S.P d800-dfff  ord &gt; 0xffff     \x{1abcd} ==
  ---------------+-----------------+------------------------------
  UCS-2BE       2   N   N  is bogus                  Not Available
  UCS-2LE       2   N   N     bogus                  Not Available
  UTF-16      2/4   Y   Y  is   S.P           S.P            BE/LE
  UTF-16BE    2/4   N   Y       S.P           S.P    0xd82a,0xdfcd
  UTF-16LE    2/4   N   Y       S.P           S.P    0x2ad8,0xcddf
  UTF-32        4   Y   -  is bogus         As is            BE/LE
  UTF-32BE      4   N   -     bogus         As is       0x0001abcd
  UTF-32LE      4   N   -     bogus         As is       0xcdab0100
  UTF-8       1-4   -   -     bogus   &gt;= 4 octets   \xf0\x9a\af\8d
  ---------------+-----------------+------------------------------

</PRE>


</DL>
<A NAME="lbAE">&nbsp;</A>
<H2>Size, Endianness, and BOM</H2>

<A NAME="ixAAG"></A>
You can categorize these <FONT SIZE="-1">CES</FONT> by 3 criteria:  size of each character,
endianness, and Byte Order Mark.
<A NAME="lbAF">&nbsp;</A>
<H3>by size</H3>

<A NAME="ixAAH"></A>
<FONT SIZE="-1">UCS-2</FONT> is a fixed-length encoding with each character taking 16 bits.
It <B>does not</B> support <I>surrogate pairs</I>.  When a surrogate pair
is encountered during <I>decode()</I>, its place is filled with \x{<FONT SIZE="-1">FFFD</FONT>}
if <I></I><FONT SIZE="-1"><I>CHECK</I></FONT><I></I> is 0, or the routine croaks if <I></I><FONT SIZE="-1"><I>CHECK</I></FONT><I></I> is 1.  When a
character whose ord value is larger than 0xFFFF is encountered,
its place is filled with \x{<FONT SIZE="-1">FFFD</FONT>} if <I></I><FONT SIZE="-1"><I>CHECK</I></FONT><I></I> is 0, or the routine
croaks if <I></I><FONT SIZE="-1"><I>CHECK</I></FONT><I></I> is 1.
<P>

<FONT SIZE="-1">UTF-16</FONT> is almost the same as <FONT SIZE="-1">UCS-2</FONT> but it supports <I>surrogate pairs</I>.
When it encounters a high surrogate (0xD800-0xDBFF), it fetches the
following low surrogate (0xDC00-0xDFFF) and <TT>&quot;desurrogate&quot;</TT>s them to
form a character.  Bogus surrogates result in death.  When \x{10000}
or above is encountered during <I>encode()</I>, it <TT>&quot;ensurrogate&quot;</TT>s them and
pushes the surrogate pair to the output stream.
<P>

<FONT SIZE="-1">UTF-32</FONT> (<FONT SIZE="-1">UCS-4</FONT>) is a fixed-length encoding with each character taking 32 bits.
Since it is 32-bit, there is no need for <I>surrogate pairs</I>.
<A NAME="lbAG">&nbsp;</A>
<H3>by endianness</H3>

<A NAME="ixAAI"></A>
The first (and now failed) goal of Unicode was to map all character
repertoires into a fixed-length integer so that programmers are happy.
Since each character is either a <I>short</I> or <I>long</I> in C, you have to
pay attention to the endianness of each platform when you pass data
to one another.
<P>

Anything marked as <FONT SIZE="-1">BE</FONT> is Big Endian (or network byte order) and <FONT SIZE="-1">LE</FONT> is
Little Endian (aka <FONT SIZE="-1">VAX</FONT> byte order).  For anything not marked either
<FONT SIZE="-1">BE</FONT> or <FONT SIZE="-1">LE</FONT>, a character called Byte Order Mark (<FONT SIZE="-1">BOM</FONT>) indicating the
endianness is prepended to the string.
<P>

<FONT SIZE="-1">CAVEAT:</FONT> Though <FONT SIZE="-1">BOM</FONT> in utf8 (\xEF\xBB\xBF) is valid, it is meaningless
and as of this writing Encode suite just leave it as is (\x{FeFF}).
<DL COMPACT>
<DT><FONT SIZE="-1">BOM</FONT> as integer when fetched in network byte order<DD>
<A NAME="ixAAJ"></A>


<PRE>
              16         32 bits/char
  -------------------------
  BE      0xFeFF 0x0000FeFF
  LE      0xFFFe 0xFFFe0000
  -------------------------

</PRE>


</DL>
<P>

This modules handles the <FONT SIZE="-1">BOM</FONT> as follows.
<DL COMPACT>
<DT>*<DD>
When <FONT SIZE="-1">BE</FONT> or <FONT SIZE="-1">LE</FONT> is explicitly stated as the name of encoding, <FONT SIZE="-1">BOM</FONT> is
simply treated as a normal character (<FONT SIZE="-1">ZERO</FONT> <FONT SIZE="-1">WIDTH</FONT> NO-BREAK <FONT SIZE="-1">SPACE</FONT>).
<DT>*<DD>
When <FONT SIZE="-1">BE</FONT> or <FONT SIZE="-1">LE</FONT> is omitted during <I>decode()</I>, it checks if <FONT SIZE="-1">BOM</FONT> is at the
beginning of the string; if one is found, the endianness is set to
what the <FONT SIZE="-1">BOM</FONT> says.  If no <FONT SIZE="-1">BOM</FONT> is found, the routine dies.
<DT>*<DD>
When <FONT SIZE="-1">BE</FONT> or <FONT SIZE="-1">LE</FONT> is omitted during <I>encode()</I>, it returns a BE-encoded
string with <FONT SIZE="-1">BOM</FONT> prepended.  So when you want to encode a whole text
file, make sure you <I>encode()</I> the whole text at once, not line by line
or each line, not file, will have a <FONT SIZE="-1">BOM</FONT> prepended.
<DT>*<DD>
<TT>&quot;UCS-2&quot;</TT> is an exception.  Unlike others, this is an alias of <FONT SIZE="-1">UCS-2BE</FONT>.
<FONT SIZE="-1">UCS-2</FONT> is already registered by <FONT SIZE="-1">IANA</FONT> and others that way.
</DL>
<A NAME="lbAH">&nbsp;</A>
<H2>Surrogate Pairs</H2>

<A NAME="ixAAK"></A>
To say the least, surrogate pairs were the biggest mistake of the
Unicode Consortium.  But according to the late Douglas Adams in <I>The
Hitchhiker's Guide to the Galaxy</I> Trilogy, <TT>&quot;In the beginning the
Universe was created. This has made a lot of people very angry and
been widely regarded as a bad move&quot;</TT>.  Their mistake was not of this
magnitude so let's forgive them.
<P>

(I don't dare make any comparison with Unicode Consortium and the
Vogons here ;)  Or, comparing Encode to Babel Fish is completely
appropriate --- if you can only stick this into your ear :)
<P>

Surrogate pairs were born when the Unicode Consortium finally
admitted that 16 bits were not big enough to hold all the world's
character repertoires.  But they already made <FONT SIZE="-1">UCS-2</FONT> 16-bit.  What
do we do?
<P>

Back then, the range 0xD800-0xDFFF was not allocated.  Let's split
that range in half and use the first half to represent the <TT>&quot;upper
half of a character&quot;</TT> and the second half to represent the <TT>&quot;lower
half of a character&quot;</TT>.  That way, you can represent 1024 * 1024 =
1048576 more characters.  Now we can store character ranges up to
\x{10ffff} even with 16-bit encodings.  This pair of half-character is
now called a <I>surrogate pair</I> and <FONT SIZE="-1">UTF-16</FONT> is the name of the encoding
that embraces them.
<P>

Here is a formula to ensurrogate a Unicode character \x{10000} and
above;
<P>



<PRE>
  $hi = ($uni - 0x10000) / 0x400 + 0xD800;
  $lo = ($uni - 0x10000) % 0x400 + 0xDC00;

</PRE>


<P>

And to desurrogate;
<P>



<PRE>
 $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);

</PRE>


<P>

Note this move has made \x{D800}-\x{<FONT SIZE="-1">DFFF</FONT>} into a forbidden zone but
perl does not prohibit the use of characters within this range.  To perl,
every one of \x{0000_0000} up to \x{ffff_ffff} (*) is <I>a character</I>.
<P>



<PRE>
  (*) or \x{ffff_ffff_ffff_ffff} if your perl is compiled with 64-bit
  integer support!

</PRE>


<A NAME="lbAI">&nbsp;</A>
<H2>Error Checking</H2>

<A NAME="ixAAL"></A>
Unlike most encodings which accept various ways to handle errors,
Unicode encodings simply croaks.
<P>



<PRE>
  % perl -MEncode -e'$_ = &quot;\xfe\xff\xd8\xd9\xda\xdb\0\n&quot;' \
         -e'Encode::from_to($_, &quot;utf16&quot;,&quot;shift_jis&quot;, 0); print'
  UTF-16:Malformed LO surrogate d8d9 at /path/to/Encode.pm line 184.
  % perl -MEncode -e'$a = &quot;BOM missing&quot;' \
         -e' Encode::from_to($a, &quot;utf16&quot;, &quot;shift_jis&quot;, 0); print'
  UTF-16:Unrecognised BOM 424f at /path/to/Encode.pm line 184.

</PRE>


<P>

Unlike other encodings where mappings are not one-to-one against
Unicode, UTFs are supposed to map 100% against one another.  So Encode
is more strict on UTFs.
<P>

Consider that ``division by zero'' of Encode :)
<A NAME="lbAJ">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAM"></A>
Encode, Encode::Unicode::UTF7, &lt;<A HREF="http://www.unicode.org/glossary/">http://www.unicode.org/glossary/</A>&gt;,
&lt;<A HREF="http://www.unicode.org/unicode/faq/utf_bom.html">http://www.unicode.org/unicode/faq/utf_bom.html</A>&gt;,
<P>

<FONT SIZE="-1">RFC</FONT> 2781 &lt;<A HREF="http://rfc.net/rfc2781.html">http://rfc.net/rfc2781.html</A>&gt;,
<P>

The whole Unicode standard &lt;<A HREF="http://www.unicode.org/unicode/uni2book/u2.html">http://www.unicode.org/unicode/uni2book/u2.html</A>&gt;
<P>

Ch. 15, pp. 403 of <TT>&quot;Programming Perl (3rd Edition)&quot;</TT>
by Larry Wall, Tom Christiansen, Jon Orwant;
O'Reilly &amp; Associates; <FONT SIZE="-1">ISBN</FONT> 0-596-00027-8
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">ABSTRACT</A><DD>
<DT><A HREF="#lbAE">Size, Endianness, and BOM</A><DD>
<DL>
<DT><A HREF="#lbAF">by size</A><DD>
<DT><A HREF="#lbAG">by endianness</A><DD>
</DL>
<DT><A HREF="#lbAH">Surrogate Pairs</A><DD>
<DT><A HREF="#lbAI">Error Checking</A><DD>
<DT><A HREF="#lbAJ">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:24 GMT, December 24, 2015
</div></div>
</body>
</HTML>
