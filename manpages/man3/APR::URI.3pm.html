<!DOCTYPE html>

<HTML><head><TITLE>Manpage of docs::api::APR::URI</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>docs::api::APR::URI</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2008-04-17<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

APR::URI - Perl API for URI manipulations
<A NAME="lbAC">&nbsp;</A>
<H2>Synopsis</H2>

<A NAME="ixAAC"></A>


<PRE>
  use APR::URI ();
  
  my $url = '<A HREF="http://user:pass@example.com:80/foo?bar#item5';">http://user:pass@example.com:80/foo?bar#item5';</A>
  
  # parse and break the url into components
  my $parsed = APR::URI-&gt;parse($r-&gt;pool, $url);
  print $parsed-&gt;scheme;
  print $parsed-&gt;user;
  print $parsed-&gt;password;
  print $parsed-&gt;hostname;
  print $parsed-&gt;port;
  print $parsed-&gt;path;
  print $parsed-&gt;rpath;
  print $parsed-&gt;query;
  print $parsed-&gt;fragment;
  
  # reconstruct the url, after changing some components and completely
  # removing other
  $parsed-&gt;scheme($new_scheme);
  $parsed-&gt;user(undef);
  $parsed-&gt;password(undef);
  $parsed-&gt;hostname($new_hostname);
  $parsed-&gt;port($new_port);
  $parsed-&gt;path($new_path);
  $parsed-&gt;query(undef);
  $parsed-&gt;fragment(undef);
  print $parsed-&gt;unparse;
  
  # get the password field too (by default it's not revealed)
  use APR::Const -compile =&gt; qw(URI_UNP_REVEALPASSWORD);
  print $parsed-&gt;unparse(APR::Const::URI_UNP_REVEALPASSWORD);
  
  # what the default port for the ftp protocol?
  my $ftp_port = APR::URI::port_of_scheme(&quot;ftp&quot;);

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>Description</H2>

<A NAME="ixAAD"></A>
<TT>&quot;APR::URI&quot;</TT> allows you to parse <FONT SIZE="-1">URI</FONT> strings, manipulate each of the
<FONT SIZE="-1">URI</FONT> elements and deparse them back into URIs.
<P>

All <TT>&quot;APR::URI&quot;</TT> object accessors accept a string or an <TT>&quot;undef&quot;</TT> value
as an argument. Same goes for return value. It's important to
distinguish between an empty string and <TT>&quot;undef&quot;</TT>. For example let's
say your code was:
<P>



<PRE>
  my $uri = '<A HREF="http://example.com/foo?bar#item5';">http://example.com/foo?bar#item5';</A>
  my $parsed = APR::URI-&gt;parse($r-&gt;pool, $uri);

</PRE>


<P>

Now you no longer want to the query and fragment components in the
final url. If you do:
<P>



<PRE>
  $parsed-&gt;fragment('');
  $parsed-&gt;query('');

</PRE>


<P>

followed by:
<P>



<PRE>
  my $new_uri = parsed-&gt;unparse;

</PRE>


<P>

the resulting <FONT SIZE="-1">URI</FONT> will be:
<P>



<PRE>
  <A HREF="http://example.com/foo?#">http://example.com/foo?#</A>

</PRE>


<P>

which is probably not something that you've expected. In order to get
rid of the separators, you must completely unset the fields you don't
want to see. So, if you do:
<P>



<PRE>
  $parsed-&gt;fragment(undef);
  $parsed-&gt;query(undef);

</PRE>


<P>

followed by:
<P>



<PRE>
  my $new_uri = parsed-&gt;unparse;

</PRE>


<P>

the resulting <FONT SIZE="-1">URI</FONT> will be:
<P>



<PRE>
   <A HREF="http://example.com/foo">http://example.com/foo</A>

</PRE>


<P>

As mentioned earlier the same goes for return values, so continuing
this example:
<P>



<PRE>
  my $new_fragment = $parsed-&gt;fragment();
  my $new_query    = $parsed-&gt;query();

</PRE>


<P>

Both values now contain <TT>&quot;undef&quot;</TT>, therefore you must be careful when
using the return values, when you use them, as you may get warnings.
<P>

Also make sure you read through <TT>&quot;the unparse()
section&quot;</TT> as various optional flags affect how the
deparsed <FONT SIZE="-1">URI</FONT> is rendered.
<A NAME="lbAE">&nbsp;</A>
<H2>API</H2>

<A NAME="ixAAE"></A>
<TT>&quot;APR::URI&quot;</TT> provides the following functions and/or methods:
<A NAME="lbAF">&nbsp;</A>
<H3>fragment</H3>



<A NAME="ixAAF"></A>
Get/set trailing ``#fragment'' string
<P>



<PRE>
  $oldval = $parsed-&gt;fragment($newval);

</PRE>


<DL COMPACT>
<DT>obj: $parsed ( APR::URI object )<DD>


<A NAME="ixAAG"></A>

<DT>opt arg1: $newval ( string or undef )<DD>


<A NAME="ixAAH"></A>
<DT>ret: $oldval ( string or undef )<DD>


<A NAME="ixAAI"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixAAJ"></A>

</DL>
<A NAME="lbAG">&nbsp;</A>
<H3>hostinfo</H3>



<A NAME="ixAAK"></A>
Get/set combined <TT>&quot;[user[:password]@]host[:port]&quot;</TT>
<P>



<PRE>
  $oldval = $parsed-&gt;hostinfo($newval);

</PRE>


<DL COMPACT>
<DT>obj: $parsed ( APR::URI object )<DD>


<A NAME="ixAAL"></A>

<DT>opt arg1: $newval ( string or undef )<DD>


<A NAME="ixAAM"></A>
<DT>ret: $oldval ( string or undef )<DD>


<A NAME="ixAAN"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixAAO"></A>

</DL>
<P>

The <TT>&quot;hostinfo&quot;</TT> value is set automatically when
<TT>&quot;parse()&quot;</TT> is called.
<P>

It's not updated if any of the individual fields is modified.
<P>

It's not used when <TT>&quot;unparse()&quot;</TT> is called.
<A NAME="lbAH">&nbsp;</A>
<H3>hostname</H3>



<A NAME="ixAAP"></A>
Get/set hostname
<P>



<PRE>
  $oldval = $parsed-&gt;hostname($newval);

</PRE>


<DL COMPACT>
<DT>obj: $parsed ( APR::URI object )<DD>


<A NAME="ixAAQ"></A>

<DT>opt arg1: $newval ( string or undef )<DD>


<A NAME="ixAAR"></A>
<DT>ret: $oldval ( string or undef )<DD>


<A NAME="ixAAS"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixAAT"></A>

</DL>
<A NAME="lbAI">&nbsp;</A>
<H3>password</H3>



<A NAME="ixAAU"></A>
Get/set password (as in <A HREF="http://user:password@host:port/)">http://user:password@host:port/)</A>
<P>



<PRE>
  $oldval = $parsed-&gt;password($newval);

</PRE>


<DL COMPACT>
<DT>obj: $parsed ( APR::URI object )<DD>


<A NAME="ixAAV"></A>

<DT>opt arg1: $newval ( string or undef )<DD>


<A NAME="ixAAW"></A>
<DT>ret: $oldval ( string or undef )<DD>


<A NAME="ixAAX"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixAAY"></A>

</DL>
<A NAME="lbAJ">&nbsp;</A>
<H3>parse</H3>



<A NAME="ixAAZ"></A>
Parse the <FONT SIZE="-1">URI</FONT> string into <FONT SIZE="-1">URI</FONT> components
<P>



<PRE>
  $parsed = APR::URI-&gt;parse($pool, $uri);

</PRE>


<DL COMPACT>
<DT>obj: $parsed ( APR::URI object or class )<DD>


<A NAME="ixABA"></A>

<DT>arg1: $pool ( string ) ( APR::Pool object )<DD>


<A NAME="ixABB"></A>
<DT>arg2: $uri ( string )<DD>


<A NAME="ixABC"></A>

The <FONT SIZE="-1">URI</FONT> to parse
<DT>ret: $parsed ( APR::URI object or class )<DD>


<A NAME="ixABD"></A>
The parsed <FONT SIZE="-1">URI</FONT> object
<DT>since: 2.0.00<DD>
<A NAME="ixABE"></A>
</DL>
<P>

After parsing, if a component existed but was an empty string
(e.g. empty query <I><A HREF="http://hostname/path?">http://hostname/path?</A></I>) --- the corresponding
accessor will return an empty string. If a component didn't exist
(e.g. no query part <I><A HREF="http://hostname/path">http://hostname/path</A></I>) --- the corresponding
accessor will return <TT>&quot;undef&quot;</TT>.
<A NAME="lbAK">&nbsp;</A>
<H3>path</H3>



<A NAME="ixABF"></A>
Get/set the request path
<P>



<PRE>
  $oldval = $parsed-&gt;path($newval);

</PRE>


<DL COMPACT>
<DT>obj: $parsed ( APR::URI object )<DD>


<A NAME="ixABG"></A>

<DT>opt arg1: $newval ( string or undef )<DD>


<A NAME="ixABH"></A>
<DT>ret: $oldval ( string or undef )<DD>


<A NAME="ixABI"></A>

<TT>&quot;/&quot;</TT> if only <TT>&quot;<A HREF="scheme://host">scheme://host</A>&quot;</TT>
<DT>since: 2.0.00<DD>
<A NAME="ixABJ"></A>
</DL>
<A NAME="lbAL">&nbsp;</A>
<H3>rpath</H3>



<A NAME="ixABK"></A>
Gets the <TT>&quot;path&quot;</TT> minus the 
<TT>&quot;path_info&quot;</TT>
<P>



<PRE>
  $rpath =  $parsed-&gt;rpath();

</PRE>


<DL COMPACT>
<DT>obj: $parsed ( APR::URI object )<DD>


<A NAME="ixABL"></A>

<DT>opt arg1: $newval ( string or undef )<DD>


<A NAME="ixABM"></A>
<DT>ret: $oldval ( string or undef )<DD>


<A NAME="ixABN"></A>

The path minus the <I>path_info</I>
<DT>since: 2.0.00<DD>
<A NAME="ixABO"></A>
</DL>
<A NAME="lbAM">&nbsp;</A>
<H3>port</H3>



<A NAME="ixABP"></A>
Get/set port number
<P>



<PRE>
  $oldval = $parsed-&gt;port($newval);

</PRE>


<DL COMPACT>
<DT>obj: $parsed ( APR::URI object )<DD>


<A NAME="ixABQ"></A>

<DT>opt arg1: $newval ( number or string or undef )<DD>


<A NAME="ixABR"></A>
<DT>ret: $oldval ( string or undef )<DD>


<A NAME="ixABS"></A>

If the port component didn't appear in the parsed <FONT SIZE="-1">URI</FONT>, <FONT SIZE="-1">APR</FONT> internally
calls <TT>&quot;port_of_scheme()&quot;</TT> to find out the port
number for the given <TT>&quot;scheme()&quot;</TT>.
<DT>since: 2.0.00<DD>
<A NAME="ixABT"></A>
</DL>
<A NAME="lbAN">&nbsp;</A>
<H3>port_of_scheme</H3>



<A NAME="ixABU"></A>
Return the default port for a given scheme.  The recognized schemes
are http, ftp, https, gopher, wais, nntp, snews and prospero.
<P>



<PRE>
  $port = APR::URI::port_of_scheme($scheme);

</PRE>


<DL COMPACT>
<DT>obj: $scheme ( string )<DD>


<A NAME="ixABV"></A>
The scheme string
<DT>ret: $port (integer)<DD>


<A NAME="ixABW"></A>
The default port for this scheme
<DT>since: 2.0.00<DD>
<A NAME="ixABX"></A>
</DL>
<A NAME="lbAO">&nbsp;</A>
<H3>query</H3>



<A NAME="ixABY"></A>
Get/set the query string (the part starting after <TT>'?'</TT> and all the
way till the end or the <TT>'#fragment'</TT> part if the latter exists).
<P>



<PRE>
  $oldval = $parsed-&gt;query($newval);

</PRE>


<DL COMPACT>
<DT>obj: $parsed ( APR::URI object )<DD>


<A NAME="ixABZ"></A>

<DT>opt arg1: $newval ( string or undef )<DD>


<A NAME="ixACA"></A>
<DT>ret: $oldval ( string or undef )<DD>


<A NAME="ixACB"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixACC"></A>

</DL>
<A NAME="lbAP">&nbsp;</A>
<H3>scheme</H3>



<A NAME="ixACD"></A>
Get/set the protocol scheme (``http'', ``ftp'', ...)
<P>



<PRE>
  $oldval = $parsed-&gt;scheme($newval);

</PRE>


<DL COMPACT>
<DT>obj: $parsed ( APR::URI object )<DD>


<A NAME="ixACE"></A>

<DT>opt arg1: $newval ( string or undef )<DD>


<A NAME="ixACF"></A>
<DT>ret: $oldval ( string or undef )<DD>


<A NAME="ixACG"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixACH"></A>

</DL>
<A NAME="lbAQ">&nbsp;</A>
<H3>user</H3>



<A NAME="ixACI"></A>
Get/set user name (as in <A HREF="http://user:password@host:port/)">http://user:password@host:port/)</A>
<P>



<PRE>
  $oldval = $parsed-&gt;user($newval);

</PRE>


<DL COMPACT>
<DT>obj: $parsed ( APR::URI object )<DD>


<A NAME="ixACJ"></A>

<DT>opt arg1: $newval ( string or undef )<DD>


<A NAME="ixACK"></A>
<DT>ret: $oldval ( string or undef )<DD>


<A NAME="ixACL"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixACM"></A>

</DL>
<A NAME="lbAR">&nbsp;</A>
<H3>unparse</H3>



<A NAME="ixACN"></A>
Unparse the <FONT SIZE="-1">URI</FONT> components back into a <FONT SIZE="-1">URI</FONT> string
<P>



<PRE>
  $new_uri = $parsed-&gt;unparse();
  $new_uri = $parsed-&gt;unparse($flags);

</PRE>


<DL COMPACT>
<DT>obj: $parsed ( APR::URI object )<DD>


<A NAME="ixACO"></A>

<DT>opt arg1: $flags ( the APR::Const :uri constants )<DD>


<A NAME="ixACP"></A>

By default the constant <TT>&quot;APR::Const::URI_UNP_OMITPASSWORD&quot;</TT> is passed.


<P>


If you need to pass more than one flag use unary <TT>&quot;|&quot;</TT>, e.g.:


<P>




<PRE>
  $flags = APR::Const::URI_UNP_OMITUSER|APR::Const::URI_UNP_OMITPASSWORD;

</PRE>




<P>


The valid <TT>&quot;flags&quot;</TT> constants are listed next
<DT>ret: $new_uri ( string )<DD>


<A NAME="ixACQ"></A>

<DT>since: 2.0.00<DD>
<A NAME="ixACR"></A>

</DL>
<P>

Valid <TT>&quot;flags&quot;</TT> constants:
<P>

To import all <FONT SIZE="-1">URI</FONT> constants you could do:
<P>



<PRE>
  use APR::Const -compile =&gt; qw(:uri);

</PRE>


<P>

but there is a significant amount of them, most irrelevant to this
method. Therefore you probably don't want to do that. Instead specify
explicitly the ones that you need. All the relevant to this method
constants start with <TT>&quot;APR::URI_UNP_&quot;</TT>.
<P>

And the available constants are:
<DL COMPACT>
<DT>APR::Const::URI_UNP_OMITSITEPART<DD>


<A NAME="ixACS"></A>
Don't show <TT>&quot;scheme&quot;</TT>, <TT>&quot;user&quot;</TT>,
<TT>&quot;password&quot;</TT>, <TT>&quot;hostname&quot;</TT> and
<TT>&quot;port&quot;</TT> components (i.e. if you want only the relative
<FONT SIZE="-1">URI</FONT>)
<DT>APR::Const::URI_UNP_OMITUSER<DD>


<A NAME="ixACT"></A>
Hide the <TT>&quot;user&quot;</TT> component
<DT>APR::Const::URI_UNP_OMITPASSWORD<DD>


<A NAME="ixACU"></A>
Hide the <TT>&quot;password&quot;</TT> component (the default)
<DT>APR::Const::URI_UNP_REVEALPASSWORD<DD>


<A NAME="ixACV"></A>
Reveal the <TT>&quot;password&quot;</TT> component
<DT>APR::Const::URI_UNP_OMITPATHINFO<DD>


<A NAME="ixACW"></A>
Don't show <TT>&quot;path&quot;</TT>, <TT>&quot;query&quot;</TT> and
<TT>&quot;fragment&quot;</TT> components
<DT>APR::Const::URI_UNP_OMITQUERY<DD>


<A NAME="ixACX"></A>
Don't show <TT>&quot;query&quot;</TT> and <TT>&quot;fragment&quot;</TT>
components
</DL>
<P>

Notice that some flags overlap.
<P>

If the optional <TT>$flags</TT> argument is passed and contains no
<TT>&quot;APR::Const::URI_UNP_OMITPASSWORD&quot;</TT> and no <TT>&quot;APR::Const::URI_UNP_REVEALPASSWORD&quot;</TT> ---
the <TT>&quot;password&quot;</TT> part will be rendered as a literal
<TT>&quot;XXXXXXXX&quot;</TT> string.
<P>

If the <TT>&quot;port&quot;</TT> number matches the
<TT>&quot;port_of_scheme()&quot;</TT>, the unparsed <FONT SIZE="-1">URI</FONT> won't
include it and there is no flag to force that <TT>&quot;port&quot;</TT> to
appear. If the <TT>&quot;port&quot;</TT> number is non-standard it will show
up in the unparsed string.
<P>

Examples:
<P>

Starting with the parsed <FONT SIZE="-1">URL:</FONT>
<P>



<PRE>
  use APR::URI ();
  my $url = '<A HREF="http://user:pass@example.com:80/foo?bar#item5';">http://user:pass@example.com:80/foo?bar#item5';</A>
  my $parsed = APR::URI-&gt;parse($r-&gt;pool, $url);

</PRE>


<P>

deparse it back including and excluding parts, using different values
for the optional <TT>&quot;flags&quot;</TT> argument:
<DL COMPACT>
<DT>*<DD>
Show all but the <TT>&quot;password&quot;</TT> fields:


<P>




<PRE>
  print $parsed-&gt;unparse;

</PRE>




<P>


Prints:


<P>




<PRE>
  <A HREF="http://user@example.com/foo?bar#item5">http://user@example.com/foo?bar#item5</A>

</PRE>




<P>


Notice that the <TT>&quot;port&quot;</TT> field is gone too, since it was a
default <TT>&quot;port&quot;</TT> for <TT>&quot;scheme&quot;</TT>
<TT>&quot;http://&quot;</TT>.
<DT>*<DD>
Include the <TT>&quot;password&quot;</TT> field (by default it's not revealed)


<P>




<PRE>
  use APR::Const -compile =&gt; qw(URI_UNP_REVEALPASSWORD);
  print $parsed-&gt;unparse(APR::Const::URI_UNP_REVEALPASSWORD);

</PRE>




<P>


Prints:


<P>




<PRE>
  <A HREF="http://user:pass@example.com/foo?bar#item5">http://user:pass@example.com/foo?bar#item5</A>

</PRE>


<DT>*<DD>
Show all fields but the last three, <TT>&quot;path&quot;</TT>,
<TT>&quot;query&quot;</TT> and <TT>&quot;fragment&quot;</TT>:


<P>




<PRE>
  use APR::Const -compile =&gt; qw(URI_UNP_REVEALPASSWORD
                                APR::Const::URI_UNP_OMITPATHINFO);
  print $parsed-&gt;unparse(
      APR::Const::URI_UNP_REVEALPASSWORD|URI_UNP_OMITPATHINFO);

</PRE>




<P>


Prints:


<P>




<PRE>
  <A HREF="http://user:pass@example.com">http://user:pass@example.com</A>

</PRE>


</DL>
<A NAME="lbAS">&nbsp;</A>
<H2>See Also</H2>

<A NAME="ixACY"></A>
<TT>&quot;Apache2::URI&quot;</TT>, mod_perl 2.0
documentation.
<A NAME="lbAT">&nbsp;</A>
<H2>Copyright</H2>

<A NAME="ixACZ"></A>
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
<A NAME="lbAU">&nbsp;</A>
<H2>Authors</H2>

<A NAME="ixADA"></A>
The mod_perl development team and numerous
contributors.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">Synopsis</A><DD>
<DT><A HREF="#lbAD">Description</A><DD>
<DT><A HREF="#lbAE">API</A><DD>
<DL>
<DT><A HREF="#lbAF">fragment</A><DD>
<DT><A HREF="#lbAG">hostinfo</A><DD>
<DT><A HREF="#lbAH">hostname</A><DD>
<DT><A HREF="#lbAI">password</A><DD>
<DT><A HREF="#lbAJ">parse</A><DD>
<DT><A HREF="#lbAK">path</A><DD>
<DT><A HREF="#lbAL">rpath</A><DD>
<DT><A HREF="#lbAM">port</A><DD>
<DT><A HREF="#lbAN">port_of_scheme</A><DD>
<DT><A HREF="#lbAO">query</A><DD>
<DT><A HREF="#lbAP">scheme</A><DD>
<DT><A HREF="#lbAQ">user</A><DD>
<DT><A HREF="#lbAR">unparse</A><DD>
</DL>
<DT><A HREF="#lbAS">See Also</A><DD>
<DT><A HREF="#lbAT">Copyright</A><DD>
<DT><A HREF="#lbAU">Authors</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:11 GMT, December 24, 2015
</div></div>
</body>
</HTML>
