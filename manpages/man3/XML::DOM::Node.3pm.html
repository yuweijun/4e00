<!DOCTYPE html>

<HTML><head><TITLE>Manpage of XML::DOM::Node</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>XML::DOM::Node</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2000-02-16<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

XML::DOM::Node - Super class of all nodes in XML::DOM
<A NAME="lbAC">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAC"></A>
XML::DOM::Node is the super class of all nodes in an <FONT SIZE="-1">XML::DOM</FONT> document.
This means that all nodes that subclass XML::DOM::Node also inherit all
the methods that XML::DOM::Node implements.
<A NAME="lbAD">&nbsp;</A>
<H3><FONT SIZE="-1">GLOBAL</FONT> <FONT SIZE="-1">VARIABLES</FONT></H3>

<A NAME="ixAAD"></A>
<DL COMPACT>
<DT>@NodeNames<DD>


<A NAME="ixAAE"></A>
The variable <TT>@XML::DOM::Node::NodeNames</TT> maps the node type constants to strings.
It is used by XML::DOM::Node::getNodeTypeName.
</DL>
<A NAME="lbAE">&nbsp;</A>
<H3><FONT SIZE="-1">METHODS</FONT></H3>

<A NAME="ixAAF"></A>
<DL COMPACT>
<DT>getNodeType<DD>
<A NAME="ixAAG"></A>
Return an integer indicating the node type. See <FONT SIZE="-1">XML::DOM</FONT> constants.
<DT>getNodeName<DD>
<A NAME="ixAAH"></A>
Return a property or a hardcoded string, depending on the node type.
Here are the corresponding functions or values:


<P>




<PRE>
 Attr                   getName
 AttDef                 getName
 AttlistDecl            getName
 CDATASection           &quot;#cdata-section&quot;
 Comment                &quot;#comment&quot;
 Document               &quot;#document&quot;
 DocumentType           getNodeName
 DocumentFragment       &quot;#document-fragment&quot;
 Element                getTagName
 ElementDecl            getName
 EntityReference        getEntityName
 Entity                 getNotationName
 Notation               getName
 ProcessingInstruction  getTarget
 Text                   &quot;#text&quot;
 XMLDecl                &quot;#xml-declaration&quot;

</PRE>




<P>


<B>Not In </B><FONT SIZE="-1"><B>DOM</B></FONT><B> Spec</B>: AttDef, AttlistDecl, ElementDecl and XMLDecl were added for
completeness.
<DT>getNodeValue and setNodeValue (value)<DD>
<A NAME="ixAAI"></A>
Returns a string or undef, depending on the node type. This method is provided 
for completeness. In other languages it saves the programmer an upcast.
The value is either available thru some other method defined in the subclass, or
else undef is returned. Here are the corresponding methods: 
Attr::getValue, Text::getData, CDATASection::getData, Comment::getData, 
ProcessingInstruction::getData.
<DT>getParentNode and setParentNode (parentNode)<DD>
<A NAME="ixAAJ"></A>
The parent of this node. All nodes, except Document,
DocumentFragment, and Attr may have a parent. However, if a
node has just been created and not yet added to the tree, or
if it has been removed from the tree, this is undef.
<DT>getChildNodes<DD>
<A NAME="ixAAK"></A>
A NodeList that contains all children of this node. If there
are no children, this is a NodeList containing no nodes. The
content of the returned NodeList is ``live'' in the sense that,
for instance, changes to the children of the node object that
it was created from are immediately reflected in the nodes
returned by the NodeList accessors; it is not a static
snapshot of the content of the node. This is true for every
NodeList, including the ones returned by the
getElementsByTagName method.


<P>


<FONT SIZE="-1">NOTE:</FONT> this implementation does not return a ``live'' NodeList for
getElementsByTagName. See <FONT SIZE="-1">CAVEATS</FONT>.


<P>


When this method is called in a list context, it returns a regular perl list
containing the child nodes. Note that this list is not ``live''. E.g.


<P>




<PRE>
 @list = $node-&gt;getChildNodes;        # returns a perl list
 $nodelist = $node-&gt;getChildNodes;    # returns a NodeList (object reference)
 for my $kid ($node-&gt;getChildNodes)   # iterate over the children of $node

</PRE>


<DT>getFirstChild<DD>
<A NAME="ixAAL"></A>
The first child of this node. If there is no such node, this returns undef.
<DT>getLastChild<DD>
<A NAME="ixAAM"></A>
The last child of this node. If there is no such node, this returns undef.
<DT>getPreviousSibling<DD>
<A NAME="ixAAN"></A>
The node immediately preceding this node. If there is no such 
node, this returns undef.
<DT>getNextSibling<DD>
<A NAME="ixAAO"></A>
The node immediately following this node. If there is no such node, this returns 
undef.
<DT>getAttributes<DD>
<A NAME="ixAAP"></A>
A NamedNodeMap containing the attributes (Attr nodes) of this node 
(if it is an Element) or undef otherwise.
Note that adding/removing attributes from the returned object, also adds/removes
attributes from the Element node that the NamedNodeMap came from.
<DT>getOwnerDocument<DD>
<A NAME="ixAAQ"></A>
The Document object associated with this node. This is also
the Document object used to create new nodes. When this node
is a Document this is undef.
<DT>insertBefore (newChild, refChild)<DD>
<A NAME="ixAAR"></A>
Inserts the node newChild before the existing child node
refChild. If refChild is undef, insert newChild at the end of
the list of children.


<P>


If newChild is a DocumentFragment object, all of its children
are inserted, in the same order, before refChild. If the
newChild is already in the tree, it is first removed.


<P>


Return Value: The node being inserted.


<P>


DOMExceptions:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>*<DD>
<FONT SIZE="-1">HIERARCHY_REQUEST_ERR</FONT>


<P>


Raised if this node is of a type that does not allow children of the type of
the newChild node, or if the node to insert is one of this node's ancestors.
<DT>*<DD>
<FONT SIZE="-1">WRONG_DOCUMENT_ERR</FONT>


<P>


Raised if newChild was created from a different document than the one that 
created this node.
<DT>*<DD>
<FONT SIZE="-1">NO_MODIFICATION_ALLOWED_ERR</FONT>


<P>


Raised if this node is readonly.
<DT>*<DD>
<FONT SIZE="-1">NOT_FOUND_ERR</FONT>


<P>


Raised if refChild is not a child of this node.
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>replaceChild (newChild, oldChild)<DD>
<A NAME="ixAAS"></A>
Replaces the child node oldChild with newChild in the list of
children, and returns the oldChild node. If the newChild is
already in the tree, it is first removed.


<P>


Return Value: The node replaced.


<P>


DOMExceptions:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>*<DD>
<FONT SIZE="-1">HIERARCHY_REQUEST_ERR</FONT>


<P>


Raised if this node is of a type that does not allow children of the type of
the newChild node, or it the node to put in is one of this node's ancestors.
<DT>*<DD>
<FONT SIZE="-1">WRONG_DOCUMENT_ERR</FONT>


<P>


Raised if newChild was created from a different document than the one that 
created this node.
<DT>*<DD>
<FONT SIZE="-1">NO_MODIFICATION_ALLOWED_ERR</FONT>


<P>


Raised if this node is readonly.
<DT>*<DD>
<FONT SIZE="-1">NOT_FOUND_ERR</FONT>


<P>


Raised if oldChild is not a child of this node.
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>removeChild (oldChild)<DD>
<A NAME="ixAAT"></A>
Removes the child node indicated by oldChild from the list of
children, and returns it.


<P>


Return Value: The node removed.


<P>


DOMExceptions:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>*<DD>
<FONT SIZE="-1">NO_MODIFICATION_ALLOWED_ERR</FONT>


<P>


Raised if this node is readonly.
<DT>*<DD>
<FONT SIZE="-1">NOT_FOUND_ERR</FONT>


<P>


Raised if oldChild is not a child of this node.
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>appendChild (newChild)<DD>
<A NAME="ixAAU"></A>
Adds the node newChild to the end of the list of children of
this node. If the newChild is already in the tree, it is
first removed. If it is a DocumentFragment object, the entire contents of 
the document fragment are moved into the child list of this node


<P>


Return Value: The node added.


<P>


DOMExceptions:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>*<DD>
<FONT SIZE="-1">HIERARCHY_REQUEST_ERR</FONT>


<P>


Raised if this node is of a type that does not allow children of the type of
the newChild node, or if the node to append is one of this node's ancestors.
<DT>*<DD>
<FONT SIZE="-1">WRONG_DOCUMENT_ERR</FONT>


<P>


Raised if newChild was created from a different document than the one that 
created this node.
<DT>*<DD>
<FONT SIZE="-1">NO_MODIFICATION_ALLOWED_ERR</FONT>


<P>


Raised if this node is readonly.
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>hasChildNodes<DD>
<A NAME="ixAAV"></A>
This is a convenience method to allow easy determination of
whether a node has any children.


<P>


Return Value: 1 if the node has any children, 0 otherwise.
<DT>cloneNode (deep)<DD>
<A NAME="ixAAW"></A>
Returns a duplicate of this node, i.e., serves as a generic
copy constructor for nodes. The duplicate node has no parent
(parentNode returns undef.).


<P>


Cloning an Element copies all attributes and their values,
including those generated by the <FONT SIZE="-1">XML</FONT> processor to represent
defaulted attributes, but this method does not copy any text
it contains unless it is a deep clone, since the text is
contained in a child Text node. Cloning any other type of
node simply returns a copy of this node.


<P>


Parameters: 
<BR>&nbsp;<I>deep</I>&nbsp;&nbsp;&nbsp;If&nbsp;true,&nbsp;recursively&nbsp;clone&nbsp;the&nbsp;subtree&nbsp;under&nbsp;the&nbsp;specified&nbsp;node.
If false, clone only the node itself (and its attributes, if it is an Element).


<P>


Return Value: The duplicate node.
<DT>normalize<DD>
<A NAME="ixAAX"></A>
Puts all Text nodes in the full depth of the sub-tree
underneath this Element into a ``normal'' form where only
markup (e.g., tags, comments, processing instructions, <FONT SIZE="-1">CDATA</FONT>
sections, and entity references) separates Text nodes, i.e.,
there are no adjacent Text nodes. This can be used to ensure
that the <FONT SIZE="-1">DOM</FONT> view of a document is the same as if it were
saved and re-loaded, and is useful when operations (such as
XPointer lookups) that depend on a particular document tree
structure are to be used.


<P>


<B>Not In </B><FONT SIZE="-1"><B>DOM</B></FONT><B> Spec</B>: In the <FONT SIZE="-1">DOM</FONT> Spec this method is defined in the Element and 
Document class interfaces only, but it doesn't hurt to have it here...
<DT>getElementsByTagName (name [, recurse])<DD>
<A NAME="ixAAY"></A>
Returns a NodeList of all descendant elements with a given
tag name, in the order in which they would be encountered in
a preorder traversal of the Element tree.


<P>


Parameters:
<BR>&nbsp;<I>name</I>&nbsp;&nbsp;The&nbsp;name&nbsp;of&nbsp;the&nbsp;tag&nbsp;to&nbsp;match&nbsp;on.&nbsp;The&nbsp;special&nbsp;value&nbsp;``*''&nbsp;matches&nbsp;all&nbsp;tags.
<BR>&nbsp;<I>recurse</I>&nbsp;&nbsp;Whether&nbsp;it&nbsp;should&nbsp;return&nbsp;only&nbsp;direct&nbsp;child&nbsp;nodes&nbsp;(0)&nbsp;or&nbsp;any&nbsp;descendant&nbsp;that&nbsp;matches&nbsp;the&nbsp;tag&nbsp;name&nbsp;(1).&nbsp;This&nbsp;argument&nbsp;is&nbsp;optional&nbsp;and&nbsp;defaults&nbsp;to&nbsp;1.&nbsp;It&nbsp;is&nbsp;not&nbsp;part&nbsp;of&nbsp;the&nbsp;<FONT SIZE="-1">DOM</FONT>&nbsp;spec.


<P>


Return Value: A list of matching Element nodes.


<P>


<FONT SIZE="-1">NOTE:</FONT> this implementation does not return a ``live'' NodeList for
getElementsByTagName. See <FONT SIZE="-1">CAVEATS</FONT>.


<P>


When this method is called in a list context, it returns a regular perl list
containing the result nodes. E.g.


<P>




<PRE>
 @list = $node-&gt;getElementsByTagName(&quot;tag&quot;);       # returns a perl list
 $nodelist = $node-&gt;getElementsByTagName(&quot;tag&quot;);   # returns a NodeList (object ref.)
 for my $elem ($node-&gt;getElementsByTagName(&quot;tag&quot;)) # iterate over the result nodes

</PRE>


</DL>
<A NAME="lbAF">&nbsp;</A>
<H3>Additional methods not in the <FONT SIZE="-1">DOM</FONT> Spec</H3>

<A NAME="ixAAZ"></A>
<DL COMPACT>
<DT>getNodeTypeName<DD>
<A NAME="ixABA"></A>
Return the string describing the node type. 
E.g. returns ``<FONT SIZE="-1">ELEMENT_NODE</FONT>'' if getNodeType returns <FONT SIZE="-1">ELEMENT_NODE</FONT>.
It uses <TT>@XML::DOM::Node::NodeNames</TT>.
<DT>toString<DD>
<A NAME="ixABB"></A>
Returns the entire subtree as a string.
<DT>printToFile (filename)<DD>
<A NAME="ixABC"></A>
Prints the entire subtree to the file with the specified filename.


<P>


Croaks: if the file could not be opened for writing.
<DT>printToFileHandle (handle)<DD>
<A NAME="ixABD"></A>
Prints the entire subtree to the file handle.
E.g. to print to <FONT SIZE="-1">STDOUT:</FONT>


<P>




<PRE>
 $node-&gt;printToFileHandle (\*STDOUT);

</PRE>


<DT>print (obj)<DD>
<A NAME="ixABE"></A>
Prints the entire subtree using the object's print method. E.g to print to a
FileHandle object:


<P>




<PRE>
 $f = new FileHandle (&quot;file.out&quot;, &quot;w&quot;);
 $node-&gt;print ($f);

</PRE>


<DT>getChildIndex (child)<DD>
<A NAME="ixABF"></A>
Returns the index of the child node in the list returned by getChildNodes.


<P>


Return Value: the index or -1 if the node is not found.
<DT>getChildAtIndex (index)<DD>
<A NAME="ixABG"></A>
Returns the child node at the specifed index or undef.
<DT>addText (text)<DD>
<A NAME="ixABH"></A>
Appends the specified string to the last child if it is a Text node, or else 
appends a new Text node (with the specified text.)


<P>


Return Value: the last child if it was a Text node or else the new Text node.
<DT>dispose<DD>
<A NAME="ixABI"></A>
Removes all circular references in this node and its descendants so the 
objects can be claimed for garbage collection. The objects should not be used
afterwards.
<DT>setOwnerDocument (doc)<DD>
<A NAME="ixABJ"></A>
Sets the ownerDocument property of this node and all its children (and 
attributes etc.) to the specified document.
This allows the user to cut and paste document subtrees between different
XML::DOM::Documents. The node should be removed from the original document
first, before calling setOwnerDocument.


<P>


This method does nothing when called on a Document node.
<DT>isAncestor (parent)<DD>
<A NAME="ixABK"></A>
Returns 1 if parent is an ancestor of this node or if it is this node itself.
<DT>expandEntityRefs (str)<DD>
<A NAME="ixABL"></A>
Expands all the entity references in the string and returns the result.
The entity references can be character references (e.g. ``&amp;#123;'' or ``&amp;#x1fc2''),
default entity references (``&amp;quot;'', ``&amp;gt;'', ``&amp;lt;'', ``&amp;apos;'' and ``&amp;amp;'') or
entity references defined in Entity objects as part of the DocumentType of
the owning Document. Character references are expanded into <FONT SIZE="-1">UTF-8</FONT>.
Parameter entity references (e.g. <TT>%ent</TT>;) are not expanded.
<DT>to_sax ( %HANDLERS )<DD>


<A NAME="ixABM"></A>
E.g.


<P>




<PRE>
 $node-&gt;to_sax (DocumentHandler =&gt; $my_handler, 
                Handler =&gt; $handler2 );

</PRE>




<P>


<TT>%HANDLERS</TT> may contain the following handlers:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>*<DD>
DocumentHandler
<DT>*<DD>
DTDHandler
<DT>*<DD>
EntityResolver
<DT>*<DD>
Handler


<P>


Default handler when one of the above is not specified
</DL>
</DL>

<DL COMPACT><DT><DD>


<P>


Each XML::DOM::Node generates the appropriate <FONT SIZE="-1">SAX</FONT> callbacks (for the
appropriate <FONT SIZE="-1">SAX</FONT> handler.) Different <FONT SIZE="-1">SAX</FONT> handlers can be plugged in to
accomplish different things, e.g. XML::Checker would check the node 
(currently only Document and Element nodes are supported), XML::Handler::BuildDOM
would create a new <FONT SIZE="-1">DOM</FONT> subtree (thereby, in essence, copying the Node)
and in the near future, XML::Writer could print the node.
All Perl <FONT SIZE="-1">SAX</FONT> related work is still in flux, so this interface may change a 
little.


<P>


See PerlSAX for the description of the <FONT SIZE="-1">SAX</FONT> interface.
</DL>

<DT>check ( [$checker] )<DD>
<A NAME="ixABN"></A>
See descriptions for <I>check()</I> in XML::DOM::Document and XML::DOM::Element.
<DT>xql ( @XQL_OPTIONS )<DD>


<A NAME="ixABO"></A>
To use the xql method, you must first <I>use</I> <FONT SIZE="-1">XML::XQL</FONT> and <FONT SIZE="-1">XML::XQL::DOM</FONT>.
This method is basically a shortcut for:


<P>




<PRE>
 $query = new XML::XQL::Query ( @XQL_OPTIONS );
 return $query-&gt;solve ($node);

</PRE>




<P>


If the first parameter in <TT>@XQL_OPTIONS</TT> is the <FONT SIZE="-1">XQL</FONT> expression, you can leave off
the 'Expr' keyword, so:


<P>




<PRE>
 $node-&gt;xql (&quot;doc//elem1[@attr]&quot;, @other_options);

</PRE>




<P>


is identical to:


<P>




<PRE>
 $node-&gt;xql (Expr =&gt; &quot;doc//elem1[@attr]&quot;, @other_options);

</PRE>




<P>


See XML::XQL::Query for other available <FONT SIZE="-1">XQL_OPTIONS</FONT>.
See <FONT SIZE="-1">XML::XQL</FONT> and XML::XQL::Tutorial for more info.
<DT>isHidden ()<DD>
<A NAME="ixABP"></A>
Whether the node is hidden.
See Hidden Nodes for details.
<P>
</DL>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAD"><FONT SIZE="-1">GLOBAL</FONT> <FONT SIZE="-1">VARIABLES</FONT></A><DD>
<DT><A HREF="#lbAE"><FONT SIZE="-1">METHODS</FONT></A><DD>
<DT><A HREF="#lbAF">Additional methods not in the <FONT SIZE="-1">DOM</FONT> Spec</A><DD>
</DL>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:46 GMT, December 24, 2015
</div></body>
</HTML>
