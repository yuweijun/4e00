<!DOCTYPE html>

<HTML><head><TITLE>Manpage of URI::Escape</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>URI::Escape</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2009-05-28<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

URI::Escape - Escape and unescape unsafe characters
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
 use URI::Escape;
 $safe = uri_escape(&quot;10% is enough\n&quot;);
 $verysafe = uri_escape(&quot;foo&quot;, &quot;\0-\377&quot;);
 $str  = uri_unescape($safe);

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
This module provides functions to escape and unescape <FONT SIZE="-1">URI</FONT> strings as
defined by <FONT SIZE="-1">RFC</FONT> 2396 (and updated by <FONT SIZE="-1">RFC</FONT> 2732).
A <FONT SIZE="-1">URI</FONT> consists of a restricted set of characters,
denoted as <TT>&quot;uric&quot;</TT> in <FONT SIZE="-1">RFC</FONT> 2396.  The restricted set of characters
consists of digits, letters, and a few graphic symbols chosen from
those common to most of the character encodings and input facilities
available to Internet users:
<P>



<PRE>
  &quot;A&quot; .. &quot;Z&quot;, &quot;a&quot; .. &quot;z&quot;, &quot;0&quot; .. &quot;9&quot;,
  &quot;;&quot;, &quot;/&quot;, &quot;?&quot;, &quot;:&quot;, &quot;@&quot;, &quot;&amp;&quot;, &quot;=&quot;, &quot;+&quot;, &quot;$&quot;, &quot;,&quot;, &quot;[&quot;, &quot;]&quot;,   # reserved
  &quot;-&quot;, &quot;_&quot;, &quot;.&quot;, &quot;!&quot;, &quot;~&quot;, &quot;*&quot;, &quot;'&quot;, &quot;(&quot;, &quot;)&quot;

</PRE>


<P>

In addition, any byte (octet) can be represented in a <FONT SIZE="-1">URI</FONT> by an escape
sequence: a triplet consisting of the character ``%'' followed by two
hexadecimal digits.  A byte can also be represented directly by a
character, using the US-ASCII character for that octet (iff the
character is part of <TT>&quot;uric&quot;</TT>).
<P>

Some of the <TT>&quot;uric&quot;</TT> characters are <I>reserved</I> for use as delimiters
or as part of certain <FONT SIZE="-1">URI</FONT> components.  These must be escaped if they are
to be treated as ordinary data.  Read <FONT SIZE="-1">RFC</FONT> 2396 for further details.
<P>

The functions provided (and exported by default) from this module are:
<DL COMPACT>
<DT>uri_escape( $string )<DD>


<A NAME="ixAAE"></A>

<DT>uri_escape( $string, $unsafe )<DD>


<A NAME="ixAAF"></A>

Replaces each unsafe character in the <TT>$string</TT> with the corresponding
escape sequence and returns the result.  The <TT>$string</TT> argument should
be a string of bytes.  The <I>uri_escape()</I> function will croak if given a
characters with code above 255.  Use <I>uri_escape_utf8()</I> if you know you
have such chars or/and want chars in the 128 .. 255 range treated as
<FONT SIZE="-1">UTF-8</FONT>.


<P>


The <I>uri_escape()</I> function takes an optional second argument that
overrides the set of characters that are to be escaped.  The set is
specified as a string that can be used in a regular expression
character class (between [ ]).  E.g.:


<P>




<PRE>
  &quot;\x00-\x1f\x7f-\xff&quot;          # all control and hi-bit characters
  &quot;a-z&quot;                         # all lower case characters
  &quot;^A-Za-z&quot;                     # everything not a letter

</PRE>




<P>


The default set of characters to be escaped is all those which are
<I>not</I> part of the <TT>&quot;uric&quot;</TT> character class shown above as well as the
reserved characters.  I.e. the default is:


<P>




<PRE>
  &quot;^A-Za-z0-9\-_.!~*'()&quot;

</PRE>


<DT>uri_escape_utf8( $string )<DD>


<A NAME="ixAAG"></A>

<DT>uri_escape_utf8( $string, $unsafe )<DD>


<A NAME="ixAAH"></A>

Works like <I>uri_escape()</I>, but will encode chars as <FONT SIZE="-1">UTF-8</FONT> before
escaping them.  This makes this function able do deal with characters
with code above 255 in <TT>$string</TT>.  Note that chars in the 128 .. 255
range will be escaped differently by this function compared to what
<I>uri_escape()</I> would.  For chars in the 0 .. 127 range there is no
difference.


<P>


The call:


<P>




<PRE>
    $uri = uri_escape_utf8($string);

</PRE>




<P>


will be the same as:


<P>




<PRE>
    use Encode qw(encode);
    $uri = uri_escape(encode(&quot;UTF-8&quot;, $string));

</PRE>




<P>


but will even work for perl-5.6 for chars in the 128 .. 255 range.


<P>


Note: Javascript has a function called <I>escape()</I> that produces the
sequence ``%uXXXX'' for chars in the 256 .. 65535 range.  This function
has really nothing to do with <FONT SIZE="-1">URI</FONT> escaping but some folks got confused
since it ``does the right thing'' in the 0 .. 255 range.  Because of
this you sometimes see ``URIs'' with these kind of escapes.  The
JavaScript <I>encodeURIComponent()</I> function is similar to <I>uri_escape_utf8()</I>.
<DT>uri_unescape($string,...)<DD>
<A NAME="ixAAI"></A>
Returns a string with each <TT>%XX</TT> sequence replaced with the actual byte
(octet).


<P>


This does the same as:


<P>




<PRE>
   $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;

</PRE>




<P>


but does not modify the string in-place as this <FONT SIZE="-1">RE</FONT> would.  Using the
<I>uri_unescape()</I> function instead of the <FONT SIZE="-1">RE</FONT> might make the code look
cleaner and is a few characters less to type.


<P>


In a simple benchmark test I did,
calling the function (instead of the inline <FONT SIZE="-1">RE</FONT> above) if a few chars
were unescaped was something like 40% slower, and something like 700% slower if none were.  If
you are going to unescape a lot of times it might be a good idea to
inline the <FONT SIZE="-1">RE</FONT>.


<P>


If the <I>uri_unescape()</I> function is passed multiple strings, then each
one is returned unescaped.
</DL>
<P>

The module can also export the <TT>%escapes</TT> hash, which contains the
mapping from all 256 bytes to the corresponding escape codes.  Lookup
in this hash is faster than evaluating <TT>&quot;sprintf(&quot;%%%02X&quot;, ord($byte))&quot;</TT>
each time.
<A NAME="lbAE">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAJ"></A>
<FONT SIZE="-1">URI</FONT>
<A NAME="lbAF">&nbsp;</A>
<H2>COPYRIGHT</H2>

<A NAME="ixAAK"></A>
Copyright 1995-2004 Gisle Aas.
<P>

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">SEE ALSO</A><DD>
<DT><A HREF="#lbAF">COPYRIGHT</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:44 GMT, December 24, 2015
</div></div>
</body>
</HTML>
