<!DOCTYPE html>

<HTML><head><TITLE>Manpage of docs::api::Apache2::Filter</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux man pages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>docs::api::Apache2::Filter</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2008-04-17<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Apache2::Filter - Perl API for Apache 2.0 Filtering
<A NAME="lbAC">&nbsp;</A>
<H2>Synopsis</H2>

<A NAME="ixAAC"></A>


<PRE>
  use Apache2::Filter ();
  
  # filter attributes
  my $c = $f-&gt;c;
  my $r = $f-&gt;r;
  my $frec = $f-&gt;frec();
  my $next_f = $f-&gt;next;
  
  my $ctx = $f-&gt;ctx;
  $f-&gt;ctx($ctx);
  
  # bucket brigade filtering API
  $rc = $f-&gt;next-&gt;get_brigade($bb, $mode, $block, $readbytes);
  $rc = $f-&gt;next-&gt;pass_brigade($bb);
  $rc = $f-&gt;fflush($bb);
  
  # streaming filtering API
  while ($filter-&gt;read(my $buffer, $wanted)) {
      # transform $buffer here
      $filter-&gt;print($buffer);
  }
  if ($f-&gt;seen_eos) {
      $filter-&gt;print(&quot;filter signature&quot;);
  }
  
  # filter manipulations
  $r-&gt;add_input_filter(\&amp;callback);
  $c-&gt;add_input_filter(\&amp;callback);
  $r-&gt;add_output_filter(\&amp;callback);
  $c-&gt;add_output_filter(\&amp;callback);
  $f-&gt;remove;

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>Description</H2>

<A NAME="ixAAD"></A>
<TT>&quot;Apache2::Filter&quot;</TT> provides Perl <FONT SIZE="-1">API</FONT> for Apache 2.0 filtering
framework.
<P>

Make sure to read <TT>&quot;the Filtering
tutorial|docs::2.0::user::handlers::filters&quot;</TT>.
<A NAME="lbAE">&nbsp;</A>
<H2>Common Filter API</H2>

<A NAME="ixAAE"></A>
The following methods can be called from any filter handler:
<A NAME="lbAF">&nbsp;</A>
<H3>c</H3>



<A NAME="ixAAF"></A>
Get the current connection object from a connection or a request
filter:
<P>



<PRE>
  $c = $f-&gt;c;

</PRE>


<DL COMPACT>
<DT>obj: $f ( Apache2::Filter object )<DD>


<A NAME="ixAAG"></A>

<DT>ret: $c ( Apache2::Connection object )<DD>


<A NAME="ixAAH"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixAAI"></A>

</DL>
<A NAME="lbAG">&nbsp;</A>
<H3>ctx</H3>



<A NAME="ixAAJ"></A>
Get/set the filter context data.
<P>



<PRE>
  $ctx = $f-&gt;ctx;
         $f-&gt;ctx($ctx);

</PRE>


<DL COMPACT>
<DT>obj: $f ( Apache2::Filter object )<DD>


<A NAME="ixAAK"></A>

<DT>opt arg2: $ctx ( <FONT SIZE="-1">SCALAR</FONT> )<DD>


<A NAME="ixAAL"></A>

next context
<DT>ret: $ctx ( <FONT SIZE="-1">SCALAR</FONT> )<DD>


<A NAME="ixAAM"></A>
current context
<DT>since: 2.0.00<DD>
<A NAME="ixAAN"></A>
</DL>
<P>

A filter context is created before the filter is called for the first
time and it's destroyed at the end of the request. The context is
preserved between filter invocations of the same request. So if a
filter needs to store some data between invocations it should use the
filter context for that.  The filter context is initialized with the
<TT>&quot;undef&quot;</TT> value.
<P>

The <TT>&quot;ctx&quot;</TT> method accepts a single <FONT SIZE="-1">SCALAR</FONT> argument. Therefore if you
want to store any other perl datastructure you should use a reference
to it.
<P>

For example you can store a hash reference:
<P>



<PRE>
  $f-&gt;ctx({ foo =&gt; 'bar' });

</PRE>


<P>

and then access it:
<P>



<PRE>
  $foo = $f-&gt;ctx-&gt;{foo};

</PRE>


<P>

if you access the context more than once it's more efficient to copy
it's value before using it:
<P>



<PRE>
  my $ctx = $f-&gt;ctx;
  $foo = $ctx-&gt;{foo};

</PRE>


<P>

to avoid redundant method calls. As of this writing <TT>$ctx</TT> is not a
tied variable, so if you modify it need to store it at the end:
<P>



<PRE>
  $f-&gt;ctx($ctx);

</PRE>


<P>

<FONT SIZE="-1">META:</FONT> later we might make it a TIEd-variable interface, so it'll be
stored automatically.
<P>

Besides its primary purpose of storing context data across multiple
filter invocations, this method is also useful when used as a
flag. For example here is how to ensure that something happens only
once during the filter's life:
<P>



<PRE>
  unless ($f-&gt;ctx) {
      do_something_once();
      $f-&gt;<A HREF="/manpages/index.html?1+ctx">ctx</A>(1);
  }

</PRE>


<A NAME="lbAH">&nbsp;</A>
<H3>frec</H3>



<A NAME="ixAAO"></A>
Get/set the <TT>&quot;Apache2::FilterRec&quot;</TT>
(filter record) object.
<P>



<PRE>
  $frec = $f-&gt;frec();

</PRE>


<DL COMPACT>
<DT>obj: $f ( Apache2::Filter object )<DD>


<A NAME="ixAAP"></A>

<DT>ret: $frec ( Apache2::FilterRec object )<DD>


<A NAME="ixAAQ"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixAAR"></A>

</DL>
<P>

For example you can call
<TT>&quot;$frec-&gt;name&quot;</TT> to get
filter's name.
<A NAME="lbAI">&nbsp;</A>
<H3>next</H3>



<A NAME="ixAAS"></A>
Return the <TT>&quot;Apache2::Filter&quot;</TT> object of the next filter in chain.
<P>



<PRE>
  $next_f = $f-&gt;next;

</PRE>


<DL COMPACT>
<DT>obj: $f ( Apache2::Filter object )<DD>


<A NAME="ixAAT"></A>
The current filter object
<DT>ret: $next_f ( Apache2::Filter object )<DD>


<A NAME="ixAAU"></A>
The next filter object in chain
<DT>since: 2.0.00<DD>
<A NAME="ixAAV"></A>
</DL>
<P>

Since Apache inserts several core filters at the end of each chain,
normally this method always returns an object. However if it's not a
mod_perl filter handler, you can call only the following methods on
it: <TT>&quot;get_brigade&quot;</TT>,
<TT>&quot;pass_brigade&quot;</TT>, <TT>&quot;c&quot;</TT>, <TT>&quot;r&quot;</TT>,
<TT>&quot;frec&quot;</TT> and <TT>&quot;next&quot;</TT>. If you call other methods
the behavior is undefined.
<P>

The next filter can be a mod_perl one or not, it's easy to tell which
one is that by calling
<TT>&quot;$f-&gt;frec-&gt;name&quot;</TT>.
<A NAME="lbAJ">&nbsp;</A>
<H3>r</H3>



<A NAME="ixAAW"></A>
Inside an <FONT SIZE="-1">HTTP</FONT> request filter retrieve the current request object:
<P>



<PRE>
  $r = $f-&gt;r;

</PRE>


<DL COMPACT>
<DT>obj: $f ( Apache2::Filter object )<DD>


<A NAME="ixAAX"></A>

<DT>ret: $r ( Apache2::RequestRec object )<DD>


<A NAME="ixAAY"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixAAZ"></A>

</DL>
<P>

If a sub-request adds filters, then that sub-request object is
associated with the filter.
<A NAME="lbAK">&nbsp;</A>
<H3>remove</H3>



<A NAME="ixABA"></A>
Remove the current filter from the filter chain (for the current
request or connection).
<P>



<PRE>
  $f-&gt;remove;

</PRE>


<DL COMPACT>
<DT>obj: $f ( Apache2::Filter object )<DD>


<A NAME="ixABB"></A>

<DT>ret: no return value<DD>
<A NAME="ixABC"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixABD"></A>

</DL>
<P>

Notice that you should either complete the current filter invocation
normally (by calling <TT>&quot;get_brigade&quot;</TT> or
<TT>&quot;pass_brigade&quot;</TT> depending on the filter kind) or
if nothing was done, return <TT>&quot;Apache2::Const::DECLINED&quot;</TT> and mod_perl will take
care of passing the current bucket brigade through unmodified to the
next filter in chain.
<P>

Note: calling <I>remove()</I> on the very top connection filter doesn't
affect the filter chain due to a bug in Apache 2.0 (which may be fixed
in 2.1). So don't use it with connection filters, till it gets fixed
in Apache and then make sure to require the minimum Apache version if
you rely on.
<P>

Remember that if the connection is
<TT>&quot;$c-&gt;keepalive&quot;</TT>
) and the connection filter is removed, it won't be added until the
connection is closed. Which may happen after many <FONT SIZE="-1">HTTP</FONT> requests. You
may want to keep the filter in place and pass the data through
unmodified, by returning <TT>&quot;Apache2::Const::DECLINED&quot;</TT>. If you need to reset the
whole or parts of the filter context between requests, use the
technique based on <TT>&quot;$c-&gt;keepalives&quot;</TT>
counting.
<P>

This method works for native Apache (non-mod_perl) filters too.
<A NAME="lbAL">&nbsp;</A>
<H2>Bucket Brigade Filter API</H2>

<A NAME="ixABE"></A>
The following methods can be called from any filter, directly
manipulating bucket brigades:
<A NAME="lbAM">&nbsp;</A>
<H3>fflush</H3>



<A NAME="ixABF"></A>
Flush a bucket brigade down the filter stack.
<P>



<PRE>
  $rc = $f-&gt;fflush($bb);

</PRE>


<DL COMPACT>
<DT>obj: $f ( Apache2::Filter object )<DD>


<A NAME="ixABG"></A>
The current filter
<DT>arg1: $bb ( Apache2::Brigade object )<DD>


<A NAME="ixABH"></A>
The brigade to flush
<DT>ret:  $rc ( APR::Const status constant )<DD>


<A NAME="ixABI"></A>
Refer to the <TT>&quot;pass_brigade()&quot;</TT> entry.
<DT>excpt: APR::Error<DD>


<A NAME="ixABJ"></A>
Exceptions are thrown only when this function is called in the <FONT SIZE="-1">VOID</FONT>
context. Refer to the <TT>&quot;get_brigade()&quot;</TT> entry for
details.
<DT>since: 2.0.00<DD>
<A NAME="ixABK"></A>
</DL>
<P>

<TT>&quot;fflush&quot;</TT> is a shortcut method. So instead of doing:
<P>



<PRE>
  my $b = APR::Bucket::flush_create($f-&gt;c-&gt;bucket_alloc);
  $bb-&gt;insert_tail($b);
  $f-&gt;pass_brigade($bb);

</PRE>


<P>

one can just write:
<P>



<PRE>
  $f-&gt;fflush($bb);

</PRE>


<A NAME="lbAN">&nbsp;</A>
<H3>get_brigade</H3>



<A NAME="ixABL"></A>
This is a method to use in bucket brigade input filters. It acquires a
bucket brigade from the upstream input filter.
<P>



<PRE>
  $rc = $next_f-&gt;get_brigade($bb, $mode, $block, $readbytes);
  $rc = $next_f-&gt;get_brigade($bb, $mode, $block);
  $rc = $next_f-&gt;get_brigade($bb, $mode)
  $rc = $next_f-&gt;get_brigade($bb);

</PRE>


<DL COMPACT>
<DT>obj: $next_f ( Apache2::Filter object )<DD>


<A NAME="ixABM"></A>
The next filter in the filter chain.


<P>


Inside filter handlers it's
usually <TT>&quot;$f-&gt;next&quot;</TT>. Inside protocol
handlers:
<TT>&quot;$c-&gt;input_filters&quot;</TT>.
<DT>arg1: $bb ( APR::Brigade object )<DD>


<A NAME="ixABN"></A>
The original bucket brigade passed to <TT>&quot;get_brigade()&quot;</TT>, which must be
empty.


<P>


Inside input filter
handlers it's usually the second
argument to the filter handler.


<P>


Otherwise it should be created:


<P>




<PRE>
  my $bb = APR::Brigade-&gt;new($c-&gt;pool, $c-&gt;bucket_alloc);

</PRE>




<P>


On return it gets populated with the next bucket brigade. That brigade
may contain nothing if there was no more data to read. The return
status tells the outcome.
<DT>opt arg2: $mode ( Apache2::Const :input_mode constant )<DD>


<A NAME="ixABO"></A>
The filter mode in which the data should be read.


<P>


If inside the filter handler, you should normally pass the same mode
that was passed to the filter handler (the third argument).


<P>


At the end of this section the available modes are presented.


<P>


If the argument <TT>$mode</TT> is not passed,
<TT>&quot;Apache2::Const::MODE_READBYTES&quot;</TT>
is used as a default value.
<DT>opt arg3: $block ( APR::Const :read_type constant )<DD>


<A NAME="ixABP"></A>
You may ask the reading operation to be blocking:
<TT>&quot;APR::Const::BLOCK_READ&quot;</TT>,
or nonblocking:
<TT>&quot;APR::Const::NONBLOCK_READ&quot;</TT>.


<P>


If inside the filter handler, you should normally pass the same
blocking mode argument that was passed to the filter handler (the
forth argument).


<P>


If the argument <TT>$block</TT> is not passed,
<TT>&quot;APR::Const::BLOCK_READ&quot;</TT> is
used as a default value.
<DT>opt arg4: $readbytes ( integer )<DD>


<A NAME="ixABQ"></A>
How many bytes to read from the next filter.


<P>


If inside the filter handler, you may want the same number of bytes,
as the upstream filter, i.e. the argument that was passed to the
filter handler (the fifth argument).


<P>


If the argument <TT>$block</TT> is not passed, 8192 is used as a default
value.
<DT>ret: $rc ( APR::Const status constant )<DD>


<A NAME="ixABR"></A>
On success,
<TT>&quot;APR::Const::SUCCESS&quot;</TT> is
returned and <TT>$bb</TT> is populated (see the <TT>$bb</TT> entry).


<P>


In case of a failure --- a failure code is returned, in which case
normally it should be returned to the caller.


<P>


If the bottom-most filter doesn't read from the network, then
<TT>&quot;Apache2::NOBODY_READ&quot;</TT> is returned (<FONT SIZE="-1">META:</FONT> need to add this constant).


<P>


Inside protocol handlers the
return code can also be <TT>&quot;APR::Const::EOF&quot;</TT>, which is success as well.
<DT>excpt: APR::Error<DD>


<A NAME="ixABS"></A>
You don't have to ask for the return value. If this function is called
in the <FONT SIZE="-1">VOID</FONT> context, e.g.:


<P>




<PRE>
  $f-&gt;next-&gt;get_brigade($bb, $mode, $block, $readbytes);

</PRE>




<P>


mod_perl will do the error checking on your behalf, and if the return
code is not
<TT>&quot;APR::Const::SUCCESS&quot;</TT>, an
<TT>&quot;APR::Error exception&quot;</TT> will be thrown.
The only time you want to do the error checking yourself, is when
return codes besides
<TT>&quot;APR::Const::SUCCESS&quot;</TT> are
considered as successful and you want to manage them by yourself.
<DT>since: 2.0.00<DD>
<A NAME="ixABT"></A>
</DL>
<P>

Available input filter modes (the optional second argument <TT>$mode</TT>)
are:
<DL COMPACT>
<DT>*<DD>
<TT>&quot;Apache2::Const::MODE_READBYTES&quot;</TT>


<P>


The filter should return at most readbytes data
<DT>*<DD>
<TT>&quot;Apache2::Const::MODE_GETLINE&quot;</TT>


<P>


The filter should return at most one line of <FONT SIZE="-1">CRLF</FONT> data.  (If a
potential line is too long or no <FONT SIZE="-1">CRLF</FONT> is found, the filter may return
partial data).
<DT>*<DD>
<TT>&quot;Apache2::Const::MODE_EATCRLF&quot;</TT>


<P>


The filter should implicitly eat any <FONT SIZE="-1">CRLF</FONT> pairs that it sees.
<DT>*<DD>
<TT>&quot;Apache2::Const::MODE_SPECULATIVE&quot;</TT>


<P>


The filter read should be treated as speculative and any returned data
should be stored for later retrieval in another mode.
<DT>*<DD>
<TT>&quot;Apache2::Const::MODE_EXHAUSTIVE&quot;</TT>


<P>


The filter read should be exhaustive and read until it can not read
any more. Use this mode with extreme caution.
<DT>*<DD>
<TT>&quot;Apache2::Const::MODE_INIT&quot;</TT>


<P>


The filter should initialize the connection if needed, <FONT SIZE="-1">NNTP</FONT> or <FONT SIZE="-1">FTP</FONT>
over <FONT SIZE="-1">SSL</FONT> for example.
</DL>
<P>

Either compile all these constants with:
<P>



<PRE>
  use Apache2::Const -compile =&gt; qw(:input_mode);

</PRE>


<P>

But it's a bit more efficient to compile only those constants that you
need.
<P>

Example:
<P>

Here is a fragment of a filter handler, that receives a bucket brigade
from the upstream filter:
<P>



<PRE>
  use Apache2::Filter ();
  use APR::Const    -compile =&gt; qw(SUCCESS);
  use Apache2::Const -compile =&gt; qw(OK);
  sub filter {
      my ($f, $bb, $mode, $block, $readbytes) = @_;
      
      my $rc = $f-&gt;next-&gt;get_brigade($bb, $mode, $block, $readbytes);
      return $rc unless $rc == APR::Const::SUCCESS;
      
      # ... process $bb
      
      return Apache2::Const::OK;
  }

</PRE>


<P>

Usually arguments <TT>$mode</TT>, <TT>$block</TT>, <TT>$readbytes</TT> are the same as
passed to the filter itself.
<P>

You can see that in case of a failure, the handler returns immediately
with that failure code, which gets propagated to the downstream
filter.
<P>

If you decide not check the return code, you can write it as:
<P>



<PRE>
  sub filter {
      my ($f, $bb, $mode, $block, $readbytes) = @_;
      
      $f-&gt;next-&gt;get_brigade($bb, $mode, $block, $readbytes);
      
      # ... process $bb
      
      return Apache2::Const::OK;
  }

</PRE>


<P>

and the error checking will be done on your behalf.
<P>

You will find many more examples in <TT>&quot;the filter
handlers|docs::2.0::user::handlers::filters&quot;</TT> and
<TT>&quot;the protocol
handlers|docs::2.0::user::handlers::protocols&quot;</TT> tutorials.
<A NAME="lbAO">&nbsp;</A>
<H3>pass_brigade</H3>



<A NAME="ixABU"></A>
This is a method to use in bucket brigade output filters.  It passes
the current bucket brigade to the downstream output filter.
<P>



<PRE>
  $rc = $next_f-&gt;pass_brigade($bb);

</PRE>


<DL COMPACT>
<DT>obj: $next_f ( Apache2::Filter object )<DD>


<A NAME="ixABV"></A>
The next filter in the filter chain.


<P>


Inside output filter handlers
it's usually <TT>&quot;$f-&gt;next&quot;</TT>. Inside protocol
handlers:
<TT>&quot;$c-&gt;output_filters&quot;</TT>.
<DT>arg1: $bb ( APR::Brigade object )<DD>


<A NAME="ixABW"></A>
The bucket brigade to pass.


<P>


Inside output filter
handlers it's usually the second 
argument to the filter handler (after potential manipulations).
<DT>ret: $rc ( APR::Const status constant )<DD>


<A NAME="ixABX"></A>
On success,
<TT>&quot;APR::Const::SUCCESS&quot;</TT> is
returned.


<P>


In case of a failure --- a failure code is returned, in which case
normally it should be returned to the caller.


<P>


If the bottom-most filter doesn't write to the network, then
<TT>&quot;Apache2::NOBODY_WROTE&quot;</TT> is returned (<FONT SIZE="-1">META:</FONT> need to add this constant).


<P>


Also refer to the <TT>&quot;get_brigade()&quot;</TT> entry to see how
to avoid checking the errors explicitly.
<DT>excpt: APR::Error<DD>


<A NAME="ixABY"></A>
Exceptions are thrown only when this function is called in the <FONT SIZE="-1">VOID</FONT>
context. Refer to the <TT>&quot;get_brigade()&quot;</TT> entry for
details.
<DT>since: 2.0.00<DD>
<A NAME="ixABZ"></A>
</DL>
<P>

The caller relinquishes ownership of the brigade (i.e. it may get
destroyed/overwritten/etc. by the callee).
<P>

Example:
<P>

Here is a fragment of a filter handler, that passes a bucket brigade
to the downstream filter (after some potential processing of the
buckets in the bucket brigade):
<P>



<PRE>
  use Apache2::Filter ();
  use APR::Const    -compile =&gt; qw(SUCCESS);
  use Apache2::Const -compile =&gt; qw(OK);
  sub filter {
      my ($f, $bb) = @_;
  
      # ... process $bb
  
      my $rc = $f-&gt;next-&gt;pass_brigade($bb);
      return $rc unless $rc == APR::Const::SUCCESS;
  
      return Apache2::Const::OK;
  }

</PRE>


<A NAME="lbAP">&nbsp;</A>
<H2>Streaming Filter API</H2>

<A NAME="ixACA"></A>
The following methods can be called from any filter, which uses the
simplified streaming functionality:
<A NAME="lbAQ">&nbsp;</A>
<H3>print</H3>



<A NAME="ixACB"></A>
Send the contents of <TT>$buffer</TT> to the next filter in chain (via
internal buffer).
<P>



<PRE>
  $sent = $f-&gt;print($buffer);

</PRE>


<DL COMPACT>
<DT>obj: $f ( Apache2::Filter object )<DD>


<A NAME="ixACC"></A>

<DT>arg1: $buffer ( string )<DD>


<A NAME="ixACD"></A>

The data to send.
<DT>ret: $sent ( integer )<DD>


<A NAME="ixACE"></A>
How many characters were sent. There is no need to check, since all
should go through and if something goes work an exception will be
thrown.
<DT>excpt: APR::Error<DD>


<A NAME="ixACF"></A>

<DT>since: 2.0.00<DD>
<A NAME="ixACG"></A>

</DL>
<P>

This method should be used only in streaming
filters.
<A NAME="lbAR">&nbsp;</A>
<H3>read</H3>



<A NAME="ixACH"></A>
Read data from the filter
<P>



<PRE>
  $read = $f-&gt;read($buffer, $wanted);

</PRE>


<DL COMPACT>
<DT>obj: $f ( Apache2::Filter object )<DD>


<A NAME="ixACI"></A>

<DT>arg1: $buffer ( <FONT SIZE="-1">SCALAR</FONT> )<DD>


<A NAME="ixACJ"></A>

The buffer to fill. All previous data will be lost.
<DT>opt arg2: $wanted ( integer )<DD>


<A NAME="ixACK"></A>
How many bytes to attempt to read.


<P>


If this optional argument is not specified --- the default 8192 will be
used.
<DT>ret: $read ( integer )<DD>


<A NAME="ixACL"></A>
How many bytes were actually read.


<P>


<TT>$buffer</TT> gets populated with the string that is read. It will
contain an empty string if there was nothing to read.
<DT>excpt: APR::Error<DD>


<A NAME="ixACM"></A>

<DT>since: 2.0.00<DD>
<A NAME="ixACN"></A>

</DL>
<P>

Reads at most <TT>$wanted</TT> characters into <TT>$buffer</TT>. The returned
value <TT>$read</TT> tells exactly how many were read, making it easy to use
it in a while loop:
<P>



<PRE>
  while ($filter-&gt;read(my $buffer, $wanted)) {
      # transform $buffer here
      $filter-&gt;print($buffer);
  }

</PRE>


<P>

This is a streaming filter method, which acquires a single bucket
brigade behind the scenes and reads data from all its
buckets. Therefore it can only read from one bucket brigade per filter
invocation.
<P>

If the <FONT SIZE="-1">EOS</FONT> bucket is read, the <TT>&quot;seen_eos&quot;</TT> method will
return a true value.
<A NAME="lbAS">&nbsp;</A>
<H3>seen_eos</H3>



<A NAME="ixACO"></A>
This methods returns a true value when the <FONT SIZE="-1">EOS</FONT> bucket is seen by the
<TT>&quot;read&quot;</TT> method.
<P>



<PRE>
  $ok = $f-&gt;seen_eos;

</PRE>


<DL COMPACT>
<DT>obj: $f ( Apache2::Filter object )<DD>


<A NAME="ixACP"></A>
The filter to remove
<DT>ret: $ok ( boolean )<DD>


<A NAME="ixACQ"></A>
a true value if <FONT SIZE="-1">EOS</FONT> has been seen, otherwise a false value
<DT>since: 2.0.00<DD>
<A NAME="ixACR"></A>
</DL>
<P>

This method only works in streaming filters which exhaustively
<TT>&quot;$f-&gt;read&quot;</TT> all the incoming data in a while loop,
like so:
<P>



<PRE>
      while ($f-&gt;read(my $buffer, $wanted)) {
          # do something with $buffer
      }
      if ($f-&gt;seen_eos) {
          # do something
      }

</PRE>


<P>

The technique in this example is useful when a streaming filter wants
to append something to the very end of data, or do something at the
end of the last filter invocation. After the <FONT SIZE="-1">EOS</FONT> bucket is read, the
filter should expect not to be invoked again.
<P>

If an input streaming filter doesn't consume all data in the bucket
brigade (or even in several bucket brigades), it has to generate the
<FONT SIZE="-1">EOS</FONT> event by itself. So when the filter is done it has to set the <FONT SIZE="-1">EOS</FONT>
flag:
<P>



<PRE>
  $f-&gt;<A HREF="/manpages/index.html?1+seen_eos">seen_eos</A>(1);

</PRE>


<P>

when the filter handler returns, internally mod_perl will take care of
creating and sending the <FONT SIZE="-1">EOS</FONT> bucket to the upstream input filter.
<P>

A similar logic may apply for output filters.
<P>

In most other cases you shouldn't set this flag.  When this flag is
prematurely set (before the real <FONT SIZE="-1">EOS</FONT> bucket has arrived) in the
current filter invocation, instead of invoking the filter again,
mod_perl will create and send the <FONT SIZE="-1">EOS</FONT> bucket to the next filter,
ignoring any other bucket brigades that may have left to consume. As
mentioned earlier this special behavior is useful in writing special
tests that test abnormal situations.
<A NAME="lbAT">&nbsp;</A>
<H2>Other Filter-related API</H2>

<A NAME="ixACS"></A>
Other methods which affect filters, but called on
non-<TT>&quot;Apache2::Filter&quot;</TT> objects:
<A NAME="lbAU">&nbsp;</A>
<H3>add_input_filter</H3>



<A NAME="ixACT"></A>
Add <TT>&amp;callback</TT> filter handler to input request filter chain.
<P>



<PRE>
  $r-&gt;add_input_filter(\&amp;callback);

</PRE>


<P>

Add <TT>&amp;callback</TT> filter handler to input connection filter chain.
<P>



<PRE>
  $c-&gt;add_input_filter(\&amp;callback);

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object ) or $r ( Apache2::RequestRec object )<DD>


<A NAME="ixACU"></A>

<DT>arg1: &amp;callback (<FONT SIZE="-1">CODE</FONT> ref)<DD>


<A NAME="ixACV"></A>
<DT>ret: no return value<DD>
<A NAME="ixACW"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixACX"></A>

</DL>
<P>

[<FONT SIZE="-1">META:</FONT> It seems that you can't add a filter when another filter is
called. I've tried to add an output connection filter from the input
connection filter when it was called for the first time. It didn't
have any affect for the first request (over keepalive connection). The
only way I succeeded to do that is from that input connection filter's
filter_init handler.
In fact it does work if there is any filter additional filter of the
same kind configured from httpd.conf or via filter_init. It looks like
there is a bug in httpd, where it doesn't prepare the chain of 3rd
party filter if none were inserted before the first filter was called.]
<A NAME="lbAV">&nbsp;</A>
<H3>add_output_filter</H3>



<A NAME="ixACY"></A>
Add <TT>&amp;callback</TT> filter handler to output request filter chain.
<P>



<PRE>
  $r-&gt;add_output_filter(\&amp;callback);

</PRE>


<P>

Add <TT>&amp;callback</TT> filter handler to output connection filter chain.
<P>



<PRE>
  $c-&gt;add_output_filter(\&amp;callback);

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object ) or $r ( Apache2::RequestRec object )<DD>


<A NAME="ixACZ"></A>

<DT>arg1: &amp;callback (<FONT SIZE="-1">CODE</FONT> ref)<DD>


<A NAME="ixADA"></A>
<DT>ret: no return value<DD>
<A NAME="ixADB"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixADC"></A>

</DL>
<A NAME="lbAW">&nbsp;</A>
<H2>Filter Handler Attributes</H2>

<A NAME="ixADD"></A>
Packages using filter attributes have to subclass <TT>&quot;Apache2::Filter&quot;</TT>:
<P>



<PRE>
  package MyApache2::FilterCool;
  use base qw(Apache2::Filter);

</PRE>


<P>

Attributes are parsed during the code compilation, by the function
<TT>&quot;MODIFY_CODE_ATTRIBUTES&quot;</TT>, inherited from the <TT>&quot;Apache2::Filter&quot;</TT>
package.
<A NAME="lbAX">&nbsp;</A>
<H3>FilterRequestHandler</H3>



<A NAME="ixADE"></A>
The <TT>&quot;FilterRequestHandler&quot;</TT> attribute tells mod_perl to insert the
filter into an <FONT SIZE="-1">HTTP</FONT> request filter chain.
<P>

For example, to configure an output request filter handler, use the
<TT>&quot;FilterRequestHandler&quot;</TT> attribute in the handler subroutine's
declaration:
<P>



<PRE>
  package MyApache2::FilterOutputReq;
  sub handler : FilterRequestHandler { ... }

</PRE>


<P>

and add the configuration entry:
<P>



<PRE>
  PerlOutputFilterHandler MyApache2::FilterOutputReq

</PRE>


<P>

This is the default mode. So if you are writing an <FONT SIZE="-1">HTTP</FONT> request
filter, you don't have to specify this attribute.
<P>

The section <FONT SIZE="-1">HTTP</FONT> Request vs. Connection
Filters
delves into more details.
<A NAME="lbAY">&nbsp;</A>
<H3>FilterConnectionHandler</H3>



<A NAME="ixADF"></A>
The <TT>&quot;FilterConnectionHandler&quot;</TT> attribute tells mod_perl to insert this
filter into a connection filter chain.
<P>

For example, to configure an output connection filter handler, use the
<TT>&quot;FilterConnectionHandler&quot;</TT> attribute in the handler subroutine's
declaration:
<P>



<PRE>
  package MyApache2::FilterOutputCon;
  sub handler : FilterConnectionHandler { ... }

</PRE>


<P>

and add the configuration entry:
<P>



<PRE>
  PerlOutputFilterHandler MyApache2::FilterOutputCon

</PRE>


<P>

The section <FONT SIZE="-1">HTTP</FONT> Request vs. Connection
Filters
delves into more details.
<A NAME="lbAZ">&nbsp;</A>
<H3>FilterInitHandler</H3>



<A NAME="ixADG"></A>
The attribute <TT>&quot;FilterInitHandler&quot;</TT> marks the function suitable to be
used as a filter initialization callback, which is called immediately
after a filter is inserted to the filter chain and before it's
actually called.
<P>



<PRE>
  sub init : FilterInitHandler {
      my $f = shift;
      #...
      return Apache2::Const::OK;
  }

</PRE>


<P>

In order to hook this filter callback, the real filter has to assign
this callback using the
<TT>&quot;FilterHasInitHandler&quot;</TT> which accepts a
reference to the callback function.
<P>

For further discussion and examples refer to the Filter
Initialization
Phase
tutorial section.
<A NAME="lbBA">&nbsp;</A>
<H3>FilterHasInitHandler</H3>



<A NAME="ixADH"></A>
If a filter wants to run an initialization callback it can register
such using the <TT>&quot;FilterHasInitHandler&quot;</TT> attribute. Similar to
<TT>&quot;push_handlers&quot;</TT> the callback reference is expected, rather than a
callback name. The used callback function has to have the
<TT>&quot;FilterInitHandler&quot;</TT> attribute. For example:
<P>



<PRE>
  package MyApache2::FilterBar;
  use base qw(Apache2::Filter);
  sub init   : FilterInitHandler { ... }
  sub filter : FilterRequestHandler FilterHasInitHandler(\&amp;init) {
      my ($f, $bb) = @_;
      # ...
      return Apache2::Const::OK;
  }

</PRE>


<P>

For further discussion and examples refer to the Filter
Initialization
Phase
tutorial section.
<A NAME="lbBB">&nbsp;</A>
<H2>Configuration</H2>

<A NAME="ixADI"></A>
mod_perl 2.0 filters configuration is explained in the filter
handlers
tutorial.
<A NAME="lbBC">&nbsp;</A>
<H3>PerlInputFilterHandler</H3>



<A NAME="ixADJ"></A>
See
<TT>&quot;PerlInputFilterHandler&quot;</TT>.
<A NAME="lbBD">&nbsp;</A>
<H3>PerlOutputFilterHandler</H3>



<A NAME="ixADK"></A>
See
<TT>&quot;PerlOutputFilterHandler&quot;</TT>.
<A NAME="lbBE">&nbsp;</A>
<H3>PerlSetInputFilter</H3>



<A NAME="ixADL"></A>
See
<TT>&quot;PerlSetInputFilter&quot;</TT>.
<A NAME="lbBF">&nbsp;</A>
<H3>PerlSetOutputFilter</H3>



<A NAME="ixADM"></A>
See
<TT>&quot;PerlSetInputFilter&quot;</TT>.
<A NAME="lbBG">&nbsp;</A>
<H2>TIE Interface</H2>

<A NAME="ixADN"></A>
<TT>&quot;Apache2::Filter&quot;</TT> also implements a tied interface, so you can work
with the <TT>$f</TT> object as a hash reference.
<P>

The <FONT SIZE="-1">TIE</FONT> interface is mostly unimplemented and might be implemented
post 2.0 release.
<A NAME="lbBH">&nbsp;</A>
<H3>TIEHANDLE</H3>



<A NAME="ixADO"></A>


<PRE>
  $ret = TIEHANDLE($stashsv, $sv);

</PRE>


<DL COMPACT>
<DT>obj: $stashsv ( <FONT SIZE="-1">SCALAR</FONT> )<DD>


<A NAME="ixADP"></A>

<DT>arg1: $sv ( <FONT SIZE="-1">SCALAR</FONT> )<DD>


<A NAME="ixADQ"></A>
<DT>ret: $ret ( <FONT SIZE="-1">SCALAR</FONT> )<DD>


<A NAME="ixADR"></A>
<DT>since: subject to change<DD>
<A NAME="ixADS"></A>

</DL>
<A NAME="lbBI">&nbsp;</A>
<H3>PRINT</H3>



<A NAME="ixADT"></A>


<PRE>
  $ret = PRINT(...);

</PRE>


<DL COMPACT>
<DT>obj: ... (<FONT SIZE="-1">XXX</FONT>)<DD>


<A NAME="ixADU"></A>

<DT>ret: $ret ( integer )<DD>


<A NAME="ixADV"></A>
<DT>since: subject to change<DD>
<A NAME="ixADW"></A>

</DL>
<A NAME="lbBJ">&nbsp;</A>
<H2>See Also</H2>

<A NAME="ixADX"></A>
mod_perl 2.0 documentation.
<A NAME="lbBK">&nbsp;</A>
<H2>Copyright</H2>

<A NAME="ixADY"></A>
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
<A NAME="lbBL">&nbsp;</A>
<H2>Authors</H2>

<A NAME="ixADZ"></A>
The mod_perl development team and numerous
contributors.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">Synopsis</A><DD>
<DT><A HREF="#lbAD">Description</A><DD>
<DT><A HREF="#lbAE">Common Filter API</A><DD>
<DL>
<DT><A HREF="#lbAF">c</A><DD>
<DT><A HREF="#lbAG">ctx</A><DD>
<DT><A HREF="#lbAH">frec</A><DD>
<DT><A HREF="#lbAI">next</A><DD>
<DT><A HREF="#lbAJ">r</A><DD>
<DT><A HREF="#lbAK">remove</A><DD>
</DL>
<DT><A HREF="#lbAL">Bucket Brigade Filter API</A><DD>
<DL>
<DT><A HREF="#lbAM">fflush</A><DD>
<DT><A HREF="#lbAN">get_brigade</A><DD>
<DT><A HREF="#lbAO">pass_brigade</A><DD>
</DL>
<DT><A HREF="#lbAP">Streaming Filter API</A><DD>
<DL>
<DT><A HREF="#lbAQ">print</A><DD>
<DT><A HREF="#lbAR">read</A><DD>
<DT><A HREF="#lbAS">seen_eos</A><DD>
</DL>
<DT><A HREF="#lbAT">Other Filter-related API</A><DD>
<DL>
<DT><A HREF="#lbAU">add_input_filter</A><DD>
<DT><A HREF="#lbAV">add_output_filter</A><DD>
</DL>
<DT><A HREF="#lbAW">Filter Handler Attributes</A><DD>
<DL>
<DT><A HREF="#lbAX">FilterRequestHandler</A><DD>
<DT><A HREF="#lbAY">FilterConnectionHandler</A><DD>
<DT><A HREF="#lbAZ">FilterInitHandler</A><DD>
<DT><A HREF="#lbBA">FilterHasInitHandler</A><DD>
</DL>
<DT><A HREF="#lbBB">Configuration</A><DD>
<DL>
<DT><A HREF="#lbBC">PerlInputFilterHandler</A><DD>
<DT><A HREF="#lbBD">PerlOutputFilterHandler</A><DD>
<DT><A HREF="#lbBE">PerlSetInputFilter</A><DD>
<DT><A HREF="#lbBF">PerlSetOutputFilter</A><DD>
</DL>
<DT><A HREF="#lbBG">TIE Interface</A><DD>
<DL>
<DT><A HREF="#lbBH">TIEHANDLE</A><DD>
<DT><A HREF="#lbBI">PRINT</A><DD>
</DL>
<DT><A HREF="#lbBJ">See Also</A><DD>
<DT><A HREF="#lbBK">Copyright</A><DD>
<DT><A HREF="#lbBL">Authors</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:11 GMT, December 24, 2015
</div></body>
</HTML>
