<!DOCTYPE html>

<HTML><head><TITLE>Manpage of Class::MethodMaker::Engine</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"documentation"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>Class::MethodMaker::Engine</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2010-05-10<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Class::MethodMaker::Engine - The parameter passing, method installation &amp;
non-data-structure methods of Class::MethodMaker.
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>
This class is for internal implementation only.  It is not a public <FONT SIZE="-1">API</FONT>.
<P>

The non-data-structure methods do form part of the public <FONT SIZE="-1">API</FONT>, but not called
directly: rather, called through the <TT>&quot;use&quot;</TT>/<TT>&quot;import&quot;</TT> interface, as for
data-structure methods.
<A NAME="lbAD">&nbsp;</A>
<H2>The Class::MethodMaker Method Installation Engine</H2>

<A NAME="ixAAD"></A>
<P>
<A NAME="lbAE">&nbsp;</A>
<H3>import</H3>

<A NAME="ixAAE"></A>
This performs argument parsing ready for calling create_methods.  In
particular, this is the point at which v1 &amp; v2 calls are distinguished.
<P>

This is implicitly called as part of a <TT>&quot;use&quot;</TT> statement:
<P>



<PRE>
  use Class::MethodMaker
    [ scalar =&gt; [qw/ foo bar baz /],
      new    =&gt; [qw/ new /]        ,
    ];

</PRE>


<P>

is equivalent to
<P>



<PRE>
  Class::MethodMaker-&gt;import([scalar =&gt; [qw/ foo bar baz /],
                              new    =&gt; [qw/ new /]        ,
                             ]);

</PRE>


<P>

See perldoc -f use for details of this equivalence.
<P>

The methods created are installed into the class calling the import - or more
accurately, the first class up the calling stack that is not
<TT>&quot;Class::MethodMaker&quot;</TT> or a subclass thereof.
<DL COMPACT>
<DT><FONT SIZE="-1">SYNOPSIS</FONT><DD>
<A NAME="ixAAF"></A>


<PRE>
  Class::MethodMaker-&gt;import([scalar =&gt; [+{ -type   =&gt; 'File::Stat',
                                            -forward =&gt; [qw/ mode size /],
                                            '*_foo' =&gt; '*_fig',
                                            '*_gop' =&gt; undef,
                                            '*_bar' =&gt; '*_bar',
                                            '*_hal' =&gt; '*_sal',
                                           },
                                         qw/ -static bob /,
                                        ]
                             ]);

</PRE>


</DL>
<A NAME="lbAF">&nbsp;</A>
<H3>parse_options</H3>

<A NAME="ixAAG"></A>
Parse the arguments given to import and call create_methods
appropriately.  See main text for options syntax.
<DL COMPACT>
<DT><FONT SIZE="-1">SYNOPSIS</FONT><DD>
<A NAME="ixAAH"></A>


<PRE>
  Class::MethodMaker-&gt;parse_options('TargetClass',
                                    [scalar =&gt;
                                      [{ -type =&gt; 'File::stat',
                                         -forward =&gt; [qw/ mode
                                                          size /],
                                         '*_foo' =&gt; '*_fig',
                                         '*_gop' =&gt; undef,
                                         '*_bar' =&gt; '*_bar',
                                         '*_hal' =&gt; '*_sal',
                                       },
                                       qw( -static bob ),
                                      ]])},

  Class::MethodMaker-&gt;parse_options('TargetClass2',
                                    [scalar =&gt;
                                      ['baz',
                                       { -type =&gt; 'File::stat',
                                         -forward =&gt; [qw/ mode
                                                          size /],
                                         '*_foo' =&gt; '*_fog',
                                         '*_bar' =&gt; '*_bar',
                                         '*_hal' =&gt; '*_sal',
                                       },
                                       qw( -static bob ),
                                      ]],
                                    +{ -type =&gt; 'Math::BigInt', },
                                    +{'*_foo' =&gt; '*_fig',
                                      '*_gop' =&gt; undef,},
                                   )},

</PRE>


<DT><FONT SIZE="-1">ARGUMENTS</FONT><DD>
<A NAME="ixAAI"></A>
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>target_class<DD>
<A NAME="ixAAJ"></A>

The class into which to install components
<DT>args<DD>
<A NAME="ixAAK"></A>
The arguments to parse, as a single arrayref.
<DT>options<DD>
<A NAME="ixAAL"></A>
A hashref of options to apply to all components created by this call (subject
to overriding by explicit option calls).
<DT>renames<DD>
<A NAME="ixAAM"></A>
A hashref of renames to apply to all components created by this call (subject
to overriding by explicit rename calls).
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

</DL>
<A NAME="lbAG">&nbsp;</A>
<H3>create_methods</H3>

<A NAME="ixAAN"></A>
Add methods to a class.  Methods for multiple components may be added this
way, but create_methods handles only one set of options.
parse_options is responsible for sorting which options to
apply to which components, and calling create_methods appropriately.
<DL COMPACT>
<DT><FONT SIZE="-1">SYNOPSIS</FONT><DD>
<A NAME="ixAAO"></A>


<PRE>
  Class::MethodMaker-&gt;create_methods($target_class,
                                     scalar =&gt; bob,
                                     +{ static =&gt; 1,
                                        type   =&gt; 'File::Stat',
                                        forward =&gt; [qw/ mode size /], },
                                     +{ '*_foo' =&gt; '*_fig',
                                        '*_gop' =&gt; undef,
                                        '*_bar' =&gt; '*_bar',
                                        '*_hal' =&gt; '*_sal', }
                                    );

</PRE>


<DT><FONT SIZE="-1">ARGUMENTS</FONT><DD>
<A NAME="ixAAP"></A>
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>targetclass<DD>
<A NAME="ixAAQ"></A>

The class to add methods to.
<DT>type<DD>
<A NAME="ixAAR"></A>
The basic data structure to use for the component, e.g., <TT>&quot;scalar&quot;</TT>.
<DT>compname<DD>
<A NAME="ixAAS"></A>
Component name.  The name must be a valid identifier, i.e., a continguous
non-empty string of word (<TT>&quot;\w&quot;</TT>) characters, of which the first may not be a
digit.
<DT>options<DD>
<A NAME="ixAAT"></A>
A hashref.  Some options (<TT>&quot;static&quot;</TT>, <TT>&quot;type&quot;</TT>, <TT>&quot;default&quot;</TT>, <TT>&quot;default_ctor&quot;</TT>) are
handled by the auto-extender.  These will be invoked if the name is present as
a key and the value is true.  Any other options are passed through to the
method in question.  The options should be named as-is; no leading hyphen
should be applied (i.e., use <TT>&quot;{static =&gt; 1}&quot;</TT> not <TT>&quot;{-static =&gt; 1}&quot;</TT>).
<DT>renames<DD>
<A NAME="ixAAU"></A>
A list of customer renames.  It is a hashref from method name to rename.  The
method name is the generic name (i.e., featuring a <TT>&quot;*&quot;</TT> to replace with the
component name).  The rename is the value to rename with.  It may itself
contain a <TT>&quot;*&quot;</TT> to replace with the component name.  If rename is undef, the
method is <I>not</I> installed.  For methods that would not be installed by default, use a rename value that is the same as the method name.


<P>


So, if a type would normally install methods


<P>




<PRE>
  '*_foo', '*_gop', '*_tom'

</PRE>




<P>


and optionally installs (but not by default)


<P>




<PRE>
  '*_bar', '*_wiz', '*_hal'

</PRE>




<P>


using a renames value of


<P>




<PRE>
  { '*_foo' =&gt; '*_fig',
    '*_gop' =&gt; undef,
    '*_bar' =&gt; '*_bar',
    '*_hal' =&gt; '*_sal',
  }

</PRE>




<P>


with a component name of <TT>&quot;xx&quot;</TT>, then <TT>*_foo</TT> is installed as <TT>&quot;xx_fig&quot;</TT>,
<TT>*_bar</TT> is installed as <TT>&quot;xx_bar&quot;</TT>, <TT>*_wiz</TT> is not installed, <TT>*_hal</TT> is
installed as <TT>&quot;xx_sal&quot;</TT>, <TT>*_gop</TT> is not installed, and <TT>*_tom</TT> is installed
as <TT>&quot;xx_tom&quot;</TT>.


<P>


The value may actually be an arrayref, in which case the function may be
called by any of the multiple names specified.
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

</DL>
<A NAME="lbAH">&nbsp;</A>
<H3>install_methods</H3>

<A NAME="ixAAV"></A>
<DL COMPACT>
<DT><FONT SIZE="-1">SYNOPSIS</FONT><DD>
<A NAME="ixAAW"></A>


<PRE>
  Class::MethodMaker-&gt;install_methods
    ($classname, { incr =&gt; sub { $i++ },
                   decr =&gt; sub { $i-- },
                 }
    );

</PRE>


<DT><FONT SIZE="-1">ARGUMENTS</FONT><DD>
<A NAME="ixAAX"></A>
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>target<DD>
<A NAME="ixAAY"></A>

The class into which the methods are to be installed
<DT>methods<DD>
<A NAME="ixAAZ"></A>
The methods to install, as a hashref.  Keys are the method names; values are
the methods themselves, as code refs.
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

</DL>
<A NAME="lbAI">&nbsp;</A>
<H2>Non-data-structure components</H2>

<A NAME="ixABA"></A>
<P>
<A NAME="lbAJ">&nbsp;</A>
<H3>new</H3>

<A NAME="ixABB"></A>


<PRE>
  use Class::MethodMaker
    [ new =&gt; 'new' ];

</PRE>


<P>

Creates a basic constructor.
<P>

Takes a single string or a reference to an array of strings as its
argument.  For each string creates a simple method that creates and
returns an object of the appropriate class.
<P>

The generated method may be called as a class method, as usual, or as in
instance method, in which case a new object of the same class as the instance
will be created.
<P>

<I>Options</I>
<A NAME="ixABC"></A>
<DL COMPACT>
<DT>-hash<DD>
<A NAME="ixABD"></A>
The contructor will accept as arguments a list of pairs, from component name
to initial value.  For each pair, the named component is initialized by
calling the method of the same name with the given value.  E.g.,


<P>




<PRE>
  package MyClass;
  use Class::MethodMaker
    [ new    =&gt; [qw/ -hash new /],
      scalar =&gt; [qw/ b c /],
    ];

  sub d {
    my $self = shift;
    $self-&gt;{d} = $_[0]
      if @_;
    return $self-&gt;{d};
  }

  package main;
  # The statement below implicitly calls
  # $m-&gt;<A HREF="/manpages/index.html?1+b">b</A>(1); $m-&gt;<A HREF="http://localhost/cgi-bin/man/man2html?2+c">c</A>(2); $m-&gt;<A HREF="http://localhost/cgi-bin/man/man2html?3+d">d</A>(3)
  # on the newly constructed m.
  my $m = MyClass-&gt;new(b =&gt; 1, c =&gt; 2, d =&gt; 3);

</PRE>




<P>


Note that this can also call user-supplied methods that have the name of the
component.


<P>


Instead of a list of pairs, a single hashref may also be passed, which will be
expanded appropriately.  So the above is equivalent to:


<P>




<PRE>
  my $m = MyClass-&gt;new({ b =&gt; 1, c =&gt; 2, d =&gt; 3 });

</PRE>




<P>


<I>Advanced Users:</I> Class::MethodMaker method renaming is taken into account,
so even if the <TT>&quot;*&quot;</TT> method is renamed or removed, this will still work.
<DT>-init<DD>
<A NAME="ixABE"></A>
This option causes the new method to call an initializor method.  The method
is called <TT>&quot;init&quot;</TT> (original, eh?) by default, but the option may be given an
alternative value.  The init method is passed any arguments that were passed
to the constructor, but the method is invoked on the newly constructed
instance.


<P>




<PRE>
  use Class::MethodMaker
    [ new =&gt; [qw/ -init new1 /, { -init =&gt; 'bob' } =&gt; 'init2' ]];

</PRE>




<P>


Constructing with new1 involves an implicit call to <TT>&quot;init&quot;</TT>, whilst
constructing with new2 involves an implicit call to <TT>&quot;bob&quot;</TT> (<I>instead</I> of
<TT>&quot;init&quot;</TT>).


<P>


It is the responsiblity of the user to ensure that an <TT>&quot;init&quot;</TT> method (or
whatever name) is defined.
<DT>-singleton<DD>
<A NAME="ixABF"></A>
Creates a basic constructor which only ever returns a single instance of the
class: i.e., after the first call, repeated calls to this constructor return
the <I>same</I> instance.  Note that the instance is instantiated at the time of
the first call, not before.
</DL>
<A NAME="lbAK">&nbsp;</A>
<H3>abstract</H3>

<A NAME="ixABG"></A>


<PRE>
  use Class::MethodMaker
    [ abstract =&gt; [ qw / foo bar baz / ] ];

</PRE>


<P>

This creates a number of methods that will die if called.  This is intended to
support the use of abstract methods, that must be overidden in a useful
subclass.
<A NAME="lbAL">&nbsp;</A>
<H3>copy</H3>

<A NAME="ixABH"></A>


<PRE>
  use Class::MethodMaker
    [ copy =&gt; [qw/ shallow -deep deep /] ];

</PRE>


<P>

This creates method that produce a copy of self.  The copy is a by default a
<I>shallow</I> copy; any references will be shared by the instance upon which the
method is called and the returned newborn.  One option is taken, <TT>&quot;-deep&quot;</TT>,
which causes the method to create <I>deep</I> copies instead (i.e., references are
copied recursively).
<P>

<B>Implementation Note:</B>
<P>

Deep copies are performed using the <TT>&quot;Storable&quot;</TT> module if available, else
<TT>&quot;Data::Dumper&quot;</TT>.  The <TT>&quot;Storable&quot;</TT> module is liable to be much quicker.
However, this implementation note is not an <FONT SIZE="-1">API</FONT> specification: the
implementation details are open to change in a future version as faster/better
ways of performing a deep copy become available.
<P>

Note that deep copying does not currently support the copying of coderefs,
ties or XS-based objects.
<A NAME="lbAM">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixABI"></A>
Martyn J. Pearce &lt;<A HREF="mailto:fluffy@cpan.org">fluffy@cpan.org</A>&gt;
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">The Class::MethodMaker Method Installation Engine</A><DD>
<DL>
<DT><A HREF="#lbAE">import</A><DD>
<DT><A HREF="#lbAF">parse_options</A><DD>
<DT><A HREF="#lbAG">create_methods</A><DD>
<DT><A HREF="#lbAH">install_methods</A><DD>
</DL>
<DT><A HREF="#lbAI">Non-data-structure components</A><DD>
<DL>
<DT><A HREF="#lbAJ">new</A><DD>
<DT><A HREF="#lbAK">abstract</A><DD>
<DT><A HREF="#lbAL">copy</A><DD>
</DL>
<DT><A HREF="#lbAM">AUTHOR</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:15 GMT, December 24, 2015
</div></div>
</body>
</HTML>
