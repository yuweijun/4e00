<!DOCTYPE html>

<HTML><head><TITLE>Manpage of Sys::Virt::Domain</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>Sys::Virt::Domain</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2012-06-22<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Sys::Virt::Domain - Represent &amp; manage a libvirt guest domain
<A NAME="lbAC">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAC"></A>
The <TT>&quot;Sys::Virt::Domain&quot;</TT> module represents a guest domain managed
by the virtual machine monitor.
<A NAME="lbAD">&nbsp;</A>
<H2>METHODS</H2>

<A NAME="ixAAD"></A>
<DL COMPACT>
<DT>my $id = $dom-&gt;<I>get_id()</I><DD>


<A NAME="ixAAE"></A>
Returns an integer with a locally unique identifier for the
domain.
<DT>my $uuid = $dom-&gt;<I>get_uuid()</I><DD>


<A NAME="ixAAF"></A>
Returns a 16 byte long string containing the raw globally unique identifier
(<FONT SIZE="-1">UUID</FONT>) for the domain.
<DT>my $uuid = $dom-&gt;<I>get_uuid_string()</I><DD>


<A NAME="ixAAG"></A>
Returns a printable string representation of the raw <FONT SIZE="-1">UUID</FONT>, in the format
'<FONT SIZE="-1">XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX</FONT>'.
<DT>my $name = $dom-&gt;<I>get_name()</I><DD>


<A NAME="ixAAH"></A>
Returns a string with a locally unique name of the domain
<DT>my $str = $dom-&gt;get_metadata($type, $uri, $flags =0)<DD>


<A NAME="ixAAI"></A>
Returns the metadata element of type <TT>$type</TT> associated
with the domain. If <TT>$type</TT> is <TT>&quot;Sys::Virt::Domain::METADATA_ELEMENT&quot;</TT>
then the <TT>$uri</TT> parameter specifies the <FONT SIZE="-1">XML</FONT> namespace to
retrieve, otherwise <TT>$uri</TT> should be <TT>&quot;undef&quot;</TT>. The optional
<TT>$flags</TT> parameter defaults to zero.
<DT>$dom-&gt;set_metadata($type, $val, $key, $uri, $flags=0)<DD>


<A NAME="ixAAJ"></A>
Sets the metadata element of type <TT>$type</TT> to hold the value
<TT>$val</TT>. If <TT>$type</TT> is  <TT>&quot;Sys::Virt::Domain::METADATA_ELEMENT&quot;</TT>
then the <TT>$key</TT> and <TT>$uri</TT> elements specify an <FONT SIZE="-1">XML</FONT> namespace
to use, otherwise they should both be <TT>&quot;nudef&quot;</TT>. The optional
<TT>$flags</TT> parameter defaults to zero.
<DT>$dom-&gt;<I>is_active()</I><DD>


<A NAME="ixAAK"></A>
Returns a true value if the domain is currently running
<DT>$dom-&gt;<I>is_persistent()</I><DD>


<A NAME="ixAAL"></A>
Returns a true value if the domain has a persistent configuration
file defined
<DT>$dom-&gt;<I>is_updated()</I><DD>


<A NAME="ixAAM"></A>
Returns a true value if the domain is running and has a persistent
configuration file defined that is out of date compared to the
current live config.
<DT>my $xml = $dom-&gt;get_xml_description($flags=0)<DD>


<A NAME="ixAAN"></A>
Returns an <FONT SIZE="-1">XML</FONT> document containing a complete description of
the domain's configuration. The optional <TT>$flags</TT> parameter
controls generation of the <FONT SIZE="-1">XML</FONT> document, defaulting to 0 if
omitted. It can be one or more of the <FONT SIZE="-1">XML</FONT> <FONT SIZE="-1">DUMP</FONT> constants
listed later in this document.
<DT>my $type = $dom-&gt;<I>get_os_type()</I><DD>


<A NAME="ixAAO"></A>
Returns a string containing the name of the <FONT SIZE="-1">OS</FONT> type running
within the domain.
<DT>$dom-&gt;create($flags)<DD>


<A NAME="ixAAP"></A>
Start a domain whose configuration was previously defined using the
<TT>&quot;define_domain&quot;</TT> method in Sys::Virt. The <TT>$flags</TT> parameter
accepts one of the <FONT SIZE="-1">DOMAIN</FONT> <FONT SIZE="-1">CREATION</FONT> constants documented later, and
defaults to 0 if omitted.
<DT>$dom-&gt;<I>undefine()</I><DD>


<A NAME="ixAAQ"></A>
Remove the configuration associated with a domain previously defined
with the <TT>&quot;define_domain&quot;</TT> method in Sys::Virt. If the domain is
running, you probably want to use the <TT>&quot;shutdown&quot;</TT> or <TT>&quot;destroy&quot;</TT>
methods instead.
<DT>$dom-&gt;<I>suspend()</I><DD>


<A NAME="ixAAR"></A>
Temporarily stop execution of the domain, allowing later continuation
by calling the <TT>&quot;resume&quot;</TT> method.
<DT>$dom-&gt;<I>resume()</I><DD>


<A NAME="ixAAS"></A>
Resume execution of a domain previously halted with the <TT>&quot;suspend&quot;</TT>
method.
<DT>$dom-&gt;pm_suspend_for_duration($target, $duration, $flags=0)<DD>


<A NAME="ixAAT"></A>
Tells the guest <FONT SIZE="-1">OS</FONT> to enter the power management suspend state
identified by <TT>$target</TT>. The <TT>$target</TT> parameter should be
one of the <FONT SIZE="-1">NODE</FONT> <FONT SIZE="-1">SUSPEND</FONT> <FONT SIZE="-1">CONTANTS</FONT> listed in <TT>&quot;Sys::Virt&quot;</TT>. The
<TT>$duration</TT> specifies when the guest should automatically
wakeup. The <TT>$flags</TT> parameter is optional and defaults to
zero.
<DT>$dom-&gt;save($filename)<DD>


<A NAME="ixAAU"></A>
Take a snapshot of the domain's state and save the information to
the file named in the <TT>$filename</TT> parameter. The domain can later
be restored from this file with the <TT>&quot;restore_domain&quot;</TT> method on
the Sys::Virt object.
<DT>$dom-&gt;managed_save($flags=0)<DD>


<A NAME="ixAAV"></A>
Take a snapshot of the domain's state and save the information to
a managed save location. The domain will be automatically restored
with this state when it is next started. The <TT>$flags</TT> parameter is
unused and defaults to zero.
<DT>$bool = $dom-&gt;has_managed_save_image($flags=0)<DD>


<A NAME="ixAAW"></A>
Return a non-zero value if the domain has a managed save image
that will be used at next start. The <TT>$flags</TT> parameter is
unused and defaults to zero.
<DT>$dom-&gt;managed_save_remove($flags=0)<DD>


<A NAME="ixAAX"></A>
Remove the current managed save image, causing the guest to perform
a full boot next time it is started. The <TT>$flags</TT> parameter is
unused and defaults to zero.
<DT>$dom-&gt;core_dump($filename[, $flags])<DD>


<A NAME="ixAAY"></A>
Trigger a core dump of the guest virtual machine, saving its memory
image to <TT>$filename</TT> so it can be analysed by tools such as <TT>&quot;crash&quot;</TT>.
The optional <TT>$flags</TT> flags parameter is currently unused and if
omitted will default to 0.
<DT>$dom-&gt;<I>destroy()</I><DD>


<A NAME="ixAAZ"></A>
Immediately poweroff the machine. This is equivalent to removing the
power plug. The guest <FONT SIZE="-1">OS</FONT> is given no time to cleanup / save state.
For a clean poweroff sequence, use the <TT>&quot;shutdown&quot;</TT> method instead.
<DT>my $info = $dom-&gt;<I>get_info()</I><DD>


<A NAME="ixABA"></A>
Returns a hash reference summarising the execution state of the
domain. The elements of the hash are as follows:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>maxMem<DD>
<A NAME="ixABB"></A>
The maximum memory allowed for this domain, in kilobytes
<DT>memory<DD>
<A NAME="ixABC"></A>
The current memory allocated to the domain in kilobytes
<DT>cpuTime<DD>
<A NAME="ixABD"></A>
The amount of <FONT SIZE="-1">CPU</FONT> time used by the domain
<DT>nrVirtCpu<DD>
<A NAME="ixABE"></A>
The current number of virtual CPUs enabled in the domain
<DT>state<DD>
<A NAME="ixABF"></A>
The execution state of the machine, which will be one of the
constants &amp;Sys::Virt::Domain::STATE_*.
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>my ($state, $reason) = $dom-&gt;<I>get_state()</I><DD>


<A NAME="ixABG"></A>
Returns an array whose values specify the current state
of the guest, and the reason for it being in that state.
The <TT>$state</TT> values are the same as for the <TT>&quot;get_info&quot;</TT>
<FONT SIZE="-1">API</FONT>, and the <TT>$reason</TT> values come from:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>Sys::Virt::Domain::STATE_CRASHED_UNKNOWN<DD>
<A NAME="ixABH"></A>
It is not known why the domain has crashed
<DT>Sys::Virt::Domain::STATE_NOSTATE_UNKNOWN<DD>
<A NAME="ixABI"></A>
It is not known why the domain has no state
<DT>Sys::Virt::Domain::STATE_PAUSED_DUMP<DD>
<A NAME="ixABJ"></A>
The guest is paused due to a core dump operation
<DT>Sys::Virt::Domain::STATE_PAUSED_FROM_SNAPSHOT<DD>
<A NAME="ixABK"></A>
The guest is paused due to a snapshot
<DT>Sys::Virt::Domain::STATE_PAUSED_IOERROR<DD>
<A NAME="ixABL"></A>
The guest is paused due to an I/O error
<DT>Sys::Virt::Domain::STATE_PAUSED_MIGRATION<DD>
<A NAME="ixABM"></A>
The guest is paused due to migration
<DT>Sys::Virt::Domain::STATE_PAUSED_SAVE<DD>
<A NAME="ixABN"></A>
The guest is paused due to a save operation
<DT>Sys::Virt::Domain::STATE_PAUSED_UNKNOWN<DD>
<A NAME="ixABO"></A>
It is not known why the domain has paused
<DT>Sys::Virt::Domain::STATE_PAUSED_USER<DD>
<A NAME="ixABP"></A>
The guest is paused at admin request
<DT>Sys::Virt::Domain::STATE_PAUSED_WATCHDOG<DD>
<A NAME="ixABQ"></A>
The guest is paused due to the watchdog
<DT>Sys::Virt::Domain::STATE_PAUSED_SHUTTING_DOWN<DD>
<A NAME="ixABR"></A>
The guest is paused while domain shutdown takes place
<DT>Sys::Virt::Domain::STATE_RUNNING_BOOTED<DD>
<A NAME="ixABS"></A>
The guest is running after being booted
<DT>Sys::Virt::Domain::STATE_RUNNING_FROM_SNAPSHOT<DD>
<A NAME="ixABT"></A>
The guest is running after restore from snapshot
<DT>Sys::Virt::Domain::STATE_RUNNING_MIGRATED<DD>
<A NAME="ixABU"></A>
The guest is running after migration
<DT>Sys::Virt::Domain::STATE_RUNNING_MIGRATION_CANCELED<DD>
<A NAME="ixABV"></A>
The guest is running after migration abort
<DT>Sys::Virt::Domain::STATE_RUNNING_RESTORED<DD>
<A NAME="ixABW"></A>
The guest is running after restore from file
<DT>Sys::Virt::Domain::STATE_RUNNING_SAVE_CANCELED<DD>
<A NAME="ixABX"></A>
The guest is running after save cancel
<DT>Sys::Virt::Domain::STATE_RUNNING_UNKNOWN<DD>
<A NAME="ixABY"></A>
It is not known why the domain has started
<DT>Sys::Virt::Domain::STATE_RUNNING_UNPAUSED<DD>
<A NAME="ixABZ"></A>
The guest is running after a resume
<DT>Sys::Virt::Domain::STATE_SHUTDOWN_UNKNOWN<DD>
<A NAME="ixACA"></A>
It is not known why the domain has shutdown
<DT>Sys::Virt::Domain::STATE_SHUTDOWN_USER<DD>
<A NAME="ixACB"></A>
The guest is shutdown due to admin request
<DT>Sys::Virt::Domain::STATE_SHUTOFF_CRASHED<DD>
<A NAME="ixACC"></A>
The guest is shutoff after a crash
<DT>Sys::Virt::Domain::STATE_SHUTOFF_DESTROYED<DD>
<A NAME="ixACD"></A>
The guest is shutoff after being destroyed
<DT>Sys::Virt::Domain::STATE_SHUTOFF_FAILED<DD>
<A NAME="ixACE"></A>
The guest is shutoff due to a virtualization failure
<DT>Sys::Virt::Domain::STATE_SHUTOFF_FROM_SNAPSHOT<DD>
<A NAME="ixACF"></A>
The guest is shutoff after a snapshot
<DT>Sys::Virt::Domain::STATE_SHUTOFF_MIGRATED<DD>
<A NAME="ixACG"></A>
The guest is shutoff after migration
<DT>Sys::Virt::Domain::STATE_SHUTOFF_SAVED<DD>
<A NAME="ixACH"></A>
The guest is shutoff after a save
<DT>Sys::Virt::Domain::STATE_SHUTOFF_SHUTDOWN<DD>
<A NAME="ixACI"></A>
The guest is shutoff due to controlled shutdown
<DT>Sys::Virt::Domain::STATE_SHUTOFF_UNKNOWN<DD>
<A NAME="ixACJ"></A>
It is not known why the domain has shutoff
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>my $info = $dom-&gt;get_control_info($flags=0)<DD>


<A NAME="ixACK"></A>
Returns a hash reference providing information about
the control channel. The returned keys in the hash
are
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>state<DD>


<A NAME="ixACL"></A>
One of the <FONT SIZE="-1">CONTROL</FONT> <FONT SIZE="-1">INFO</FONT> constants listed later
<DT>details<DD>


<A NAME="ixACM"></A>
Currently unsed, always 0.
<DT>stateTime<DD>


<A NAME="ixACN"></A>
The elapsed time since the control channel entered
the current state.
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>my @errs = $dom-&gt;get_disk_errors($flags=0)<DD>


<A NAME="ixACO"></A>
Returns a list of all disk errors that have occurred on
the backing store for the guest's virtual disks. The
returned array elements are hash references, containing
two keys
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>path<DD>


<A NAME="ixACP"></A>
The path of the disk with an error
<DT>error<DD>


<A NAME="ixACQ"></A>
The error type
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>$dom-&gt;send_key($keycodeset, $holdtime, \@keycodes, $flags=0)<DD>


<A NAME="ixACR"></A>
Sends a sequence of keycodes to the guest domain. The
<TT>$keycodeset</TT> should be one of the constants listed
later in the <FONT SIZE="-1">KEYCODE</FONT> <FONT SIZE="-1">SET</FONT> section. <TT>$holdtiem</TT> is the
duration, in milliseconds, to keep the key pressed
before releasing it and sending the next keycode.
<TT>@keycodes</TT> is an array reference containing the list
of keycodes to send to the guest. The elements in the
array should be keycode values from the specified
keycode set. <TT>$flags</TT> is currently unused.
<DT>my $info = $dom-&gt;get_block_info($dev, $flags=0)<DD>


<A NAME="ixACS"></A>
Returns a hash reference summarising the disk usage of
the host backing store for a guest block device. The
<TT>$dev</TT> parameter should be the path to the backing
store on the host. <TT>$flags</TT> is currently unused and
defaults to 0 if omitted. The returned hash contains
the following elements
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>capacity<DD>
<A NAME="ixACT"></A>
Logical size in bytes of the block device backing image *
<DT>allocation<DD>
<A NAME="ixACU"></A>
Highest allocated extent in bytes of the block device backing image
<DT>physical<DD>
<A NAME="ixACV"></A>
Physical size in bytes of the container of the backing image
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>$dom-&gt;set_max_memory($mem)<DD>


<A NAME="ixACW"></A>
Set the maximum memory for the domain to the value <TT>$mem</TT>. The
value of the <TT>$mem</TT> parameter is specified in kilobytes.
<DT>$mem = $dom-&gt;<I>get_max_memory()</I><DD>


<A NAME="ixACX"></A>
Returns the current maximum memory allowed for this domain in
kilobytes.
<DT>$dom-&gt;set_memory($mem, $flags)<DD>


<A NAME="ixACY"></A>
Set the current memory for the domain to the value <TT>$mem</TT>. The
value of the <TT>$mem</TT> parameter is specified in kilobytes. This
must be less than, or equal to the domain's max memory limit.
The <TT>$flags</TT> parameter can control whether the update affects
the live guest, or inactive config, defaulting to modifying
the current state.
<DT>$dom-&gt;<I>shutdown()</I><DD>


<A NAME="ixACZ"></A>
Request that the guest <FONT SIZE="-1">OS</FONT> perform a graceful shutdown and
poweroff. This usually requires some form of cooperation
from the guest operating system, such as responding to an
<FONT SIZE="-1">ACPI</FONT> signal, or a guest agent process. For an immediate,
forceful poweroff, use the <TT>&quot;destroy&quot;</TT> method instead.
<DT>$dom-&gt;reboot([$flags])<DD>


<A NAME="ixADA"></A>
Request that the guest <FONT SIZE="-1">OS</FONT> perform a graceful shutdown and
optionally restart. The optional <TT>$flags</TT> parameter is
currently unused and if omitted defaults to zero.
<DT>$dom-&gt;reset([$flags])<DD>


<A NAME="ixADB"></A>
Perform a hardware reset of the virtual machine. The guest
<FONT SIZE="-1">OS</FONT> is given no opportunity to shutdown gracefully. The
optional <TT>$flags</TT> parameter is currently unused and if
omitted defaults to zero.
<DT>$dom-&gt;<I>get_max_vcpus()</I><DD>


<A NAME="ixADC"></A>
Return the maximum number of vcpus that are configured
for the domain
<DT>$dom-&gt;attach_device($xml[, $flags])<DD>


<A NAME="ixADD"></A>
Hotplug a new device whose configuration is given by <TT>$xml</TT>,
to the running guest. The optional &lt;$flags&gt; parameter defaults
to 0, but can accept one of the device hotplug flags described
later.
<DT>$dom-&gt;detach_device($xml[, $flags])<DD>


<A NAME="ixADE"></A>
Hotunplug a existing device whose configuration is given by <TT>$xml</TT>,
from the running guest. The optional &lt;$flags&gt; parameter defaults
to 0, but can accept one of the device hotplug flags described
later.
<DT>$dom-&gt;update_device($xml[, $flags])<DD>


<A NAME="ixADF"></A>
Update the configuration of an existing device. The new configuration
is given by <TT>$xml</TT>. The optional &lt;$flags&gt; parameter defaults to
0 but can accept one of the device hotplug flags described later.
<DT>$data = $dom-&gt;block_peek($path, $offset, $size[, $flags)<DD>


<A NAME="ixADG"></A>
Peek into the guest disk <TT>$path</TT>, at byte <TT>$offset</TT> capturing
<TT>$size</TT> bytes of data. The returned scalar may contain embedded
NULLs. The optional <TT>$flags</TT> parameter is currently unused and
if omitted defaults to zero.
<DT>$data = $dom-&gt;memory_peek($offset, $size[, $flags])<DD>


<A NAME="ixADH"></A>
Peek into the guest memory at byte <TT>$offset</TT> virtual address,
capturing <TT>$size</TT> bytes of memory. The return scalar may
contain embedded NULLs. The optional <TT>$flags</TT> parameter is
currently unused and if omitted defaults to zero.
<DT>$flag = $dom-&gt;<I>get_autostart()</I>;<DD>


<A NAME="ixADI"></A>
Return a true value if the guest domain is configured to automatically
start upon boot. Return false, otherwise
<DT>$dom-&gt;set_autostart($flag)<DD>


<A NAME="ixADJ"></A>
Set the state of the autostart flag, which determines whether the
guest will automatically start upon boot of the host <FONT SIZE="-1">OS</FONT>
<DT>$dom-&gt;set_vcpus($count, [$flags])<DD>


<A NAME="ixADK"></A>
Set the number of virtual CPUs in the guest <FONT SIZE="-1">VM</FONT> to <TT>$count</TT>.
The optional <TT>$flags</TT> parameter can be used to control whether
the setting changes the live config or inactive config.
<DT>$count = $dom-&gt;get_vcpus([$flags])<DD>


<A NAME="ixADL"></A>
Get the number of virtual CPUs in the guest <FONT SIZE="-1">VM</FONT>.
The optional <TT>$flags</TT> parameter can be used to control whether
to query the setting of the live config or inactive config.
<DT>$type = $dom-&gt;<I>get_scheduler_type()</I><DD>


<A NAME="ixADM"></A>
Return the scheduler type for the guest domain
<DT>$stats = $dom-&gt;block_stats($path)<DD>


<A NAME="ixADN"></A>
Fetch the current I/O statistics for the block device given by <TT>$path</TT>.
The returned hash reference contains keys for
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>rd_req<DD>


<A NAME="ixADO"></A>
Number of read requests
<DT>rd_bytes<DD>


<A NAME="ixADP"></A>
Number of bytes read
<DT>wr_req<DD>


<A NAME="ixADQ"></A>
Number of write requests
<DT>wr_bytes<DD>


<A NAME="ixADR"></A>
Number of bytes written
<DT>errs<DD>


<A NAME="ixADS"></A>
Some kind of error count
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>my $params = $dom-&gt;get_scheduler_parameters($flags=0)<DD>


<A NAME="ixADT"></A>
Return the set of scheduler tunable parameters for the guest,
as a hash reference. The precise set of keys in the hash
are specific to the hypervisor.
<DT>$dom-&gt;set_scheduler_parameters($params, $flags=0)<DD>


<A NAME="ixADU"></A>
Update the set of scheduler tunable parameters. The value names for
tunables vary, and can be discovered using the <TT>&quot;get_scheduler_params&quot;</TT>
call
<DT>my $params = $dom-&gt;get_memory_parameters($flags=0)<DD>


<A NAME="ixADV"></A>
Return a hash reference containing the set of memory tunable
parameters for the guest. The keys in the hash are one of the
constants <FONT SIZE="-1">MEMORY</FONT> <FONT SIZE="-1">PARAMETERS</FONT> described later.
<DT>$dom-&gt;set_memory_parameters($params, $flags=0)<DD>


<A NAME="ixADW"></A>
Update the memory tunable parameters for the guest. The
<TT>$params</TT> should be a hash reference whose keys are one
of the <FONT SIZE="-1">MEMORY</FONT> <FONT SIZE="-1">PARAMETERS</FONT> constants.
<DT>my $params = $dom-&gt;get_blkio_parameters($flags=0)<DD>


<A NAME="ixADX"></A>
Return a hash reference containing the set of blkio tunable
parameters for the guest. The keys in the hash are one of the
constants <FONT SIZE="-1">BLKIO</FONT> <FONT SIZE="-1">PARAMETERS</FONT> described later.
<DT>$dom-&gt;set_blkio_parameters($params, $flags=0)<DD>


<A NAME="ixADY"></A>
Update the blkio tunable parameters for the guest. The
<TT>$params</TT> should be a hash reference whose keys are one
of the <FONT SIZE="-1">BLKIO</FONT> <FONT SIZE="-1">PARAMETERS</FONT> constants.
<DT>$stats = $dom-&gt;get_block_iotune($disk, $flags=0)<DD>


<A NAME="ixADZ"></A>
Return a hash reference containing the set of blkio tunable
parameters for the guest disk <TT>$disk</TT>. The keys in the hash
are one of the constants <FONT SIZE="-1">BLOCK</FONT> <FONT SIZE="-1">IOTUNE</FONT> <FONT SIZE="-1">PARAMETERS</FONT> described later.
<DT>$dom-&gt;set_block_iotune($disk, $params, $flags=0);<DD>


<A NAME="ixAEA"></A>
Update the blkio tunable parameters for the guest disk <TT>$disk</TT>. The
<TT>$params</TT> should be a hash reference whose keys are one
of the <FONT SIZE="-1">BLOCK</FONT> <FONT SIZE="-1">IOTUNE</FONT> <FONT SIZE="-1">PARAMETERS</FONT> constants.
<DT>my $params = $dom-&gt;get_interface_parameters($intf, $flags=0)<DD>


<A NAME="ixAEB"></A>
Return a hash reference containing the set of interface tunable
parameters for the guest. The keys in the hash are one of the
constants <FONT SIZE="-1">INTERFACE</FONT> <FONT SIZE="-1">PARAMETERS</FONT> described later.
<DT>$dom-&gt;set_interface_parameters($intf, $params, $flags=0)<DD>


<A NAME="ixAEC"></A>
Update the interface tunable parameters for the guest. The
<TT>$params</TT> should be a hash reference whose keys are one
of the <FONT SIZE="-1">INTERFACE</FONT> <FONT SIZE="-1">PARAMETERS</FONT> constants.
<DT>my $params = $dom-&gt;get_numa_parameters($flags=0)<DD>


<A NAME="ixAED"></A>
Return a hash reference containing the set of numa tunable
parameters for the guest. The keys in the hash are one of the
constants <FONT SIZE="-1">NUMA</FONT> <FONT SIZE="-1">PARAMETERS</FONT> described later.
<DT>$dom-&gt;set_numa_parameters($params, $flags=0)<DD>


<A NAME="ixAEE"></A>
Update the numa tunable parameters for the guest. The
<TT>$params</TT> should be a hash reference whose keys are one
of the <FONT SIZE="-1">NUMA</FONT> <FONT SIZE="-1">PARAMETERS</FONT> constants.
<DT>$dom-&gt;block_resize($disk, $newsize, $flags=0)<DD>


<A NAME="ixAEF"></A>
Resize the disk <TT>$disk</TT> to have new size <TT>$newsize</TT>. If the disk
is backed by a special image format, the actual resize is done by the
hypervisor. If the disk is backed by a raw file, or block device,
the resize must be done prior to invoking this <FONT SIZE="-1">API</FONT> call, and it
merely updates the hypervisor's view of the disk size.
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>weight<DD>


<A NAME="ixAEG"></A>
Relative I/O weighting
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>$dom-&gt;interface_stats($path)<DD>


<A NAME="ixAEH"></A>
Fetch the current I/O statistics for the block device given by <TT>$path</TT>.
The returned hash containins keys for
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>rx_bytes<DD>


<A NAME="ixAEI"></A>
Total bytes received
<DT>rx_packets<DD>


<A NAME="ixAEJ"></A>
Total packets received
<DT>rx_errs<DD>


<A NAME="ixAEK"></A>
Total packets received with errors
<DT>rx_drop<DD>


<A NAME="ixAEL"></A>
Total packets drop at reception
<DT>tx_bytes<DD>


<A NAME="ixAEM"></A>
Total bytes transmitted
<DT>tx_packets<DD>


<A NAME="ixAEN"></A>
Total packets transmitted
<DT>tx_errs<DD>


<A NAME="ixAEO"></A>
Total packets transmitted with errors
<DT>tx_drop<DD>


<A NAME="ixAEP"></A>
Total packets dropped at transmission.
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>$dom-&gt;memory_stats($flags=0)<DD>


<A NAME="ixAEQ"></A>
Fetch the current memory statistics for the guest domain. The
<TT>$flags</TT> parameter is currently unused and can be omitted.
The returned hash containins keys for
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>swap_in<DD>


<A NAME="ixAER"></A>
Data read from swap space
<DT>swap_out<DD>


<A NAME="ixAES"></A>
Data written to swap space
<DT>major_fault<DD>


<A NAME="ixAET"></A>
Page fault involving disk I/O
<DT>minor_fault<DD>


<A NAME="ixAEU"></A>
Page fault not involving disk I/O
<DT>unused<DD>


<A NAME="ixAEV"></A>
Memory not used by the system
<DT>available<DD>


<A NAME="ixAEW"></A>
Total memory seen by guest
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>$info = $dom-&gt;<I>get_security_label()</I><DD>


<A NAME="ixAEX"></A>
Fetch information about the security label assigned to the guest
domain. The returned hash reference has two keys, <TT>&quot;model&quot;</TT> gives
the name of the security model in effect (eg <TT>&quot;selinux&quot;</TT>), while
<TT>&quot;label&quot;</TT> provides the name of the security label applied to the
domain.
<DT>$ddom = $dom-&gt;migrate(destcon, flags, dname, uri, bandwidth)<DD>


<A NAME="ixAEY"></A>
Migrate a domain to an alternative host. The <TT>&quot;destcon&quot;</TT> parameter
should be a <TT>&quot;Sys::Virt&quot;</TT> connection to the remote target host.
If the <TT>&quot;flags&quot;</TT> parameter is zero offline migration will be
performed. The <TT>&quot;Sys::Virt::Domain::MIGRATE_LIVE&quot;</TT> constant can be
used to request live migration. The <TT>&quot;dname&quot;</TT> parameter allows the
guest to be renamed on the target host, if set to <TT>&quot;undef&quot;</TT>, the
domains' current name will be maintained. In normal circumstances,
the source host determines the target hostname from the <FONT SIZE="-1">URI</FONT> associated
with the <TT>&quot;destcon&quot;</TT> connection. If the destination host is multi-homed
it may be necessary to supply an alternate destination hostame
via the <TT>&quot;uri&quot;</TT> parameter. The <TT>&quot;bandwidth&quot;</TT> parameter allows network
usage to be throttled during migration. If set to zero, no throttling
will be performed. The <TT>&quot;flags&quot;</TT>, <TT>&quot;dname&quot;</TT>, <TT>&quot;uri&quot;</TT> and <TT>&quot;bandwidth&quot;</TT>
parameters are all optional, and if omitted default to zero, <TT>&quot;undef&quot;</TT>,
<TT>&quot;undef&quot;</TT>, and zero respectively.
<DT>$ddom = $dom-&gt;migrate2(destcon, dxml, flags, dname, uri, bandwidth)<DD>


<A NAME="ixAEZ"></A>
Migrate a domain to an alternative host. This function works in the
same way as <TT>&quot;migrate&quot;</TT>, except is also allows <TT>&quot;dxml&quot;</TT> to specify a
changed <FONT SIZE="-1">XML</FONT> configuration for the guest on the target host.
<DT>$dom-&gt;migrate_to_uri(desturi, flags, dname, bandwidth)<DD>


<A NAME="ixAFA"></A>
Migrate a domain to an alternative host. The <TT>&quot;destri&quot;</TT> parameter
should be a valid libvirt connection <FONT SIZE="-1">URI</FONT> for the remote target host.
If the <TT>&quot;flags&quot;</TT> parameter is zero offline migration will be
performed. The <TT>&quot;Sys::Virt::Domain::MIGRATE_LIVE&quot;</TT> constant can be
used to request live migration. The <TT>&quot;dname&quot;</TT> parameter allows the
guest to be renamed on the target host, if set to <TT>&quot;undef&quot;</TT>, the
domains' current name will be maintained. In normal circumstances,
the source host determines the target hostname from the <FONT SIZE="-1">URI</FONT> associated
with the <TT>&quot;destcon&quot;</TT> connection. If the destination host is multi-homed
it may be necessary to supply an alternate destination hostame
via the <TT>&quot;uri&quot;</TT> parameter. The <TT>&quot;bandwidth&quot;</TT> parameter allows network
usage to be throttled during migration. If set to zero, no throttling
will be performed. The <TT>&quot;flags&quot;</TT>, <TT>&quot;dname&quot;</TT> and <TT>&quot;bandwidth&quot;</TT>
parameters are all optional, and if omitted default to zero, <TT>&quot;undef&quot;</TT>,
<TT>&quot;undef&quot;</TT>, and zero respectively.
<DT>$dom-&gt;migrate_to_uri2(dconnuri, miguri, dxml, flags, dname, bandwidth)<DD>


<A NAME="ixAFB"></A>
Migrate a domain to an alternative host. This function works in almost
the same way as <TT>&quot;migrate_to_uri&quot;</TT>, except is also allows <TT>&quot;dxml&quot;</TT> to
specify a changed <FONT SIZE="-1">XML</FONT> configuration for the guest on the target host.
The <TT>&quot;dconnuri&quot;</TT> must always specify the <FONT SIZE="-1">URI</FONT> of the remote libvirtd
daemon, or be <TT>&quot;undef&quot;</TT>. The <TT>&quot;miguri&quot;</TT> parameter can be used to specify
the <FONT SIZE="-1">URI</FONT> for initiating the migration operation, or be <TT>&quot;undef&quot;</TT>.
<DT>$dom-&gt;migrate_set_max_downtime($downtime, $flags)<DD>


<A NAME="ixAFC"></A>
Set the maximum allowed downtime during migration of the guest. A
longer downtime makes it more likely that migration will complete,
at the cost of longer time blackout for the guest <FONT SIZE="-1">OS</FONT> at the switch
over point. The <TT>&quot;downtime&quot;</TT> parameter is measured in milliseconds.
The <TT>$flags</TT> parameter is currently unused and defaults to zero.
<DT>$dom-&gt;migrate_set_max_speed($bandwidth, $flags)<DD>


<A NAME="ixAFD"></A>
Set the maximum allowed bandwidth during migration of the guest.
The <TT>&quot;bandwidth&quot;</TT> parameter is measured in MB/second.
The <TT>$flags</TT> parameter is currently unused and defaults to zero.
<DT>$bandwidth = $dom-&gt;migrate_get_max_speed($flag)<DD>


<A NAME="ixAFE"></A>
Get the maximum allowed bandwidth during migration fo the guest.
The returned &lt;bandwidth&gt; value is measured in MB/second.
The <TT>$flags</TT> parameter is currently unused and defaults to zero.
<DT>$dom-&gt;inject_nmi($flags)<DD>


<A NAME="ixAFF"></A>
Trigger an <FONT SIZE="-1">NMI</FONT> in the guest virtual machine. The <TT>$flags</TT> parameter
is currently unused and defaults to 0.
<DT>$dom-&gt;open_console($st, $devname, $flags)<DD>


<A NAME="ixAFG"></A>
Open the text console for a serial, parallel or paravirt console
device identified by <TT>$devname</TT>, connecting it to the stream
<TT>$st</TT>. If <TT>$devname</TT> is undefined, the default console will be
opened. <TT>$st</TT> must be a <TT>&quot;Sys::Virt::Stream&quot;</TT> object used for
bi-directional communication with the console. <TT>$flags</TT> is
currently unused, defaulting to 0.
<DT>$dom-&gt;open_graphics($idx, $fd, $flags)<DD>


<A NAME="ixAFH"></A>
Open the graphics console for a guest, identified by <TT>$idx</TT>,
counting from 0. The <TT>$fd</TT> should be a file descriptor for an
anoymous socket pair. The <TT>$flags</TT> argument should be one of
the constants listed at the end of this document, and defaults
to 0.
<DT>$dom-&gt;screenshot($st, $screen, $flags)<DD>


<A NAME="ixAFI"></A>
Capture a screenshot of the virtual machine's monitor. The <TT>$screen</TT>
parameter controls which monitor is captured when using a multi-head
or multi-card configuration. <TT>$st</TT> must be a <TT>&quot;Sys::Virt::Stream&quot;</TT>
object from which the data can be read. <TT>$flags</TT> is currently unused
and defaults to 0.
<DT>@vcpuinfo = $dom-&gt;<I>get_vcpu_info()</I><DD>


<A NAME="ixAFJ"></A>
Obtain information about the state of all virtual CPUs in a running
guest domain. The returned list will have one element for each vCPU,
where each elements contains a hash reference. The keys in the hash
are, <TT>&quot;number&quot;</TT> the vCPU number, <TT>&quot;cpu&quot;</TT> the physical <FONT SIZE="-1">CPU</FONT> on which the
vCPU is currently scheduled, <TT>&quot;cpuTime&quot;</TT> the cummulative execution
time of the vCPU, <TT>&quot;state&quot;</TT> the running state and <TT>&quot;affinity&quot;</TT> giving
the allowed shedular placement. The value for <TT>&quot;affinity&quot;</TT> is a
string representing a bitmask against physical CPUs, 8 cpus per
character.
<DT>$dom-&gt;pin_vcpu($vcpu, $mask)<DD>


<A NAME="ixAFK"></A>
Ping the virtual <FONT SIZE="-1">CPU</FONT> given by index <TT>$vcpu</TT> to physical CPUs
given by <TT>$mask</TT>. The <TT>$mask</TT> is a string representing a bitmask
against physical CPUs, 8 cpus per character.
<DT>my @stats = $dom-&gt;get_cpu_stats($startCpu, $numCpus, $flags=0)<DD>


<A NAME="ixAFL"></A>
Requests the guests host physical <FONT SIZE="-1">CPU</FONT> usage statistics, starting
from host <FONT SIZE="-1">CPU</FONT> &lt;$startCpu&gt; counting upto <TT>$numCpus</TT>. If <TT>$startCpu</TT>
is -1 and <TT>$numCpus</TT> is 1, then the utilization across all CPUs
is returned. Returns an array of hash references, each element
containing stats for one <FONT SIZE="-1">CPU</FONT>.
<DT>my $info = $dom-&gt;<I>get_job_info()</I><DD>


<A NAME="ixAFM"></A>
Returns a hash reference summarising the execution state of the
background job. The elements of the hash are as follows:
<DT>$dom-&gt;<I>abort_job()</I><DD>


<A NAME="ixAFN"></A>
Aborts the currently executing job
<DT>my $info = $dom-&gt;get_block_job_info($path, $flags=0)<DD>


<A NAME="ixAFO"></A>
Returns a hash reference summarising the execution state of
the block job. The <TT>$path</TT> parameter should be the fully
qualified path of the block device being changed.
<DT>$dom-&gt;set_block_job_speed($path, $bandwidth, $flags=0)<DD>


<A NAME="ixAFP"></A>
Change the maximum I/O bandwidth used by the block job that
is currently executing for <TT>$path</TT>. The <TT>$bandwidth</TT> argument
is specified in MB/s
<DT>$dom-&gt;abort_block_job($path, $flags=0)<DD>


<A NAME="ixAFQ"></A>
Abort the current job that is executing for the block device
associated with <TT>$path</TT>
<DT>$dom-&gt;block_pull($path, $bandwith, $flags=0)<DD>


<A NAME="ixAFR"></A>
Merge the backing files associated with <TT>$path</TT> into the
top level file. The <TT>$bandwidth</TT> parameter specifies the
maximum I/O rate to allow in MB/s.
<DT>$dom-&gt;block_rebase($path, $backingpath, $bandwith, $flags=0)<DD>


<A NAME="ixAFS"></A>
Switch the backing path associated with <TT>$path</TT> to instead
use <TT>$backingpath</TT>. The <TT>$bandwidth</TT> parameter specifies the
maximum I/O rate to allow in MB/s.
<DT>$count = $dom-&gt;<I>num_of_snapshots()</I><DD>


<A NAME="ixAFT"></A>
Return the number of saved snapshots of the domain
<DT>@names = $dom-&gt;<I>list_snapshot_names()</I><DD>


<A NAME="ixAFU"></A>
List the names of all saved snapshots. The names can be
used with the <TT>&quot;lookup_snapshot_by_name&quot;</TT>
<DT>@snapshots = $dom-&gt;<I>list_snapshots()</I><DD>


<A NAME="ixAFV"></A>
Return a list of all snapshots currently known to the domain. The elements
in the returned list are instances of the Sys::Virt::DomainSnapshot class.
<DT>my $snapshot = $dom-&gt;get_snapshot_by_name($name)<DD>


<A NAME="ixAFW"></A>
Return the domain snapshot with a name of <TT>$name</TT>. The returned object is
an instance of the Sys::Virt::DomainSnapshot class.
<DT>$dom-&gt;<I>has_current_snapshot()</I><DD>


<A NAME="ixAFX"></A>
Returns a true value if the domain has a currently active snapshot
<DT>$snapshot = $dom-&gt;<I>current_snapshot()</I><DD>


<A NAME="ixAFY"></A>
Returns the currently active snapshot for the domain.
<DT>$snapshot = $dom-&gt;create_snapshot($xml[, $flags])<DD>


<A NAME="ixAFZ"></A>
Create a new snapshot from the <TT>$xml</TT>.
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>type<DD>
<A NAME="ixAGA"></A>
The type of job, one of the <FONT SIZE="-1">JOB</FONT> <FONT SIZE="-1">TYPE</FONT> constants listed later in
this document.
<DT>timeElapsed<DD>
<A NAME="ixAGB"></A>
The elapsed time in milliseconds
<DT>timeRemaining<DD>
<A NAME="ixAGC"></A>
The expected remaining time in milliseconds. Only set if the
<TT>&quot;type&quot;</TT> is <FONT SIZE="-1">JOB_UNBOUNDED</FONT>.
<DT>dataTotal<DD>
<A NAME="ixAGD"></A>
The total amount of data expected to be processed by the job, in bytes.
<DT>dataProcessed<DD>
<A NAME="ixAGE"></A>
The current amount of data processed by the job, in bytes.
<DT>dataRemaining<DD>
<A NAME="ixAGF"></A>
The expected amount of data remaining to be processed by the job, in bytes.
<DT>memTotal<DD>
<A NAME="ixAGG"></A>
The total amount of mem expected to be processed by the job, in bytes.
<DT>memProcessed<DD>
<A NAME="ixAGH"></A>
The current amount of mem processed by the job, in bytes.
<DT>memRemaining<DD>
<A NAME="ixAGI"></A>
The expected amount of mem remaining to be processed by the job, in bytes.
<DT>fileTotal<DD>
<A NAME="ixAGJ"></A>
The total amount of file expected to be processed by the job, in bytes.
<DT>fileProcessed<DD>
<A NAME="ixAGK"></A>
The current amount of file processed by the job, in bytes.
<DT>fileRemaining<DD>
<A NAME="ixAGL"></A>
The expected amount of file remaining to be processed by the job, in bytes.
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

</DL>
<A NAME="lbAE">&nbsp;</A>
<H2>CONSTANTS</H2>

<A NAME="ixAGM"></A>
A number of the APIs take a <TT>&quot;flags&quot;</TT> parameter. In most cases
passing a value of zero will be satisfactory. Some APIs, however,
accept named constants to alter their behaviour. This section
documents the current known constants.
<A NAME="lbAF">&nbsp;</A>
<H3><FONT SIZE="-1">DOMAIN</FONT> <FONT SIZE="-1">STATE</FONT></H3>

<A NAME="ixAGN"></A>
The domain state constants are useful in interpreting the
<TT>&quot;state&quot;</TT> key in the hash returned by the <TT>&quot;get_info&quot;</TT> method.
<DL COMPACT>
<DT>Sys::Virt::Domain::STATE_NOSTATE<DD>
<A NAME="ixAGO"></A>
The domain is active, but is not running / blocked (eg idle)
<DT>Sys::Virt::Domain::STATE_RUNNING<DD>
<A NAME="ixAGP"></A>
The domain is active and running
<DT>Sys::Virt::Domain::STATE_BLOCKED<DD>
<A NAME="ixAGQ"></A>
The domain is active, but execution is blocked
<DT>Sys::Virt::Domain::STATE_PAUSED<DD>
<A NAME="ixAGR"></A>
The domain is active, but execution has been paused
<DT>Sys::Virt::Domain::STATE_SHUTDOWN<DD>
<A NAME="ixAGS"></A>
The domain is active, but in the shutdown phase
<DT>Sys::Virt::Domain::STATE_SHUTOFF<DD>
<A NAME="ixAGT"></A>
The domain is inactive, and shut down.
<DT>Sys::Virt::Domain::STATE_CRASHED<DD>
<A NAME="ixAGU"></A>
The domain is inactive, and crashed.
</DL>
<A NAME="lbAG">&nbsp;</A>
<H3><FONT SIZE="-1">CONTROL</FONT> <FONT SIZE="-1">INFO</FONT></H3>

<A NAME="ixAGV"></A>
The following constants can be used to determine what the
guest domain control channel status is
<DL COMPACT>
<DT>Sys::Virt::Domain::CONTROL_ERROR<DD>
<A NAME="ixAGW"></A>
The control channel has a fatal error
<DT>Sys::Virt::Domain::CONTROL_OK<DD>
<A NAME="ixAGX"></A>
The control channel is ready for jobs
<DT>Sys::Virt::Domain::CONTROL_OCCUPIED<DD>
<A NAME="ixAGY"></A>
The control channel is busy
<DT>Sys::Virt::Domain::CONTROL_JOB<DD>
<A NAME="ixAGZ"></A>
The control channel is busy with a job
</DL>
<A NAME="lbAH">&nbsp;</A>
<H3><FONT SIZE="-1">DOMAIN</FONT> <FONT SIZE="-1">CREATION</FONT></H3>

<A NAME="ixAHA"></A>
The following constants can be used to control the behaviour
of domain creation
<DL COMPACT>
<DT>Sys::Virt::Domain::START_PAUSED<DD>
<A NAME="ixAHB"></A>
Keep the guest vCPUs paused after starting the guest
<DT>Sys::Virt::Domain::START_AUTODESTROY<DD>
<A NAME="ixAHC"></A>
Automatically destroy the guest when the connection is closed (or fails)
<DT>Sys::Virt::Domain::START_BYPASS_CACHE<DD>
<A NAME="ixAHD"></A>
Do not use <FONT SIZE="-1">OS</FONT> I/O cache if starting a domain with a saved state image
<DT>Sys::Virt::Domain::START_FORCE_BOOT<DD>
<A NAME="ixAHE"></A>
Boot the guest, even if there was a saved snapshot
</DL>
<A NAME="lbAI">&nbsp;</A>
<H3><FONT SIZE="-1">KEYCODE</FONT> <FONT SIZE="-1">SETS</FONT></H3>

<A NAME="ixAHF"></A>
The following constants define the set of supported keycode
sets
<DL COMPACT>
<DT>Sys::Virt::Domain::KEYCODE_SET_LINUX<DD>
<A NAME="ixAHG"></A>
The Linux event subsystem keycodes
<DT>Sys::Virt::Domain::KEYCODE_SET_XT<DD>
<A NAME="ixAHH"></A>
The original <FONT SIZE="-1">XT</FONT> keycodes
<DT>Sys::Virt::Domain::KEYCODE_SET_ATSET1<DD>
<A NAME="ixAHI"></A>
The <FONT SIZE="-1">AT</FONT> Set1 keycodes (aka <FONT SIZE="-1">XT</FONT>)
<DT>Sys::Virt::Domain::KEYCODE_SET_ATSET2<DD>
<A NAME="ixAHJ"></A>
The <FONT SIZE="-1">AT</FONT> Set2 keycodes (aka <FONT SIZE="-1">AT</FONT>)
<DT>Sys::Virt::Domain::KEYCODE_SET_ATSET3<DD>
<A NAME="ixAHK"></A>
The <FONT SIZE="-1">AT</FONT> Set3 keycodes (aka <FONT SIZE="-1">PS2</FONT>)
<DT>Sys::Virt::Domain::KEYCODE_SET_OSX<DD>
<A NAME="ixAHL"></A>
The OS-X keycodes
<DT>Sys::Virt::Domain::KEYCODE_SET_XT_KBD<DD>
<A NAME="ixAHM"></A>
The <FONT SIZE="-1">XT</FONT> keycodes from the Linux Keyboard driver
<DT>Sys::Virt::Domain::KEYCODE_SET_USB<DD>
<A NAME="ixAHN"></A>
The <FONT SIZE="-1">USB</FONT> <FONT SIZE="-1">HID</FONT> keycode set
<DT>Sys::Virt::Domain::KEYCODE_SET_WIN32<DD>
<A NAME="ixAHO"></A>
The Windows keycode set
<DT>Sys::Virt::Domain::KEYCODE_SET_RFB<DD>
<A NAME="ixAHP"></A>
The <FONT SIZE="-1">XT</FONT> keycode set, with the extended scancodes using the
high bit of the first byte, instead of the low bit of the
second byte.
</DL>
<A NAME="lbAJ">&nbsp;</A>
<H3><FONT SIZE="-1">MEMORY</FONT> <FONT SIZE="-1">PEEK</FONT></H3>

<A NAME="ixAHQ"></A>
The following constants can be used with the <TT>&quot;memory_peek&quot;</TT>
method's flags parameter
<DL COMPACT>
<DT>Sys::Virt::Domain::MEMORY_VIRTUAL<DD>
<A NAME="ixAHR"></A>
Indicates that the offset is using virtual memory addressing.
<DT>Sys::Virt::Domain::MEMORY_PHYSICAL<DD>
<A NAME="ixAHS"></A>
Indicates that the offset is using physical memory addressing.
</DL>
<A NAME="lbAK">&nbsp;</A>
<H3><FONT SIZE="-1">VCPU</FONT> <FONT SIZE="-1">STATE</FONT></H3>

<A NAME="ixAHT"></A>
The following constants are useful when interpreting the
virtual <FONT SIZE="-1">CPU</FONT> run state
<DL COMPACT>
<DT>Sys::Virt::Domain::VCPU_OFFLINE<DD>
<A NAME="ixAHU"></A>
The virtual <FONT SIZE="-1">CPU</FONT> is not online
<DT>Sys::Virt::Domain::VCPU_RUNNING<DD>
<A NAME="ixAHV"></A>
The virtual <FONT SIZE="-1">CPU</FONT> is executing code
<DT>Sys::Virt::Domain::VCPU_BLOCKED<DD>
<A NAME="ixAHW"></A>
The virtual <FONT SIZE="-1">CPU</FONT> is waiting to be scheduled
</DL>
<A NAME="lbAL">&nbsp;</A>
<H3><FONT SIZE="-1">OPEN</FONT> <FONT SIZE="-1">GRAPHICS</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixAHX"></A>
The following constants are used when opening a connection
to the guest graphics server
<DL COMPACT>
<DT>Sys::Virt::Domain::OPEN_GRAPHICS_SKIPAUTH<DD>
<A NAME="ixAHY"></A>
Skip authentication of the client
</DL>
<A NAME="lbAM">&nbsp;</A>
<H3><FONT SIZE="-1">XML</FONT> <FONT SIZE="-1">DUMP</FONT> <FONT SIZE="-1">OPTIONS</FONT></H3>

<A NAME="ixAHZ"></A>
The following constants are used to control the information
included in the <FONT SIZE="-1">XML</FONT> configuration dump
<DL COMPACT>
<DT>Sys::Virt::Domain::XML_INACTIVE<DD>
<A NAME="ixAIA"></A>
Report the persistent inactive configuration for the guest, even
if it is currently running.
<DT>Sys::Virt::Domain::XML_SECURE<DD>
<A NAME="ixAIB"></A>
Include security sensitive information in the <FONT SIZE="-1">XML</FONT> dump, such as
passwords.
<DT>Sys::Virt::Domain::XML_UPDATE_CPU<DD>
<A NAME="ixAIC"></A>
Update the <FONT SIZE="-1">CPU</FONT> model definition to match the current executing
state.
</DL>
<A NAME="lbAN">&nbsp;</A>
<H3><FONT SIZE="-1">DEVICE</FONT> <FONT SIZE="-1">HOTPLUG</FONT> <FONT SIZE="-1">OPTIONS</FONT></H3>

<A NAME="ixAID"></A>
The following constants are used to control device hotplug
operations
<DL COMPACT>
<DT>Sys::Virt::Domain::DEVICE_MODIFY_CURRENT<DD>
<A NAME="ixAIE"></A>
Modify the domain in its current state
<DT>Sys::Virt::Domain::DEVICE_MODIFY_LIVE<DD>
<A NAME="ixAIF"></A>
Modify only the live state of the domain
<DT>Sys::Virt::Domain::DEVICE_MODIFY_CONFIG<DD>
<A NAME="ixAIG"></A>
Modify only the persistent config of the domain
<DT>Sys::Virt::Domain::DEVICE_MODIFY_FORCE<DD>
<A NAME="ixAIH"></A>
Force the device to be modified
</DL>
<A NAME="lbAO">&nbsp;</A>
<H3><FONT SIZE="-1">MEMORY</FONT> <FONT SIZE="-1">OPTIONS</FONT></H3>

<A NAME="ixAII"></A>
The following constants are used to control memory change
operations
<DL COMPACT>
<DT>Sys::Virt::Domain::MEM_CURRENT<DD>
<A NAME="ixAIJ"></A>
Modify the current state
<DT>Sys::Virt::Domain::MEM_LIVE<DD>
<A NAME="ixAIK"></A>
Modify only the live state of the domain
<DT>Sys::Virt::Domain::MEM_CONFIG<DD>
<A NAME="ixAIL"></A>
Modify only the persistent config of the domain
<DT>Sys::Virt::Domain::MEM_MAXIMUM<DD>
<A NAME="ixAIM"></A>
Modify the maximum memory value
</DL>
<A NAME="lbAP">&nbsp;</A>
<H3><FONT SIZE="-1">CONFIG</FONT> <FONT SIZE="-1">OPTIONS</FONT></H3>

<A NAME="ixAIN"></A>
The following constants are used to control what configuration
a domain update changes
<DL COMPACT>
<DT>Sys::Virt::Domain::AFFECT_CURRENT<DD>
<A NAME="ixAIO"></A>
Modify the current state
<DT>Sys::Virt::Domain::AFFECT_LIVE<DD>
<A NAME="ixAIP"></A>
Modify only the live state of the domain
<DT>Sys::Virt::Domain::AFFECT_CONFIG<DD>
<A NAME="ixAIQ"></A>
Modify only the persistent config of the domain
</DL>
<A NAME="lbAQ">&nbsp;</A>
<H3><FONT SIZE="-1">MIGRATE</FONT> <FONT SIZE="-1">OPTIONS</FONT></H3>

<A NAME="ixAIR"></A>
The following constants are used to control how migration
is performed
<DL COMPACT>
<DT>Sys::Virt::Domain::MIGRATE_LIVE<DD>
<A NAME="ixAIS"></A>
Migrate the guest without interrupting its execution on the source
host.
<DT>Sys::Virt::Domain::MIGRATE_PEER2PEER<DD>
<A NAME="ixAIT"></A>
Manage the migration process over a direct peer-2-peer connection between
the source and destination host libvirtd daemons.
<DT>Sys::Virt::Domain::MIGRATE_TUNNELLED<DD>
<A NAME="ixAIU"></A>
Tunnel the migration data over the libvirt daemon connection, rather
than the native hypervisor data transport. Requires <FONT SIZE="-1">PEER2PEER</FONT> flag to
be set.
<DT>Sys::Virt::Domain::MIGRATE_PERSIST_DEST<DD>
<A NAME="ixAIV"></A>
Make the domain persistent on the destination host, defining its
configuration file upon completion of migration.
<DT>Sys::Virt::Domain::MIGRATE_UNDEFINE_SOURCE<DD>
<A NAME="ixAIW"></A>
Remove the domain's persistent configuration after migration
completes successfully.
<DT>Sys::Virt::Domain::MIGRATE_PAUSED<DD>
<A NAME="ixAIX"></A>
Do not re-start execution of the guest CPUs on the destination
host after migration completes.
<DT>Sys::Virt::Domain::MIGRATE_NON_SHARED_DISK<DD>
<A NAME="ixAIY"></A>
Copy the complete contents of the disk images during migration
<DT>Sys::Virt::Domain::MIGRATE_NON_SHARED_INC<DD>
<A NAME="ixAIZ"></A>
Copy the incrementally changed contents of the disk images
during migration
<DT>Sys::Virt::Domain::MIGRATE_CHANGE_PROTECTION<DD>
<A NAME="ixAJA"></A>
Do not allow changes to the virtual domain configuration while
migration is taking place. This option is automatically implied
if doing a peer-2-peer migration.
</DL>
<A NAME="lbAR">&nbsp;</A>
<H3><FONT SIZE="-1">UNDEFINE</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixAJB"></A>
The following constants can be used when undefining virtual
domain configurations
<DL COMPACT>
<DT>Sys::Virt::Domain::UNDEFINE_MANAGED_SAVE<DD>
<A NAME="ixAJC"></A>
Also remove any managed save image when undefining the virtual
domain
<DT>Sys::Virt::Domain::UNDEFINE_SNAPSHOTS_METADATA<DD>
<A NAME="ixAJD"></A>
Also remove any snapshot metadata when undefining the virtual
domain.
</DL>
<A NAME="lbAS">&nbsp;</A>
<H3><FONT SIZE="-1">JOB</FONT> <FONT SIZE="-1">TYPES</FONT></H3>

<A NAME="ixAJE"></A>
The following constants describe the different background job
types.
<DL COMPACT>
<DT>Sys::Virt::Domain::JOB_NONE<DD>
<A NAME="ixAJF"></A>
No job is active
<DT>Sys::Virt::Domain::JOB_BOUNDED<DD>
<A NAME="ixAJG"></A>
A job with a finite completion time is active
<DT>Sys::Virt::Domain::JOB_UNBOUNDED<DD>
<A NAME="ixAJH"></A>
A job with an unbounded completion time is active
<DT>Sys::Virt::Domain::JOB_COMPLETED<DD>
<A NAME="ixAJI"></A>
The job has finished, but isn't cleaned up
<DT>Sys::Virt::Domain::JOB_FAILED<DD>
<A NAME="ixAJJ"></A>
The job has hit an error, but isn't cleaned up
<DT>Sys::Virt::Domain::JOB_CANCELLED<DD>
<A NAME="ixAJK"></A>
The job was aborted at user request, but isn't cleaned up
</DL>
<A NAME="lbAT">&nbsp;</A>
<H3><FONT SIZE="-1">MEMORY</FONT> <FONT SIZE="-1">PARAMETERS</FONT></H3>

<A NAME="ixAJL"></A>
The following constants are useful when getting/setting
memory parameters for guests
<DL COMPACT>
<DT>Sys::Virt::Domain::MEMORY_HARD_LIMIT<DD>
<A NAME="ixAJM"></A>
The maximum memory the guest can use.
<DT>Sys::Virt::Domain::MEMORY_SOFT_LIMIT<DD>
<A NAME="ixAJN"></A>
The memory upper limit enforced during memory contention.
<DT>Sys::Virt::Domain::MEMORY_MIN_GUARANTEE<DD>
<A NAME="ixAJO"></A>
The minimum memory guaranteed to be reserved for the guest.
<DT>Sys::Virt::Domain::MEMORY_SWAP_HARD_LIMIT<DD>
<A NAME="ixAJP"></A>
The maximum swap the guest can use.
<DT>Sys::Virt::Domain::MEMORY_PARAM_UNLIMITED<DD>
<A NAME="ixAJQ"></A>
The value of an unlimited memory parameter
</DL>
<A NAME="lbAU">&nbsp;</A>
<H3><FONT SIZE="-1">BLKIO</FONT> <FONT SIZE="-1">PARAMETERS</FONT></H3>

<A NAME="ixAJR"></A>
The following parameters control I/O tuning for the domain
as a whole
<DL COMPACT>
<DT>Sys::Virt::Domain::BLKIO_WEIGHT<DD>
<A NAME="ixAJS"></A>
The I/O weight parameter
<DT>Sys::Virt::Domain::BLKIO_DEVICE_WEIGHT<DD>
<A NAME="ixAJT"></A>
The per-device I/O weight parameter
</DL>
<A NAME="lbAV">&nbsp;</A>
<H3><FONT SIZE="-1">BLKIO</FONT> <FONT SIZE="-1">TUNING</FONT> <FONT SIZE="-1">PARAMETERS</FONT></H3>

<A NAME="ixAJU"></A>
The following parameters control I/O tuning for an individual
guest disk.
<DL COMPACT>
<DT>Sys::Virt::Domain::BLOCK_IOTUNE_TOTAL_BYTES_SEC<DD>
<A NAME="ixAJV"></A>
The total bytes processed per second.
<DT>Sys::Virt::Domain::BLOCK_IOTUNE_READ_BYTES_SEC<DD>
<A NAME="ixAJW"></A>
The bytes read per second.
<DT>Sys::Virt::Domain::BLOCK_IOTUNE_WRITE_BYTES_SEC<DD>
<A NAME="ixAJX"></A>
The bytes written per second.
<DT>Sys::Virt::Domain::BLOCK_IOTUNE_TOTAL_IOPS_SEC<DD>
<A NAME="ixAJY"></A>
The total I/O operations processed per second.
<DT>Sys::Virt::Domain::BLOCK_IOTUNE_READ_IOPS_SEC<DD>
<A NAME="ixAJZ"></A>
The I/O operations read per second.
<DT>Sys::Virt::Domain::BLOCK_IOTUNE_WRITE_IOPS_SEC<DD>
<A NAME="ixAKA"></A>
The I/O operations written per second.
</DL>
<A NAME="lbAW">&nbsp;</A>
<H3><FONT SIZE="-1">SCHEDULER</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixAKB"></A>
<DL COMPACT>
<DT>Sys::Virt::Domain::SCHEDULER_CAP<DD>
<A NAME="ixAKC"></A>
The <FONT SIZE="-1">VM</FONT> cap tunable
<DT>Sys::Virt::Domain::SCHEDULER_CPU_SHARES<DD>
<A NAME="ixAKD"></A>
The <FONT SIZE="-1">CPU</FONT> shares tunable
<DT>Sys::Virt::Domain::SCHEDULER_LIMIT<DD>
<A NAME="ixAKE"></A>
The <FONT SIZE="-1">VM</FONT> limit tunable
<DT>Sys::Virt::Domain::SCHEDULER_RESERVATION<DD>
<A NAME="ixAKF"></A>
The <FONT SIZE="-1">VM</FONT> reservation tunable
<DT>Sys::Virt::Domain::SCHEDULER_SHARES<DD>
<A NAME="ixAKG"></A>
The <FONT SIZE="-1">VM</FONT> shares tunable
<DT>Sys::Virt::Domain::SCHEDULER_VCPU_PERIOD<DD>
<A NAME="ixAKH"></A>
The <FONT SIZE="-1">VCPU</FONT> period tunable
<DT>Sys::Virt::Domain::SCHEDULER_VCPU_QUOTA<DD>
<A NAME="ixAKI"></A>
The <FONT SIZE="-1">VCPU</FONT> quota tunable
<DT>Sys::Virt::Domain::SCHEDULER_WEIGHT<DD>
<A NAME="ixAKJ"></A>
The <FONT SIZE="-1">VM</FONT> weight tunable
</DL>
<A NAME="lbAX">&nbsp;</A>
<H3><FONT SIZE="-1">NUMA</FONT> <FONT SIZE="-1">PARAMETERS</FONT></H3>

<A NAME="ixAKK"></A>
The following constants are useful when getting/setting the
guest <FONT SIZE="-1">NUMA</FONT> memory policy
<DL COMPACT>
<DT>Sys::Virt::Domain::NUMA_MODE<DD>
<A NAME="ixAKL"></A>
The <FONT SIZE="-1">NUMA</FONT> policy mode
<DT>Sys::Virt::Domain::NUMA_NODESET<DD>
<A NAME="ixAKM"></A>
The <FONT SIZE="-1">NUMA</FONT> nodeset mask
</DL>
<P>

The following constants are useful when interpreting the
<TT>&quot;Sys::Virt::Domain::NUMA_MODE&quot;</TT> parameter value
<DL COMPACT>
<DT>Sys::Virt::Domain::NUMATUNE_MEM_STRICT<DD>
<A NAME="ixAKN"></A>
Allocation is mandatory from the mask nodes
<DT>Sys::Virt::Domain::NUMATUNE_MEM_PREFERRED<DD>
<A NAME="ixAKO"></A>
Allocation is preferred from the masked nodes
<DT>Sys::Virt::Domain::NUMATUNE_MEM_INTERLEAVE<DD>
<A NAME="ixAKP"></A>
Allocation is interleaved across all masked nods
</DL>
<A NAME="lbAY">&nbsp;</A>
<H3><FONT SIZE="-1">INTERFACE</FONT> <FONT SIZE="-1">PARAMETERS</FONT></H3>

<A NAME="ixAKQ"></A>
The following constants are useful when getting/setting the
per network interface tunable parameters
<DL COMPACT>
<DT>Sys::Virt::Domain::BANDWIDTH_IN_AVERAGE<DD>
<A NAME="ixAKR"></A>
The average inbound bandwidth
<DT>Sys::Virt::Domain::BANDWIDTH_IN_PEAK<DD>
<A NAME="ixAKS"></A>
The peak inbound bandwidth
<DT>Sys::Virt::Domain::BANDWIDTH_IN_BURST<DD>
<A NAME="ixAKT"></A>
The burstable inbound bandwidth
<DT>Sys::Virt::Domain::BANDWIDTH_OUT_AVERAGE<DD>
<A NAME="ixAKU"></A>
The average outbound bandwidth
<DT>Sys::Virt::Domain::BANDWIDTH_OUT_PEAK<DD>
<A NAME="ixAKV"></A>
The peak outbound bandwidth
<DT>Sys::Virt::Domain::BANDWIDTH_OUT_BURST<DD>
<A NAME="ixAKW"></A>
The burstable outbound bandwidth
</DL>
<A NAME="lbAZ">&nbsp;</A>
<H3><FONT SIZE="-1">VCPU</FONT> <FONT SIZE="-1">FLAGS</FONT></H3>

<A NAME="ixAKX"></A>
The following constants are useful when getting/setting the
<FONT SIZE="-1">VCPU</FONT> count for a guest
<DL COMPACT>
<DT>Sys::Virt::Domain::VCPU_LIVE<DD>
<A NAME="ixAKY"></A>
Flag to request the live value
<DT>Sys::Virt::Domain::VCPU_CONFIG<DD>
<A NAME="ixAKZ"></A>
Flag to request the persistent config value
<DT>Sys::Virt::Domain::VCPU_CURRENT<DD>
<A NAME="ixALA"></A>
Flag to request the current config value
<DT>Sys::Virt::Domain::VCPU_MAXIMUM<DD>
<A NAME="ixALB"></A>
Flag to request adjustment of the maximum vCPU value
</DL>
<A NAME="lbBA">&nbsp;</A>
<H3><FONT SIZE="-1">STATE</FONT> <FONT SIZE="-1">CHANGE</FONT> <FONT SIZE="-1">EVENTS</FONT></H3>

<A NAME="ixALC"></A>
The following constants allow domain state change events to be
interpreted. The events contain both a state change, and a
reason.
<DL COMPACT>
<DT>Sys::Virt::Domain::EVENT_DEFINED<DD>
<A NAME="ixALD"></A>
Indicates that a persistent configuration has been defined for
the domain.
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>Sys::Virt::Domain::EVENT_DEFINED_ADDED<DD>
<A NAME="ixALE"></A>
The defined configuration is newly added
<DT>Sys::Virt::Domain::EVENT_DEFINED_UPDATED<DD>
<A NAME="ixALF"></A>
The defined configuration is an update to an existing configuration
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>Sys::Virt::Domain::EVENT_RESUMED<DD>
<A NAME="ixALG"></A>
The domain has resumed execution
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>Sys::Virt::Domain::EVENT_RESUMED_MIGRATED<DD>
<A NAME="ixALH"></A>
The domain resumed because migration has completed. This is
emitted on the destination host.
<DT>Sys::Virt::Domain::EVENT_RESUMED_UNPAUSED<DD>
<A NAME="ixALI"></A>
The domain resumed because the admin unpaused it.
<DT>Sys::Virt::Domain::EVENT_RESUMED_FROM_SNAPSHOT<DD>
<A NAME="ixALJ"></A>
The domain resumed because it was restored from a snapshot
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>Sys::Virt::Domain::EVENT_STARTED<DD>
<A NAME="ixALK"></A>
The domain has started running
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>Sys::Virt::Domain::EVENT_STARTED_BOOTED<DD>
<A NAME="ixALL"></A>
The domain was booted from shutoff state
<DT>Sys::Virt::Domain::EVENT_STARTED_MIGRATED<DD>
<A NAME="ixALM"></A>
The domain started due to an incoming migration
<DT>Sys::Virt::Domain::EVENT_STARTED_RESTORED<DD>
<A NAME="ixALN"></A>
The domain was restored from saved state file
<DT>Sys::Virt::Domain::EVENT_STARTED_FROM_SNAPSHOT<DD>
<A NAME="ixALO"></A>
The domain was restored from a snapshot
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>Sys::Virt::Domain::EVENT_STOPPED<DD>
<A NAME="ixALP"></A>
The domain has stopped running
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>Sys::Virt::Domain::EVENT_STOPPED_CRASHED<DD>
<A NAME="ixALQ"></A>
The domain stopped because guest operating system has crashed
<DT>Sys::Virt::Domain::EVENT_STOPPED_DESTROYED<DD>
<A NAME="ixALR"></A>
The domain stopped because administrator issued a destroy
command.
<DT>Sys::Virt::Domain::EVENT_STOPPED_FAILED<DD>
<A NAME="ixALS"></A>
The domain stopped because of a fault in the host virtualization
environment.
<DT>Sys::Virt::Domain::EVENT_STOPPED_MIGRATED<DD>
<A NAME="ixALT"></A>
The domain stopped because it was migrated to another machine.
<DT>Sys::Virt::Domain::EVENT_STOPPED_SAVED<DD>
<A NAME="ixALU"></A>
The domain was saved to a state file
<DT>Sys::Virt::Domain::EVENT_STOPPED_SHUTDOWN<DD>
<A NAME="ixALV"></A>
The domain stopped due to graceful shutdown of the guest.
<DT>Sys::Virt::Domain::EVENT_STOPPED_FROM_SNAPSHOT<DD>
<A NAME="ixALW"></A>
The domain was stopped due to a snapshot
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>Sys::Virt::Domain::EVENT_SHUTDOWN<DD>
<A NAME="ixALX"></A>
The domain has shutdown but is not yet stopped
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>Sys::Virt::Domain::EVENT_SHUTDOWN_FINISHED<DD>
<A NAME="ixALY"></A>
The domain finished shutting down
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>Sys::Virt::Domain::EVENT_SUSPENDED<DD>
<A NAME="ixALZ"></A>
The domain has stopped executing, but still exists
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>Sys::Virt::Domain::EVENT_SUSPENDED_MIGRATED<DD>
<A NAME="ixAMA"></A>
The domain has been suspended due to offline migration
<DT>Sys::Virt::Domain::EVENT_SUSPENDED_PAUSED<DD>
<A NAME="ixAMB"></A>
The domain has been suspended due to administrator pause
request.
<DT>Sys::Virt::Domain::EVENT_SUSPENDED_IOERROR<DD>
<A NAME="ixAMC"></A>
The domain has been suspended due to a block device I/O
error.
<DT>Sys::Virt::Domain::EVENT_SUSPENDED_FROM_SNAPSHOT<DD>
<A NAME="ixAMD"></A>
The domain has been suspended due to resume from snapshot
<DT>Sys::Virt::Domain::EVENT_SUSPENDED_WATCHDOG<DD>
<A NAME="ixAME"></A>
The domain has been suspended due to the watchdog triggering
<DT>Sys::Virt::Domain::EVENT_SUSPENDED_RESTORED<DD>
<A NAME="ixAMF"></A>
The domain has been suspended due to restore from saved state
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT>Sys::Virt::Domain::EVENT_UNDEFINED<DD>
<A NAME="ixAMG"></A>
The persistent configuration has gone away
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>Sys::Virt::Domain::EVENT_UNDEFINED_REMOVED<DD>
<A NAME="ixAMH"></A>
The domain configuration has gone away due to it being
removed by administrator.
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

</DL>
<A NAME="lbBB">&nbsp;</A>
<H3><FONT SIZE="-1">EVENT</FONT> <FONT SIZE="-1">ID</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixAMI"></A>
<DL COMPACT>
<DT>Sys::Virt::Domain::EVENT_ID_LIFECYCLE<DD>
<A NAME="ixAMJ"></A>
Domain lifecycle events
<DT>Sys::Virt::Domain::EVENT_ID_REBOOT<DD>
<A NAME="ixAMK"></A>
Soft / warm reboot events
<DT>Sys::Virt::Domain::EVENT_ID_RTC_CHANGE<DD>
<A NAME="ixAML"></A>
<FONT SIZE="-1">RTC</FONT> clock adjustments
<DT>Sys::Virt::Domain::EVENT_ID_IO_ERROR<DD>
<A NAME="ixAMM"></A>
File <FONT SIZE="-1">IO</FONT> errors, typically from disks
<DT>Sys::Virt::Domain::EVENT_ID_WATCHDOG<DD>
<A NAME="ixAMN"></A>
Watchdog device triggering
<DT>Sys::Virt::Domain::EVENT_ID_GRAPHICS<DD>
<A NAME="ixAMO"></A>
Graphics client connections.
<DT>Sys::Virt::Domain::EVENT_ID_IO_ERROR_REASON<DD>
<A NAME="ixAMP"></A>
File <FONT SIZE="-1">IO</FONT> errors, typically from disks, with a root cause
<DT>Sys::Virt::Domain::EVENT_ID_CONTROL_ERROR<DD>
<A NAME="ixAMQ"></A>
Errors from the virtualization control channel
<DT>Sys::Virt::Domain::EVENT_ID_BLOCK_JOB<DD>
<A NAME="ixAMR"></A>
Completion status of asynchronous block jobs
<DT>Sys::Virt::Domain::EVENT_ID_DISK_CHANGE<DD>
<A NAME="ixAMS"></A>
Changes in disk media
</DL>
<A NAME="lbBC">&nbsp;</A>
<H3><FONT SIZE="-1">IO</FONT> <FONT SIZE="-1">ERROR</FONT> <FONT SIZE="-1">EVENT</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixAMT"></A>
These constants describe what action was taken due to the
<FONT SIZE="-1">IO</FONT> error.
<DL COMPACT>
<DT>Sys::Virt::Domain::EVENT_IO_ERROR_NONE<DD>
<A NAME="ixAMU"></A>
No action was taken, the error was ignored &amp; reported as success to guest
<DT>Sys::Virt::Domain::EVENT_IO_ERROR_PAUSE<DD>
<A NAME="ixAMV"></A>
The guest is paused since the error occurred
<DT>Sys::Virt::Domain::EVENT_IO_ERROR_REPORT<DD>
<A NAME="ixAMW"></A>
The error has been reported to the guest <FONT SIZE="-1">OS</FONT>
</DL>
<A NAME="lbBD">&nbsp;</A>
<H3><FONT SIZE="-1">WATCHDOG</FONT> <FONT SIZE="-1">EVENT</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixAMX"></A>
These constants describe what action was taken due to the
watchdog firing
<DL COMPACT>
<DT>Sys::Virt::Domain::EVENT_WATCHDOG_NONE<DD>
<A NAME="ixAMY"></A>
No action was taken, the watchdog was ignored
<DT>Sys::Virt::Domain::EVENT_WATCHDOG_PAUSE<DD>
<A NAME="ixAMZ"></A>
The guest is paused since the watchdog fired
<DT>Sys::Virt::Domain::EVENT_WATCHDOG_POWEROFF<DD>
<A NAME="ixANA"></A>
The guest is powered off after the watchdog fired
<DT>Sys::Virt::Domain::EVENT_WATCHDOG_RESET<DD>
<A NAME="ixANB"></A>
The guest is reset after the watchdog fired
<DT>Sys::Virt::Domain::EVENT_WATCHDOG_SHUTDOWN<DD>
<A NAME="ixANC"></A>
The guest attempted to gracefully shutdown after the watchdog fired
<DT>Sys::Virt::Domain::EVENT_WATCHDOG_DEBUG<DD>
<A NAME="ixAND"></A>
No action was taken, the watchdog was logged
</DL>
<A NAME="lbBE">&nbsp;</A>
<H3><FONT SIZE="-1">GRAPHICS</FONT> <FONT SIZE="-1">EVENT</FONT> <FONT SIZE="-1">PHASE</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixANE"></A>
These constants describe the phase of the graphics connection
<DL COMPACT>
<DT>Sys::Virt::Domain::EVENT_GRAPHICS_CONNECT<DD>
<A NAME="ixANF"></A>
The initial client connection
<DT>Sys::Virt::Domain::EVENT_GRAPHICS_INITIALIZE<DD>
<A NAME="ixANG"></A>
The client has been authenticated &amp; the connection is running
<DT>Sys::Virt::Domain::EVENT_GRAPHICS_DISCONNECT<DD>
<A NAME="ixANH"></A>
The client has disconnected
</DL>
<A NAME="lbBF">&nbsp;</A>
<H3><FONT SIZE="-1">GRAPHICS</FONT> <FONT SIZE="-1">EVENT</FONT> <FONT SIZE="-1">ADDRESS</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixANI"></A>
These constants describe the format of the address
<DL COMPACT>
<DT>Sys::Virt::Domain::EVENT_GRAPHICS_ADDRESS_IPV4<DD>
<A NAME="ixANJ"></A>
An IPv4 address
<DT>Sys::Virt::Domain::EVENT_GRAPHICS_ADDRESS_IPV6<DD>
<A NAME="ixANK"></A>
An IPv6 address
<DT>Sys::Virt::Domain::EVENT_GRAPHICS_ADDRESS_UNIX<DD>
<A NAME="ixANL"></A>
An <FONT SIZE="-1">UNIX</FONT> socket path address
</DL>
<A NAME="lbBG">&nbsp;</A>
<H3><FONT SIZE="-1">DISK</FONT> <FONT SIZE="-1">CHANGE</FONT> <FONT SIZE="-1">EVENT</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixANM"></A>
These constants describe the reason for a disk change event
<DL COMPACT>
<DT>Sys::Virt::Domain::EVENT_DISK_CHANGE_MISSING_ON_START<DD>
<A NAME="ixANN"></A>
The disk media was missing when attempting to start the guest
</DL>
<A NAME="lbBH">&nbsp;</A>
<H3><FONT SIZE="-1">DOMAIN</FONT> <FONT SIZE="-1">BLOCK</FONT> <FONT SIZE="-1">JOB</FONT> <FONT SIZE="-1">TYPE</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixANO"></A>
The following constants identify the different types of domain
block jobs
<DL COMPACT>
<DT>Sys::Virt::Domain::BLOCK_JOB_TYPE_UNKNOWN<DD>
<A NAME="ixANP"></A>
An unknown block job type
<DT>Sys::Virt::Domain::BLOCK_JOB_TYPE_PULL<DD>
<A NAME="ixANQ"></A>
The block pull job type
</DL>
<A NAME="lbBI">&nbsp;</A>
<H3><FONT SIZE="-1">DOMAIN</FONT> <FONT SIZE="-1">BLOCK</FONT> <FONT SIZE="-1">JOB</FONT> <FONT SIZE="-1">COMPLETION</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixANR"></A>
The following constants can be used to determine the completion
status of a block job
<DL COMPACT>
<DT>Sys::Virt::Domain::BLOCK_JOB_COMPLETED<DD>
<A NAME="ixANS"></A>
A successfully completed block job
<DT>Sys::Virt::Domain::BLOCK_JOB_FAILED<DD>
<A NAME="ixANT"></A>
An unsuccessful block job
</DL>
<A NAME="lbBJ">&nbsp;</A>
<H3><FONT SIZE="-1">DOMAIN</FONT> <FONT SIZE="-1">SAVE</FONT> / <FONT SIZE="-1">RESTORE</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixANU"></A>
The following constants can be used when saving or restoring
virtual machines
<DL COMPACT>
<DT>Sys::Virt::Domain::SAVE_BYPASS_CACHE<DD>
<A NAME="ixANV"></A>
Do not use <FONT SIZE="-1">OS</FONT> I/O cache when saving state.
<DT>Sys::Virt::Domain::SAVE_PAUSED<DD>
<A NAME="ixANW"></A>
Mark the saved state as paused to prevent the guest CPUs
starting upon restore.
<DT>Sys::Virt::Domain::SAVE_RUNNING<DD>
<A NAME="ixANX"></A>
Mark the saved state as running to allow the guest CPUs
to start upon restore.
</DL>
<A NAME="lbBK">&nbsp;</A>
<H3><FONT SIZE="-1">DOMAIN</FONT> <FONT SIZE="-1">CORE</FONT> <FONT SIZE="-1">DUMP</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixANY"></A>
The following constants can be used when triggering domain
core dumps
<DL COMPACT>
<DT>Sys::Virt::Domain::DUMP_LIVE<DD>
<A NAME="ixANZ"></A>
Do not pause execution while dumping the guest
<DT>Sys::Virt::Domain::DUMP_CRASH<DD>
<A NAME="ixAOA"></A>
Crash the guest after completing the core dump
<DT>Sys::Virt::Domain::DUMP_BYPASS_CACHE<DD>
<A NAME="ixAOB"></A>
Do not use <FONT SIZE="-1">OS</FONT> I/O cache when writing core dump
<DT>Sys::Virt::Domain::DUMP_RESET<DD>
<A NAME="ixAOC"></A>
Reset the virtual machine after finishing the dump
</DL>
<A NAME="lbBL">&nbsp;</A>
<H3><FONT SIZE="-1">DESTROY</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixAOD"></A>
The following constants are useful when terminating guests
using the <TT>&quot;destroy&quot;</TT> <FONT SIZE="-1">API</FONT>.
<DL COMPACT>
<DT>Sys::Virt::Domain::DESTROY_DEFAULT<DD>
<A NAME="ixAOE"></A>
Destroy the guest using the default approach
<DT>Sys::Virt::Domain::DESTROY_GRACEFUL<DD>
<A NAME="ixAOF"></A>
Destroy the guest in a graceful manner
</DL>
<A NAME="lbBM">&nbsp;</A>
<H3><FONT SIZE="-1">SHUTDOWN</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixAOG"></A>
The following constants are useful when requesting that a
guest terminate using the <TT>&quot;shutdown&quot;</TT> <FONT SIZE="-1">API</FONT>
<DL COMPACT>
<DT>Sys::Virt::Domain::SHUTDOWN_DEFAULT<DD>
<A NAME="ixAOH"></A>
Shutdown using the hypervisor's default mechanism
<DT>Sys::Virt::Domain::SHUTDOWN_GUEST_AGENT<DD>
<A NAME="ixAOI"></A>
Shutdown by issuing a command to a guest agent
<DT>Sys::Virt::Domain::SHUTDOWN_ACPI_POWER_BTN<DD>
<A NAME="ixAOJ"></A>
Shutdown by injecting an <FONT SIZE="-1">ACPI</FONT> power button press
</DL>
<A NAME="lbBN">&nbsp;</A>
<H3><FONT SIZE="-1">REBOOT</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixAOK"></A>
The following constants are useful when requesting that a
guest terminate using the <TT>&quot;reboot&quot;</TT> <FONT SIZE="-1">API</FONT>
<DL COMPACT>
<DT>Sys::Virt::Domain::REBOOT_DEFAULT<DD>
<A NAME="ixAOL"></A>
Reboot using the hypervisor's default mechanism
<DT>Sys::Virt::Domain::REBOOT_GUEST_AGENT<DD>
<A NAME="ixAOM"></A>
Reboot by issuing a command to a guest agent
<DT>Sys::Virt::Domain::REBOOT_ACPI_POWER_BTN<DD>
<A NAME="ixAON"></A>
Reboot by injecting an <FONT SIZE="-1">ACPI</FONT> power button press
</DL>
<A NAME="lbBO">&nbsp;</A>
<H3><FONT SIZE="-1">METADATA</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixAOO"></A>
The following constants are useful when reading/writing
metadata about a guest
<DL COMPACT>
<DT>Sys::Virt::Domain::METADATA_TITLE<DD>
<A NAME="ixAOP"></A>
The short human friendly title of the guest
<DT>Sys::Virt::Domain::METADATA_DESCRIPTION<DD>
<A NAME="ixAOQ"></A>
The long free text description of the guest
<DT>Sys::Virt::Domain::METADATA_ELEMENT<DD>
<A NAME="ixAOR"></A>
The structured metadata elements for the guest
</DL>
<A NAME="lbBP">&nbsp;</A>
<H3><FONT SIZE="-1">DISK</FONT> <FONT SIZE="-1">ERROR</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixAOS"></A>
The following constants are useful when interpreting
disk error codes
<DL COMPACT>
<DT>Sys::Virt::Domain::DISK_ERROR_NONE<DD>
<A NAME="ixAOT"></A>
No error
<DT>Sys::Virt::Domain::DISK_ERROR_NO_SPACE<DD>
<A NAME="ixAOU"></A>
The host storage has run out of free space
<DT>Sys::Virt::Domain::DISK_ERROR_UNSPEC<DD>
<A NAME="ixAOV"></A>
An unspecified error has ocurred.
</DL>
<A NAME="lbBQ">&nbsp;</A>
<H3><FONT SIZE="-1">MEMORY</FONT> <FONT SIZE="-1">STATISTIC</FONT> <FONT SIZE="-1">CONSTANTS</FONT></H3>

<A NAME="ixAOW"></A>
<DL COMPACT>
<DT>Sys::Virt::Domain::MEMORY_STAT_SWAP_IN<DD>
<A NAME="ixAOX"></A>
Swap in
<DT>Sys::Virt::Domain::MEMORY_STAT_SWAP_OUT<DD>
<A NAME="ixAOY"></A>
Swap out
<DT>Sys::Virt::Domain::MEMORY_STAT_MINOR_FAULT<DD>
<A NAME="ixAOZ"></A>
Minor faults
<DT>Sys::Virt::Domain::MEMORY_STAT_MAJOR_FAULT<DD>
<A NAME="ixAPA"></A>
Major faults
<DT>Sys::Virt::Domain::MEMORY_STAT_RSS<DD>
<A NAME="ixAPB"></A>
Resident memory
<DT>Sys::Virt::Domain::MEMORY_STAT_UNUSED<DD>
<A NAME="ixAPC"></A>
Unused memory
<DT>Sys::Virt::Domain::MEMORY_STAT_AVAILABLE<DD>
<A NAME="ixAPD"></A>
Available memory
<DT>Sys::Virt::Domain::MEMORY_STAT_ACTUAL_BALLOON<DD>
<A NAME="ixAPE"></A>
Actual balloon limit
</DL>
<A NAME="lbBR">&nbsp;</A>
<H2>AUTHORS</H2>

<A NAME="ixAPF"></A>
Daniel P. Berrange &lt;<A HREF="mailto:berrange@redhat.com">berrange@redhat.com</A>&gt;
<A NAME="lbBS">&nbsp;</A>
<H2>COPYRIGHT</H2>

<A NAME="ixAPG"></A>
Copyright (C) 2006 Red Hat
Copyright (C) 2006-2007 Daniel P. Berrange
<A NAME="lbBT">&nbsp;</A>
<H2>LICENSE</H2>

<A NAME="ixAPH"></A>
This program is free software; you can redistribute it and/or modify
it under the terms of either the <FONT SIZE="-1">GNU</FONT> General Public License as published
by the Free Software Foundation (either version 2 of the License, or at
your option any later version), or, the Artistic License, as specified
in the Perl <FONT SIZE="-1">README</FONT> file.
<A NAME="lbBU">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAPI"></A>
Sys::Virt, Sys::Virt::Error, <TT>&quot;<A HREF="http://libvirt.org">http://libvirt.org</A>&quot;</TT>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">DESCRIPTION</A><DD>
<DT><A HREF="#lbAD">METHODS</A><DD>
<DT><A HREF="#lbAE">CONSTANTS</A><DD>
<DL>
<DT><A HREF="#lbAF"><FONT SIZE="-1">DOMAIN</FONT> <FONT SIZE="-1">STATE</FONT></A><DD>
<DT><A HREF="#lbAG"><FONT SIZE="-1">CONTROL</FONT> <FONT SIZE="-1">INFO</FONT></A><DD>
<DT><A HREF="#lbAH"><FONT SIZE="-1">DOMAIN</FONT> <FONT SIZE="-1">CREATION</FONT></A><DD>
<DT><A HREF="#lbAI"><FONT SIZE="-1">KEYCODE</FONT> <FONT SIZE="-1">SETS</FONT></A><DD>
<DT><A HREF="#lbAJ"><FONT SIZE="-1">MEMORY</FONT> <FONT SIZE="-1">PEEK</FONT></A><DD>
<DT><A HREF="#lbAK"><FONT SIZE="-1">VCPU</FONT> <FONT SIZE="-1">STATE</FONT></A><DD>
<DT><A HREF="#lbAL"><FONT SIZE="-1">OPEN</FONT> <FONT SIZE="-1">GRAPHICS</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbAM"><FONT SIZE="-1">XML</FONT> <FONT SIZE="-1">DUMP</FONT> <FONT SIZE="-1">OPTIONS</FONT></A><DD>
<DT><A HREF="#lbAN"><FONT SIZE="-1">DEVICE</FONT> <FONT SIZE="-1">HOTPLUG</FONT> <FONT SIZE="-1">OPTIONS</FONT></A><DD>
<DT><A HREF="#lbAO"><FONT SIZE="-1">MEMORY</FONT> <FONT SIZE="-1">OPTIONS</FONT></A><DD>
<DT><A HREF="#lbAP"><FONT SIZE="-1">CONFIG</FONT> <FONT SIZE="-1">OPTIONS</FONT></A><DD>
<DT><A HREF="#lbAQ"><FONT SIZE="-1">MIGRATE</FONT> <FONT SIZE="-1">OPTIONS</FONT></A><DD>
<DT><A HREF="#lbAR"><FONT SIZE="-1">UNDEFINE</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbAS"><FONT SIZE="-1">JOB</FONT> <FONT SIZE="-1">TYPES</FONT></A><DD>
<DT><A HREF="#lbAT"><FONT SIZE="-1">MEMORY</FONT> <FONT SIZE="-1">PARAMETERS</FONT></A><DD>
<DT><A HREF="#lbAU"><FONT SIZE="-1">BLKIO</FONT> <FONT SIZE="-1">PARAMETERS</FONT></A><DD>
<DT><A HREF="#lbAV"><FONT SIZE="-1">BLKIO</FONT> <FONT SIZE="-1">TUNING</FONT> <FONT SIZE="-1">PARAMETERS</FONT></A><DD>
<DT><A HREF="#lbAW"><FONT SIZE="-1">SCHEDULER</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbAX"><FONT SIZE="-1">NUMA</FONT> <FONT SIZE="-1">PARAMETERS</FONT></A><DD>
<DT><A HREF="#lbAY"><FONT SIZE="-1">INTERFACE</FONT> <FONT SIZE="-1">PARAMETERS</FONT></A><DD>
<DT><A HREF="#lbAZ"><FONT SIZE="-1">VCPU</FONT> <FONT SIZE="-1">FLAGS</FONT></A><DD>
<DT><A HREF="#lbBA"><FONT SIZE="-1">STATE</FONT> <FONT SIZE="-1">CHANGE</FONT> <FONT SIZE="-1">EVENTS</FONT></A><DD>
<DT><A HREF="#lbBB"><FONT SIZE="-1">EVENT</FONT> <FONT SIZE="-1">ID</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbBC"><FONT SIZE="-1">IO</FONT> <FONT SIZE="-1">ERROR</FONT> <FONT SIZE="-1">EVENT</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbBD"><FONT SIZE="-1">WATCHDOG</FONT> <FONT SIZE="-1">EVENT</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbBE"><FONT SIZE="-1">GRAPHICS</FONT> <FONT SIZE="-1">EVENT</FONT> <FONT SIZE="-1">PHASE</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbBF"><FONT SIZE="-1">GRAPHICS</FONT> <FONT SIZE="-1">EVENT</FONT> <FONT SIZE="-1">ADDRESS</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbBG"><FONT SIZE="-1">DISK</FONT> <FONT SIZE="-1">CHANGE</FONT> <FONT SIZE="-1">EVENT</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbBH"><FONT SIZE="-1">DOMAIN</FONT> <FONT SIZE="-1">BLOCK</FONT> <FONT SIZE="-1">JOB</FONT> <FONT SIZE="-1">TYPE</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbBI"><FONT SIZE="-1">DOMAIN</FONT> <FONT SIZE="-1">BLOCK</FONT> <FONT SIZE="-1">JOB</FONT> <FONT SIZE="-1">COMPLETION</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbBJ"><FONT SIZE="-1">DOMAIN</FONT> <FONT SIZE="-1">SAVE</FONT> / <FONT SIZE="-1">RESTORE</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbBK"><FONT SIZE="-1">DOMAIN</FONT> <FONT SIZE="-1">CORE</FONT> <FONT SIZE="-1">DUMP</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbBL"><FONT SIZE="-1">DESTROY</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbBM"><FONT SIZE="-1">SHUTDOWN</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbBN"><FONT SIZE="-1">REBOOT</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbBO"><FONT SIZE="-1">METADATA</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbBP"><FONT SIZE="-1">DISK</FONT> <FONT SIZE="-1">ERROR</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
<DT><A HREF="#lbBQ"><FONT SIZE="-1">MEMORY</FONT> <FONT SIZE="-1">STATISTIC</FONT> <FONT SIZE="-1">CONSTANTS</FONT></A><DD>
</DL>
<DT><A HREF="#lbBR">AUTHORS</A><DD>
<DT><A HREF="#lbBS">COPYRIGHT</A><DD>
<DT><A HREF="#lbBT">LICENSE</A><DD>
<DT><A HREF="#lbBU">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:43 GMT, December 24, 2015
</div></div>
</body>
</HTML>
