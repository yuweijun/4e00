<!DOCTYPE html>

<HTML><head><TITLE>Manpage of Unicode::Collate</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>Unicode::Collate</H1>
Section: Perl Programmers Reference Guide (3pm)<BR>Updated: 2009-02-12<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Unicode::Collate - Unicode Collation Algorithm
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
  use Unicode::Collate;

  #construct
  $Collator = Unicode::Collate-&gt;new(%tailoring);

  #sort
  @sorted = $Collator-&gt;sort(@not_sorted);

  #compare
  $result = $Collator-&gt;cmp($a, $b); # returns 1, 0, or -1.

  # If %tailoring is false (i.e. empty),
  # $Collator should do the default collation.

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
This module is an implementation of Unicode Technical Standard #10
(a.k.a. <FONT SIZE="-1">UTS</FONT> #10) - Unicode Collation Algorithm (a.k.a. <FONT SIZE="-1">UCA</FONT>).
<A NAME="lbAE">&nbsp;</A>
<H3>Constructor and Tailoring</H3>

<A NAME="ixAAE"></A>
The <TT>&quot;new&quot;</TT> method returns a collator object.
<P>



<PRE>
   $Collator = Unicode::Collate-&gt;new(
      UCA_Version =&gt; $UCA_Version,
      alternate =&gt; $alternate, # deprecated: use of 'variable' is recommended.
      backwards =&gt; $levelNumber, # or \@levelNumbers
      entry =&gt; $element,
      hangul_terminator =&gt; $term_primary_weight,
      ignoreName =&gt; qr/$ignoreName/,
      ignoreChar =&gt; qr/$ignoreChar/,
      katakana_before_hiragana =&gt; $bool,
      level =&gt; $collationLevel,
      normalization  =&gt; $normalization_form,
      overrideCJK =&gt; \&amp;overrideCJK,
      overrideHangul =&gt; \&amp;overrideHangul,
      preprocess =&gt; \&amp;preprocess,
      rearrange =&gt; \@charList,
      table =&gt; $filename,
      undefName =&gt; qr/$undefName/,
      undefChar =&gt; qr/$undefChar/,
      upper_before_lower =&gt; $bool,
      variable =&gt; $variable,
   );

</PRE>


<DL COMPACT>
<DT>UCA_Version<DD>
<A NAME="ixAAF"></A>
If the tracking version number of <FONT SIZE="-1">UCA</FONT> is given,
behavior of that tracking version is emulated on collating.
If omitted, the return value of <TT>&quot;UCA_Version()&quot;</TT> is used.
<TT>&quot;UCA_Version()&quot;</TT> should return the latest tracking version supported.


<P>


The supported tracking version: 8, 9, 11, or 14.


<P>




<PRE>
     UCA       Unicode Standard         DUCET (@version)
     ---------------------------------------------------
      8              3.1                3.0.1 (3.0.1d9)
      9     3.1 with Corrigendum 3      3.1.1 (3.1.1)
     11              4.0                4.0.0 (4.0.0)
     14             4.1.0               4.1.0 (4.1.0)

</PRE>




<P>


Note: Recent <FONT SIZE="-1">UTS</FONT> #10 renames ``Tracking Version'' to ``Revision.''
<DT>alternate<DD>
<A NAME="ixAAG"></A>
-- see 3.2.2 Alternate Weighting, version 8 of <FONT SIZE="-1">UTS</FONT> #10


<P>


For backward compatibility, <TT>&quot;alternate&quot;</TT> (old name) can be used
as an alias for <TT>&quot;variable&quot;</TT>.
<DT>backwards<DD>
<A NAME="ixAAH"></A>
-- see 3.1.2 French Accents, <FONT SIZE="-1">UTS</FONT> #10.


<P>




<PRE>
     backwards =&gt; $levelNumber or \@levelNumbers

</PRE>




<P>


Weights in reverse order; ex. level 2 (diacritic ordering) in French.
If omitted, forwards at all the levels.
<DT>entry<DD>
<A NAME="ixAAI"></A>
-- see 3.1 Linguistic Features; 3.2.1 File Format, <FONT SIZE="-1">UTS</FONT> #10.


<P>


If the same character (or a sequence of characters) exists
in the collation element table through <TT>&quot;table&quot;</TT>,
mapping to collation elements is overrided.
If it does not exist, the mapping is defined additionally.


<P>




<PRE>
    entry =&gt; &lt;&lt;'ENTRY', # for DUCET v4.0.0 (allkeys-4.0.0.txt)
0063 0068 ; [.0E6A.0020.0002.0063] # ch
0043 0068 ; [.0E6A.0020.0007.0043] # Ch
0043 0048 ; [.0E6A.0020.0008.0043] # CH
006C 006C ; [.0F4C.0020.0002.006C] # ll
004C 006C ; [.0F4C.0020.0007.004C] # Ll
004C 004C ; [.0F4C.0020.0008.004C] # LL
00F1      ; [.0F7B.0020.0002.00F1] # n-tilde
006E 0303 ; [.0F7B.0020.0002.00F1] # n-tilde
00D1      ; [.0F7B.0020.0008.00D1] # N-tilde
004E 0303 ; [.0F7B.0020.0008.00D1] # N-tilde
ENTRY

    entry =&gt; &lt;&lt;'ENTRY', # for DUCET v4.0.0 (allkeys-4.0.0.txt)
00E6 ; [.0E33.0020.0002.00E6][.0E8B.0020.0002.00E6] # ae ligature as &lt;a&gt;&lt;e&gt;
00C6 ; [.0E33.0020.0008.00C6][.0E8B.0020.0008.00C6] # AE ligature as &lt;A&gt;&lt;E&gt;
ENTRY

</PRE>




<P>


<B></B><FONT SIZE="-1"><B>NOTE:</B></FONT><B></B> The code point in the <FONT SIZE="-1">UCA</FONT> file format (before <TT>';'</TT>)
<B>must</B> be a Unicode code point (defined as hexadecimal),
but not a native code point.
So <TT>0063</TT> must always denote <TT>&quot;U+0063&quot;</TT>,
but not a character of <TT>&quot;\x63&quot;</TT>.


<P>


Weighting may vary depending on collation element table.
So ensure the weights defined in <TT>&quot;entry&quot;</TT> will be consistent with
those in the collation element table loaded via <TT>&quot;table&quot;</TT>.


<P>


In <FONT SIZE="-1">DUCET</FONT> v4.0.0, primary weight of <TT>&quot;C&quot;</TT> is <TT>0E60</TT>
and that of <TT>&quot;D&quot;</TT> is <TT>&quot;0E6D&quot;</TT>. So setting primary weight of <TT>&quot;CH&quot;</TT> to <TT>&quot;0E6A&quot;</TT>
(as a value between <TT>0E60</TT> and <TT>&quot;0E6D&quot;</TT>)
makes ordering as <TT>&quot;C &lt; CH &lt; D&quot;</TT>.
Exactly speaking <FONT SIZE="-1">DUCET</FONT> already has some characters between <TT>&quot;C&quot;</TT> and <TT>&quot;D&quot;</TT>:
<TT>&quot;small capital C&quot;</TT> (<TT>&quot;U+1D04&quot;</TT>) with primary weight <TT>0E64</TT>,
<TT>&quot;c-hook/C-hook&quot;</TT> (<TT>&quot;U+0188/U+0187&quot;</TT>) with <TT>0E65</TT>,
and <TT>&quot;c-curl&quot;</TT> (<TT>&quot;U+0255&quot;</TT>) with <TT>0E69</TT>.
Then primary weight <TT>&quot;0E6A&quot;</TT> for <TT>&quot;CH&quot;</TT> makes <TT>&quot;CH&quot;</TT>
ordered between <TT>&quot;c-curl&quot;</TT> and <TT>&quot;D&quot;</TT>.
<DT>hangul_terminator<DD>
<A NAME="ixAAJ"></A>
-- see 7.1.4 Trailing Weights, <FONT SIZE="-1">UTS</FONT> #10.


<P>


If a true value is given (non-zero but should be positive),
it will be added as a terminator primary weight to the end of
every standard Hangul syllable. Secondary and any higher weights
for terminator are set to zero.
If the value is false or <TT>&quot;hangul_terminator&quot;</TT> key does not exist,
insertion of terminator weights will not be performed.


<P>


Boundaries of Hangul syllables are determined
according to conjoining Jamo behavior in <I>the Unicode Standard</I>
and <I>HangulSyllableType.txt</I>.


<P>


<B>Implementation Note:</B>
(1) For expansion mapping (Unicode character mapped
to a sequence of collation elements), a terminator will not be added
between collation elements, even if Hangul syllable boundary exists there.
Addition of terminator is restricted to the next position
to the last collation element.


<P>


(2) Non-conjoining Hangul letters
(Compatibility Jamo, halfwidth Jamo, and enclosed letters) are not
automatically terminated with a terminator primary weight.
These characters may need terminator included in a collation element
table beforehand.
<DT>ignoreChar<DD>
<A NAME="ixAAK"></A>

<DT>ignoreName<DD>
<A NAME="ixAAL"></A>

-- see 3.2.2 Variable Weighting, <FONT SIZE="-1">UTS</FONT> #10.


<P>


Makes the entry in the table completely ignorable;
i.e. as if the weights were zero at all level.


<P>


Through <TT>&quot;ignoreChar&quot;</TT>, any character matching <TT>&quot;qr/$ignoreChar/&quot;</TT>
will be ignored. Through <TT>&quot;ignoreName&quot;</TT>, any character whose name
(given in the <TT>&quot;table&quot;</TT> file as a comment) matches <TT>&quot;qr/$ignoreName/&quot;</TT>
will be ignored.


<P>


E.g. when 'a' and 'e' are ignorable,
'element' is equal to 'lament' (or 'lmnt').
<DT>katakana_before_hiragana<DD>
<A NAME="ixAAM"></A>
-- see 7.3.1 Tertiary Weight Table, <FONT SIZE="-1">UTS</FONT> #10.


<P>


By default, hiragana is before katakana.
If the parameter is made true, this is reversed.


<P>


<B></B><FONT SIZE="-1"><B>NOTE</B></FONT><B></B>: This parameter simplemindedly assumes that any hiragana/katakana
distinctions must occur in level 3, and their weights at level 3 must be
same as those mentioned in 7.3.1, <FONT SIZE="-1">UTS</FONT> #10.
If you define your collation elements which violate this requirement,
this parameter does not work validly.
<DT>level<DD>
<A NAME="ixAAN"></A>
-- see 4.3 Form Sort Key, <FONT SIZE="-1">UTS</FONT> #10.


<P>


Set the maximum level.
Any higher levels than the specified one are ignored.


<P>




<PRE>
  Level 1: alphabetic ordering
  Level 2: diacritic ordering
  Level 3: case ordering
  Level 4: tie-breaking (e.g. in the case when variable is 'shifted')

  ex.level =&gt; 2,

</PRE>




<P>


If omitted, the maximum is the 4th.
<DT>normalization<DD>
<A NAME="ixAAO"></A>
-- see 4.1 Normalize, <FONT SIZE="-1">UTS</FONT> #10.


<P>


If specified, strings are normalized before preparation of sort keys
(the normalization is executed after preprocess).


<P>


A form name <TT>&quot;Unicode::Normalize::normalize()&quot;</TT> accepts will be applied
as <TT>$normalization_form</TT>.
Acceptable names include <TT>'NFD'</TT>, <TT>'NFC'</TT>, <TT>'NFKD'</TT>, and <TT>'NFKC'</TT>.
See <TT>&quot;Unicode::Normalize::normalize()&quot;</TT> for detail.
If omitted, <TT>'NFD'</TT> is used.


<P>


<TT>&quot;normalization&quot;</TT> is performed after <TT>&quot;preprocess&quot;</TT> (if defined).


<P>


Furthermore, special values, <TT>&quot;undef&quot;</TT> and <TT>&quot;prenormalized&quot;</TT>, can be used,
though they are not concerned with <TT>&quot;Unicode::Normalize::normalize()&quot;</TT>.


<P>


If <TT>&quot;undef&quot;</TT> (not a string <TT>&quot;undef&quot;</TT>) is passed explicitly
as the value for this key,
any normalization is not carried out (this may make tailoring easier
if any normalization is not desired). Under <TT>&quot;(normalization =&gt; undef)&quot;</TT>,
only contiguous contractions are resolved;
e.g. even if <TT>&quot;A-ring&quot;</TT> (and <TT>&quot;A-ring-cedilla&quot;</TT>) is ordered after <TT>&quot;Z&quot;</TT>,
<TT>&quot;A-cedilla-ring&quot;</TT> would be primary equal to <TT>&quot;A&quot;</TT>.
In this point,
<TT>&quot;(normalization =&gt; undef, preprocess =&gt; sub { NFD(shift) })&quot;</TT>
<B>is not</B> equivalent to <TT>&quot;(normalization =&gt; 'NFD')&quot;</TT>.


<P>


In the case of <TT>&quot;(normalization =&gt; &quot;prenormalized&quot;)&quot;</TT>,
any normalization is not performed, but
non-contiguous contractions with combining characters are performed.
Therefore
<TT>&quot;(normalization =&gt; 'prenormalized', preprocess =&gt; sub { NFD(shift) })&quot;</TT>
<B>is</B> equivalent to <TT>&quot;(normalization =&gt; 'NFD')&quot;</TT>.
If source strings are finely prenormalized,
<TT>&quot;(normalization =&gt; 'prenormalized')&quot;</TT> may save time for normalization.


<P>


Except <TT>&quot;(normalization =&gt; undef)&quot;</TT>,
<B>Unicode::Normalize</B> is required (see also <B></B><FONT SIZE="-1"><B>CAVEAT</B></FONT><B></B>).
<DT>overrideCJK<DD>
<A NAME="ixAAP"></A>
-- see 7.1 Derived Collation Elements, <FONT SIZE="-1">UTS</FONT> #10.


<P>


By default, <FONT SIZE="-1">CJK</FONT> Unified Ideographs are ordered in Unicode codepoint order
but <TT>&quot;CJK Unified Ideographs&quot;</TT> (if <TT>&quot;UCA_Version&quot;</TT> is 8 to 11, its range is
<TT>&quot;U+4E00..U+9FA5&quot;</TT>; if <TT>&quot;UCA_Version&quot;</TT> is 14, its range is <TT>&quot;U+4E00..U+9FBB&quot;</TT>)
are lesser than <TT>&quot;CJK Unified Ideographs Extension&quot;</TT> (its range is
<TT>&quot;U+3400..U+4DB5&quot;</TT> and <TT>&quot;U+20000..U+2A6D6&quot;</TT>).


<P>


Through <TT>&quot;overrideCJK&quot;</TT>, ordering of <FONT SIZE="-1">CJK</FONT> Unified Ideographs can be overrided.


<P>


ex. <FONT SIZE="-1">CJK</FONT> Unified Ideographs in the <FONT SIZE="-1">JIS</FONT> code point order.


<P>




<PRE>
  overrideCJK =&gt; sub {
      my $u = shift;             # get a Unicode codepoint
      my $b = pack('n', $u);     # to UTF-16BE
      my $s = your_unicode_to_sjis_converter($b); # convert
      my $n = unpack('n', $s);   # convert sjis to short
      [ $n, 0x20, 0x2, $u ];     # return the collation element
  },

</PRE>




<P>


ex. ignores all <FONT SIZE="-1">CJK</FONT> Unified Ideographs.


<P>




<PRE>
  overrideCJK =&gt; sub {()}, # CODEREF returning empty list

   # where -&gt;eq(&quot;Pe\x{4E00}rl&quot;, &quot;Perl&quot;) is true
   # as U+4E00 is a CJK Unified Ideograph and to be ignorable.

</PRE>




<P>


If <TT>&quot;undef&quot;</TT> is passed explicitly as the value for this key,
weights for <FONT SIZE="-1">CJK</FONT> Unified Ideographs are treated as undefined.
But assignment of weight for <FONT SIZE="-1">CJK</FONT> Unified Ideographs
in table or <TT>&quot;entry&quot;</TT> is still valid.
<DT>overrideHangul<DD>
<A NAME="ixAAQ"></A>
-- see 7.1 Derived Collation Elements, <FONT SIZE="-1">UTS</FONT> #10.


<P>


By default, Hangul Syllables are decomposed into Hangul Jamo,
even if <TT>&quot;(normalization =&gt; undef)&quot;</TT>.
But the mapping of Hangul Syllables may be overrided.


<P>


This parameter works like <TT>&quot;overrideCJK&quot;</TT>, so see there for examples.


<P>


If you want to override the mapping of Hangul Syllables,
<FONT SIZE="-1">NFD</FONT>, <FONT SIZE="-1">NFKD</FONT>, and <FONT SIZE="-1">FCD</FONT> are not appropriate,
since they will decompose Hangul Syllables before overriding.


<P>


If <TT>&quot;undef&quot;</TT> is passed explicitly as the value for this key,
weight for Hangul Syllables is treated as undefined
without decomposition into Hangul Jamo.
But definition of weight for Hangul Syllables
in table or <TT>&quot;entry&quot;</TT> is still valid.
<DT>preprocess<DD>
<A NAME="ixAAR"></A>
-- see 5.1 Preprocessing, <FONT SIZE="-1">UTS</FONT> #10.


<P>


If specified, the coderef is used to preprocess
before the formation of sort keys.


<P>


ex. dropping English articles, such as ``a'' or ``the''.
Then, ``the pen'' is before ``a pencil''.


<P>




<PRE>
     preprocess =&gt; sub {
           my $str = shift;
           $str =~ s/\b(?:an?|the)\s+//gi;
           return $str;
        },

</PRE>




<P>


<TT>&quot;preprocess&quot;</TT> is performed before <TT>&quot;normalization&quot;</TT> (if defined).
<DT>rearrange<DD>
<A NAME="ixAAS"></A>
-- see 3.1.3 Rearrangement, <FONT SIZE="-1">UTS</FONT> #10.


<P>


Characters that are not coded in logical order and to be rearranged.
If <TT>&quot;UCA_Version&quot;</TT> is equal to or lesser than 11, default is:


<P>




<PRE>
    rearrange =&gt; [ 0x0E40..0x0E44, 0x0EC0..0x0EC4 ],

</PRE>




<P>


If you want to disallow any rearrangement, pass <TT>&quot;undef&quot;</TT> or <TT>&quot;[]&quot;</TT>
(a reference to empty list) as the value for this key.


<P>


If <TT>&quot;UCA_Version&quot;</TT> is equal to 14, default is <TT>&quot;[]&quot;</TT> (i.e. no rearrangement).


<P>


<B>According to the version 9 of </B><FONT SIZE="-1"><B>UCA</B></FONT><B>, this parameter shall not be used;
but it is not warned at present.</B>
<DT>table<DD>
<A NAME="ixAAT"></A>
-- see 3.2 Default Unicode Collation Element Table, <FONT SIZE="-1">UTS</FONT> #10.


<P>


You can use another collation element table if desired.


<P>


The table file should locate in the <I>Unicode/Collate</I> directory
on <TT>@INC</TT>. Say, if the filename is <I>Foo.txt</I>,
the table file is searched as <I>Unicode/Collate/Foo.txt</I> in <TT>@INC</TT>.


<P>


By default, <I>allkeys.txt</I> (as the filename of <FONT SIZE="-1">DUCET</FONT>) is used.
If you will prepare your own table file, any name other than <I>allkeys.txt</I>
may be better to avoid namespace conflict.


<P>


If <TT>&quot;undef&quot;</TT> is passed explicitly as the value for this key,
no file is read (but you can define collation elements via <TT>&quot;entry&quot;</TT>).


<P>


A typical way to define a collation element table
without any file of table:


<P>




<PRE>
   $onlyABC = Unicode::Collate-&gt;new(
       table =&gt; undef,
       entry =&gt; &lt;&lt; 'ENTRIES',
0061 ; [.0101.0020.0002.0061] # LATIN SMALL LETTER A
0041 ; [.0101.0020.0008.0041] # LATIN CAPITAL LETTER A
0062 ; [.0102.0020.0002.0062] # LATIN SMALL LETTER B
0042 ; [.0102.0020.0008.0042] # LATIN CAPITAL LETTER B
0063 ; [.0103.0020.0002.0063] # LATIN SMALL LETTER C
0043 ; [.0103.0020.0008.0043] # LATIN CAPITAL LETTER C
ENTRIES
    );

</PRE>




<P>


If <TT>&quot;ignoreName&quot;</TT> or <TT>&quot;undefName&quot;</TT> is used, character names should be
specified as a comment (following <TT>&quot;#&quot;</TT>) on each line.
<DT>undefChar<DD>
<A NAME="ixAAU"></A>

<DT>undefName<DD>
<A NAME="ixAAV"></A>

-- see 6.3.4 Reducing the Repertoire, <FONT SIZE="-1">UTS</FONT> #10.


<P>


Undefines the collation element as if it were unassigned in the table.
This reduces the size of the table.
If an unassigned character appears in the string to be collated,
the sort key is made from its codepoint
as a single-character collation element,
as it is greater than any other assigned collation elements
(in the codepoint order among the unassigned characters).
But, it'd be better to ignore characters
unfamiliar to you and maybe never used.


<P>


Through <TT>&quot;undefChar&quot;</TT>, any character matching <TT>&quot;qr/$undefChar/&quot;</TT>
will be undefined. Through <TT>&quot;undefName&quot;</TT>, any character whose name
(given in the <TT>&quot;table&quot;</TT> file as a comment) matches <TT>&quot;qr/$undefName/&quot;</TT>
will be undefined.


<P>


ex. Collation weights for beyond-BMP characters are not stored in object:


<P>




<PRE>
    undefChar =&gt; qr/[^\0-\x{fffd}]/,

</PRE>


<DT>upper_before_lower<DD>
<A NAME="ixAAW"></A>
-- see 6.6 Case Comparisons, <FONT SIZE="-1">UTS</FONT> #10.


<P>


By default, lowercase is before uppercase.
If the parameter is made true, this is reversed.


<P>


<B></B><FONT SIZE="-1"><B>NOTE</B></FONT><B></B>: This parameter simplemindedly assumes that any lowercase/uppercase
distinctions must occur in level 3, and their weights at level 3 must be
same as those mentioned in 7.3.1, <FONT SIZE="-1">UTS</FONT> #10.
If you define your collation elements which differs from this requirement,
this parameter doesn't work validly.
<DT>variable<DD>
<A NAME="ixAAX"></A>
-- see 3.2.2 Variable Weighting, <FONT SIZE="-1">UTS</FONT> #10.


<P>


This key allows to variable weighting for variable collation elements,
which are marked with an <FONT SIZE="-1">ASTERISK</FONT> in the table
(<FONT SIZE="-1">NOTE:</FONT> Many punction marks and symbols are variable in <I>allkeys.txt</I>).


<P>




<PRE>
   variable =&gt; 'blanked', 'non-ignorable', 'shifted', or 'shift-trimmed'.

</PRE>




<P>


These names are case-insensitive.
By default (if specification is omitted), 'shifted' is adopted.


<P>




<PRE>
   'Blanked'        Variable elements are made ignorable at levels 1 through 3;
                    considered at the 4th level.

   'Non-Ignorable'  Variable elements are not reset to ignorable.

   'Shifted'        Variable elements are made ignorable at levels 1 through 3
                    their level 4 weight is replaced by the old level 1 weight.
                    Level 4 weight for Non-Variable elements is 0xFFFF.

   'Shift-Trimmed'  Same as 'shifted', but all FFFF's at the 4th level
                    are trimmed.

</PRE>


</DL>
<A NAME="lbAF">&nbsp;</A>
<H3>Methods for Collation</H3>

<A NAME="ixAAY"></A>
<DL COMPACT>
<DT>@sorted = $Collator-&gt;sort(@not_sorted)<DD>


<A NAME="ixAAZ"></A>
Sorts a list of strings.
<DT>$result = $Collator-&gt;cmp($a, $b)<DD>


<A NAME="ixABA"></A>
Returns 1 (when <TT>$a</TT> is greater than <TT>$b</TT>)
or 0 (when <TT>$a</TT> is equal to <TT>$b</TT>)
or -1 (when <TT>$a</TT> is lesser than <TT>$b</TT>).
<DT>$result = $Collator-&gt;eq($a, $b)<DD>


<A NAME="ixABB"></A>

<DT>$result = $Collator-&gt;ne($a, $b)<DD>


<A NAME="ixABC"></A>
<DT>$result = $Collator-&gt;lt($a, $b)<DD>


<A NAME="ixABD"></A>
<DT>$result = $Collator-&gt;le($a, $b)<DD>


<A NAME="ixABE"></A>
<DT>$result = $Collator-&gt;gt($a, $b)<DD>


<A NAME="ixABF"></A>
<DT>$result = $Collator-&gt;ge($a, $b)<DD>


<A NAME="ixABG"></A>

They works like the same name operators as theirs.


<P>




<PRE>
   eq : whether $a is equal to $b.
   ne : whether $a is not equal to $b.
   lt : whether $a is lesser than $b.
   le : whether $a is lesser than $b or equal to $b.
   gt : whether $a is greater than $b.
   ge : whether $a is greater than $b or equal to $b.

</PRE>


<DT>$sortKey = $Collator-&gt;getSortKey($string)<DD>


<A NAME="ixABH"></A>
-- see 4.3 Form Sort Key, <FONT SIZE="-1">UTS</FONT> #10.


<P>


Returns a sort key.


<P>


You compare the sort keys using a binary comparison
and get the result of the comparison of the strings using <FONT SIZE="-1">UCA</FONT>.


<P>




<PRE>
   $Collator-&gt;getSortKey($a) cmp $Collator-&gt;getSortKey($b)

      is equivalent to

   $Collator-&gt;cmp($a, $b)

</PRE>


<DT>$sortKeyForm = $Collator-&gt;viewSortKey($string)<DD>


<A NAME="ixABI"></A>
Converts a sorting key into its representation form.
If <TT>&quot;UCA_Version&quot;</TT> is 8, the output is slightly different.


<P>




<PRE>
   use Unicode::Collate;
   my $c = Unicode::Collate-&gt;new();
   print $c-&gt;viewSortKey(&quot;Perl&quot;),&quot;\n&quot;;

   # output:
   # [0B67 0A65 0B7F 0B03 | 0020 0020 0020 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF]
   #  Level 1               Level 2               Level 3               Level 4

</PRE>


</DL>
<A NAME="lbAG">&nbsp;</A>
<H3>Methods for Searching</H3>

<A NAME="ixABJ"></A>
<B></B><FONT SIZE="-1"><B>DISCLAIMER:</B></FONT><B></B> If <TT>&quot;preprocess&quot;</TT> or <TT>&quot;normalization&quot;</TT> parameter is true
for <TT>$Collator</TT>, calling these methods (<TT>&quot;index&quot;</TT>, <TT>&quot;match&quot;</TT>, <TT>&quot;gmatch&quot;</TT>,
<TT>&quot;subst&quot;</TT>, <TT>&quot;gsubst&quot;</TT>) is croaked,
as the position and the length might differ
from those on the specified string.
(And <TT>&quot;rearrange&quot;</TT> and <TT>&quot;hangul_terminator&quot;</TT> parameters are neglected.)
<P>

The <TT>&quot;match&quot;</TT>, <TT>&quot;gmatch&quot;</TT>, <TT>&quot;subst&quot;</TT>, <TT>&quot;gsubst&quot;</TT> methods work
like <TT>&quot;m//&quot;</TT>, <TT>&quot;m//g&quot;</TT>, <TT>&quot;s///&quot;</TT>, <TT>&quot;s///g&quot;</TT>, respectively,
but they are not aware of any pattern, but only a literal substring.
<DL COMPACT>
<DT>$position = $Collator-&gt;index($string, $substring[, $position])<DD>


<A NAME="ixABK"></A>

<DT>($position, $length) = $Collator-&gt;index($string, $substring[, $position])<DD>


<A NAME="ixABL"></A>

If <TT>$substring</TT> matches a part of <TT>$string</TT>, returns
the position of the first occurrence of the matching part in scalar context;
in list context, returns a two-element list of
the position and the length of the matching part.


<P>


If <TT>$substring</TT> does not match any part of <TT>$string</TT>,
returns <TT>&quot;-1&quot;</TT> in scalar context and
an empty list in list context.


<P>


e.g. you say


<P>




<PRE>
  my $Collator = Unicode::Collate-&gt;new( normalization =&gt; undef, level =&gt; 1 );
                                     # (normalization =&gt; undef) is REQUIRED.
  my $str = &quot;Ich muA~X studieren Perl.&quot;;
  my $sub = &quot;MA~XSS&quot;;
  my $match;
  if (my($pos,$len) = $Collator-&gt;index($str, $sub)) {
      $match = substr($str, $pos, $len);
  }

</PRE>




<P>


and get <TT>&quot;muA~X&quot;</TT> in <TT>$match</TT> since <TT>&quot;muA~X&quot;</TT>
is primary equal to <TT>&quot;MA~XSS&quot;</TT>.
<DT>$match_ref = $Collator-&gt;match($string, $substring)<DD>


<A NAME="ixABM"></A>

<DT>($match)   = $Collator-&gt;match($string, $substring)<DD>


<A NAME="ixABN"></A>

If <TT>$substring</TT> matches a part of <TT>$string</TT>, in scalar context, returns
<B>a reference to</B> the first occurrence of the matching part
(<TT>$match_ref</TT> is always true if matches,
since every reference is <B>true</B>);
in list context, returns the first occurrence of the matching part.


<P>


If <TT>$substring</TT> does not match any part of <TT>$string</TT>,
returns <TT>&quot;undef&quot;</TT> in scalar context and
an empty list in list context.


<P>


e.g.


<P>




<PRE>
    if ($match_ref = $Collator-&gt;match($str, $sub)) { # scalar context
        print &quot;matches [$$match_ref].\n&quot;;
    } else {
        print &quot;doesn't match.\n&quot;;
    }

     or

    if (($match) = $Collator-&gt;match($str, $sub)) { # list context
        print &quot;matches [$match].\n&quot;;
    } else {
        print &quot;doesn't match.\n&quot;;
    }

</PRE>


<DT>@match = $Collator-&gt;gmatch($string, $substring)<DD>


<A NAME="ixABO"></A>
If <TT>$substring</TT> matches a part of <TT>$string</TT>, returns
all the matching parts (or matching count in scalar context).


<P>


If <TT>$substring</TT> does not match any part of <TT>$string</TT>,
returns an empty list.
<DT>$count = $Collator-&gt;subst($string, $substring, $replacement)<DD>


<A NAME="ixABP"></A>
If <TT>$substring</TT> matches a part of <TT>$string</TT>,
the first occurrence of the matching part is replaced by <TT>$replacement</TT>
(<TT>$string</TT> is modified) and return <TT>$count</TT> (always equals to <TT>1</TT>).


<P>


<TT>$replacement</TT> can be a <TT>&quot;CODEREF&quot;</TT>,
taking the matching part as an argument,
and returning a string to replace the matching part
(a bit similar to <TT>&quot;s/(..)/$coderef-&gt;($1)/e&quot;</TT>).
<DT>$count = $Collator-&gt;gsubst($string, $substring, $replacement)<DD>


<A NAME="ixABQ"></A>
If <TT>$substring</TT> matches a part of <TT>$string</TT>,
all the occurrences of the matching part is replaced by <TT>$replacement</TT>
(<TT>$string</TT> is modified) and return <TT>$count</TT>.


<P>


<TT>$replacement</TT> can be a <TT>&quot;CODEREF&quot;</TT>,
taking the matching part as an argument,
and returning a string to replace the matching part
(a bit similar to <TT>&quot;s/(..)/$coderef-&gt;($1)/eg&quot;</TT>).


<P>


e.g.


<P>




<PRE>
  my $Collator = Unicode::Collate-&gt;new( normalization =&gt; undef, level =&gt; 1 );
                                     # (normalization =&gt; undef) is REQUIRED.
  my $str = &quot;Camel donkey zebra came\x{301}l CAMEL horse cAm\0E\0L...&quot;;
  $Collator-&gt;gsubst($str, &quot;camel&quot;, sub { &quot;&lt;b&gt;$_[0]&lt;/b&gt;&quot; });

  # now $str is &quot;&lt;b&gt;Camel&lt;/b&gt; donkey zebra &lt;b&gt;came\x{301}l&lt;/b&gt; &lt;b&gt;CAMEL&lt;/b&gt; horse &lt;b&gt;cAm\0E\0L&lt;/b&gt;...&quot;;
  # i.e., all the camels are made bold-faced.

</PRE>


</DL>
<A NAME="lbAH">&nbsp;</A>
<H3>Other Methods</H3>

<A NAME="ixABR"></A>
<DL COMPACT>
<DT>%old_tailoring = $Collator-&gt;change(%new_tailoring)<DD>


<A NAME="ixABS"></A>
Change the value of specified keys and returns the changed part.


<P>




<PRE>
    $Collator = Unicode::Collate-&gt;new(level =&gt; 4);

    $Collator-&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # false

    %old = $Collator-&gt;change(level =&gt; 2); # returns (level =&gt; 4).

    $Collator-&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # true

    $Collator-&gt;change(%old); # returns (level =&gt; 2).

    $Collator-&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # false

</PRE>




<P>


Not all <TT>&quot;(key,value)&quot;</TT>s are allowed to be changed.
See also <TT>@Unicode::Collate::ChangeOK</TT> and <TT>@Unicode::Collate::ChangeNG</TT>.


<P>


In the scalar context, returns the modified collator
(but it is <B>not</B> a clone from the original).


<P>




<PRE>
    $Collator-&gt;change(level =&gt; 2)-&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # true

    $Collator-&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # true; now max level is 2nd.

    $Collator-&gt;change(level =&gt; 4)-&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # false

</PRE>


<DT>$version = $Collator-&gt;version()<DD>


<A NAME="ixABT"></A>
Returns the version number (a string) of the Unicode Standard
which the <TT>&quot;table&quot;</TT> file used by the collator object is based on.
If the table does not include a version line (starting with <TT>@version</TT>),
returns <TT>&quot;unknown&quot;</TT>.
<DT>UCA_Version()<DD>


<A NAME="ixABU"></A>
Returns the tracking version number of <FONT SIZE="-1">UTS</FONT> #10 this module consults.
<DT>Base_Unicode_Version()<DD>


<A NAME="ixABV"></A>
Returns the version number of <FONT SIZE="-1">UTS</FONT> #10 this module consults.
</DL>
<A NAME="lbAI">&nbsp;</A>
<H2>EXPORT</H2>

<A NAME="ixABW"></A>
No method will be exported.
<A NAME="lbAJ">&nbsp;</A>
<H2>INSTALL</H2>

<A NAME="ixABX"></A>
Though this module can be used without any <TT>&quot;table&quot;</TT> file,
to use this module easily, it is recommended to install a table file
in the <FONT SIZE="-1">UCA</FONT> format, by copying it under the directory
&lt;a place in <TT>@INC</TT>&gt;/Unicode/Collate.
<P>

The most preferable one is ``The Default Unicode Collation Element Table''
(aka <FONT SIZE="-1">DUCET</FONT>), available from the Unicode Consortium's website:
<P>



<PRE>
   <A HREF="http://www.unicode.org/Public/UCA/">http://www.unicode.org/Public/UCA/</A>

   <A HREF="http://www.unicode.org/Public/UCA/latest/allkeys.txt">http://www.unicode.org/Public/UCA/latest/allkeys.txt</A> (latest version)

</PRE>


<P>

If <FONT SIZE="-1">DUCET</FONT> is not installed, it is recommended to copy the file
from <A HREF="http://www.unicode.org/Public/UCA/latest/allkeys.txt">http://www.unicode.org/Public/UCA/latest/allkeys.txt</A>
to &lt;a place in <TT>@INC</TT>&gt;/Unicode/Collate/allkeys.txt
manually.
<A NAME="lbAK">&nbsp;</A>
<H2>CAVEATS</H2>

<A NAME="ixABY"></A>
<DL COMPACT>
<DT>Normalization<DD>
<A NAME="ixABZ"></A>
Use of the <TT>&quot;normalization&quot;</TT> parameter requires the <B>Unicode::Normalize</B>
module (see Unicode::Normalize).


<P>


If you need not it (say, in the case when you need not
handle any combining characters),
assign <TT>&quot;normalization =&gt; undef&quot;</TT> explicitly.


<P>


-- see 6.5 Avoiding Normalization, <FONT SIZE="-1">UTS</FONT> #10.
<DT>Conformance Test<DD>
<A NAME="ixACA"></A>
The Conformance Test for the <FONT SIZE="-1">UCA</FONT> is available
under &lt;<A HREF="http://www.unicode.org/Public/UCA/">http://www.unicode.org/Public/UCA/</A>&gt;.


<P>


For <I>CollationTest_SHIFTED.txt</I>,
a collator via <TT>&quot;Unicode::Collate-&gt;new( )&quot;</TT> should be used;
for <I>CollationTest_NON_IGNORABLE.txt</I>, a collator via
<TT>&quot;Unicode::Collate-&gt;new(variable =&gt; &quot;non-ignorable&quot;, level =&gt; 3)&quot;</TT>.


<P>


<B>Unicode::Normalize is required to try The Conformance Test.</B>
</DL>
<A NAME="lbAL">&nbsp;</A>
<H2>AUTHOR, COPYRIGHT AND LICENSE</H2>

<A NAME="ixACB"></A>
The Unicode::Collate module for perl was written by <FONT SIZE="-1">SADAHIRO</FONT> Tomoyuki,
&lt;<A HREF="mailto:SADAHIRO@cpan.org">SADAHIRO@cpan.org</A>&gt;. This module is Copyright(C) 2001-2005,
<FONT SIZE="-1">SADAHIRO</FONT> Tomoyuki. Japan. All rights reserved.
<P>

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
<P>

The file Unicode/Collate/allkeys.txt was copied directly
from &lt;<A HREF="http://www.unicode.org/Public/UCA/4.1.0/allkeys.txt">http://www.unicode.org/Public/UCA/4.1.0/allkeys.txt</A>&gt;.
This file is Copyright (c) 1991-2005 Unicode, Inc. All rights reserved.
Distributed under the Terms of Use in &lt;<A HREF="http://www.unicode.org/copyright.html">http://www.unicode.org/copyright.html</A>&gt;.
<A NAME="lbAM">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixACC"></A>
<DL COMPACT>
<DT>Unicode Collation Algorithm - <FONT SIZE="-1">UTS</FONT> #10<DD>
<A NAME="ixACD"></A>
&lt;<A HREF="http://www.unicode.org/reports/tr10/">http://www.unicode.org/reports/tr10/</A>&gt;
<DT>The Default Unicode Collation Element Table (<FONT SIZE="-1">DUCET</FONT>)<DD>
<A NAME="ixACE"></A>
&lt;<A HREF="http://www.unicode.org/Public/UCA/latest/allkeys.txt">http://www.unicode.org/Public/UCA/latest/allkeys.txt</A>&gt;
<DT>The conformance test for the <FONT SIZE="-1">UCA</FONT><DD>
<A NAME="ixACF"></A>
&lt;<A HREF="http://www.unicode.org/Public/UCA/latest/CollationTest.html">http://www.unicode.org/Public/UCA/latest/CollationTest.html</A>&gt;


<P>


&lt;<A HREF="http://www.unicode.org/Public/UCA/latest/CollationTest.zip">http://www.unicode.org/Public/UCA/latest/CollationTest.zip</A>&gt;
<DT>Hangul Syllable Type<DD>
<A NAME="ixACG"></A>
&lt;<A HREF="http://www.unicode.org/Public/UNIDATA/HangulSyllableType.txt">http://www.unicode.org/Public/UNIDATA/HangulSyllableType.txt</A>&gt;
<DT>Unicode Normalization Forms - <FONT SIZE="-1">UAX</FONT> #15<DD>
<A NAME="ixACH"></A>
&lt;<A HREF="http://www.unicode.org/reports/tr15/">http://www.unicode.org/reports/tr15/</A>&gt;
<P>
</DL>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE">Constructor and Tailoring</A><DD>
<DT><A HREF="#lbAF">Methods for Collation</A><DD>
<DT><A HREF="#lbAG">Methods for Searching</A><DD>
<DT><A HREF="#lbAH">Other Methods</A><DD>
</DL>
<DT><A HREF="#lbAI">EXPORT</A><DD>
<DT><A HREF="#lbAJ">INSTALL</A><DD>
<DT><A HREF="#lbAK">CAVEATS</A><DD>
<DT><A HREF="#lbAL">AUTHOR, COPYRIGHT AND LICENSE</A><DD>
<DT><A HREF="#lbAM">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:44 GMT, December 24, 2015
</div></body>
</HTML>
