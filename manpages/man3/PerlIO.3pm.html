<!DOCTYPE html>

<HTML><head><TITLE>Manpage of PerlIO</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>PerlIO</H1>
Section: Perl Programmers Reference Guide (3pm)<BR>Updated: 2009-07-03<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

PerlIO - On demand loader for PerlIO layers and root of PerlIO::* name space
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
  open($fh,&quot;&lt;:crlf&quot;, &quot;my.txt&quot;); # support platform-native and CRLF text files

  open($fh,&quot;&lt;&quot;,&quot;his.jpg&quot;);      # portably open a binary file for reading
  binmode($fh);

  Shell:
    PERLIO=perlio perl ....

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
When an undefined layer 'foo' is encountered in an <TT>&quot;open&quot;</TT> or
<TT>&quot;binmode&quot;</TT> layer specification then C code performs the equivalent of:
<P>



<PRE>
  use PerlIO 'foo';

</PRE>


<P>

The perl code in PerlIO.pm then attempts to locate a layer by doing
<P>



<PRE>
  require PerlIO::foo;

</PRE>


<P>

Otherwise the <TT>&quot;PerlIO&quot;</TT> package is a place holder for additional
PerlIO related functions.
<P>

The following layers are currently defined:
<DL COMPACT>
<DT>:unix<DD>
<A NAME="ixAAE"></A>
Lowest level layer which provides basic PerlIO operations in terms of
<FONT SIZE="-1">UNIX/POSIX</FONT> numeric file descriptor calls
(<I>open()</I>, <I>read()</I>, <I>write()</I>, <I>lseek()</I>, <I>close()</I>).
<DT>:stdio<DD>
<A NAME="ixAAF"></A>
Layer which calls <TT>&quot;fread&quot;</TT>, <TT>&quot;fwrite&quot;</TT> and <TT>&quot;fseek&quot;</TT>/<TT>&quot;ftell&quot;</TT> etc.  Note
that as this is ``real'' stdio it will ignore any layers beneath it and
go straight to the operating system via the C library as usual.
<DT>:perlio<DD>
<A NAME="ixAAG"></A>
A from scratch implementation of buffering for PerlIO. Provides fast
access to the buffer for <TT>&quot;sv_gets&quot;</TT> which implements perl's readline/&lt;&gt;
and in general attempts to minimize data copying.


<P>


<TT>&quot;:perlio&quot;</TT> will insert a <TT>&quot;:unix&quot;</TT> layer below itself to do low level <FONT SIZE="-1">IO</FONT>.
<DT>:crlf<DD>
<A NAME="ixAAH"></A>
A layer that implements DOS/Windows like <FONT SIZE="-1">CRLF</FONT> line endings.  On read
converts pairs of <FONT SIZE="-1">CR</FONT>,LF to a single ``\n'' newline character.  On write
converts each ``\n'' to a <FONT SIZE="-1">CR</FONT>,LF pair.  Note that this layer likes to be
one of its kind: it silently ignores attempts to be pushed into the
layer stack more than once.


<P>


It currently does <I>not</I> mimic MS-DOS as far as treating of Control-Z
as being an end-of-file marker.


<P>


(Gory details follow) To be more exact what happens is this: after
pushing itself to the stack, the <TT>&quot;:crlf&quot;</TT> layer checks all the layers
below itself to find the first layer that is capable of being a <FONT SIZE="-1">CRLF</FONT>
layer but is not yet enabled to be a <FONT SIZE="-1">CRLF</FONT> layer.  If it finds such a
layer, it enables the CRLFness of that other deeper layer, and then
pops itself off the stack.  If not, fine, use the one we just pushed.


<P>


The end result is that a <TT>&quot;:crlf&quot;</TT> means ``please enable the first <FONT SIZE="-1">CRLF</FONT>
layer you can find, and if you can't find one, here would be a good
spot to place a new one.''


<P>


Based on the <TT>&quot;:perlio&quot;</TT> layer.
<DT>:mmap<DD>
<A NAME="ixAAI"></A>
A layer which implements ``reading'' of files by using <TT>&quot;mmap()&quot;</TT> to
make a (whole) file appear in the process's address space, and then
using that as PerlIO's ``buffer''. This <I>may</I> be faster in certain
circumstances for large files, and may result in less physical memory
use when multiple processes are reading the same file.


<P>


Files which are not <TT>&quot;mmap()&quot;</TT>-able revert to behaving like the <TT>&quot;:perlio&quot;</TT>
layer. Writes also behave like the <TT>&quot;:perlio&quot;</TT> layer, as <TT>&quot;mmap()&quot;</TT> for write
needs extra house-keeping (to extend the file) which negates any advantage.


<P>


The <TT>&quot;:mmap&quot;</TT> layer will not exist if the platform does not support <TT>&quot;mmap()&quot;</TT>.
<DT>:utf8<DD>
<A NAME="ixAAJ"></A>
Declares that the stream accepts perl's <I>internal</I> encoding of
characters.  (Which really is <FONT SIZE="-1">UTF-8</FONT> on <FONT SIZE="-1">ASCII</FONT> machines, but is
UTF-EBCDIC on <FONT SIZE="-1">EBCDIC</FONT> machines.)  This allows any character perl can
represent to be read from or written to the stream. The UTF-X encoding
is chosen to render simple text parts (i.e.  non-accented letters,
digits and common punctuation) human readable in the encoded file.


<P>


Here is how to write your native data out using <FONT SIZE="-1">UTF-8</FONT> (or UTF-EBCDIC)
and then read it back in.


<P>




<PRE>
        open(F, &quot;&gt;:utf8&quot;, &quot;data.utf&quot;);
        print F $out;
        close(F);

        open(F, &quot;&lt;:utf8&quot;, &quot;data.utf&quot;);
        $in = &lt;F&gt;;
        close(F);

</PRE>




<P>


Note that this layer does not validate byte sequences. For reading
input, using <TT>&quot;:encoding(utf8)&quot;</TT> instead of bare <TT>&quot;:utf8&quot;</TT> is strongly
recommended.
<DT>:bytes<DD>
<A NAME="ixAAK"></A>
This is the inverse of the <TT>&quot;:utf8&quot;</TT> layer. It turns off the flag
on the layer below so that data read from it is considered to
be ``octets'' i.e. characters in the range 0..255 only. Likewise
on output perl will warn if a ``wide'' character is written
to a such a stream.
<DT>:raw<DD>
<A NAME="ixAAL"></A>
The <TT>&quot;:raw&quot;</TT> layer is <I>defined</I> as being identical to calling
<TT>&quot;binmode($fh)&quot;</TT> - the stream is made suitable for passing binary data,
i.e. each byte is passed as-is. The stream will still be
buffered.


<P>


In Perl 5.6 and some books the <TT>&quot;:raw&quot;</TT> layer (previously sometimes also
referred to as a ``discipline'') is documented as the inverse of the
<TT>&quot;:crlf&quot;</TT> layer. That is no longer the case - other layers which would
alter the binary nature of the stream are also disabled.  If you want <FONT SIZE="-1">UNIX</FONT>
line endings on a platform that normally does <FONT SIZE="-1">CRLF</FONT> translation, but still
want <FONT SIZE="-1">UTF-8</FONT> or encoding defaults, the appropriate thing to do is to add
<TT>&quot;:perlio&quot;</TT> to the <FONT SIZE="-1">PERLIO</FONT> environment variable.


<P>


The implementation of <TT>&quot;:raw&quot;</TT> is as a pseudo-layer which when ``pushed''
pops itself and then any layers which do not declare themselves as suitable
for binary data. (Undoing :utf8 and :crlf are implemented by clearing
flags rather than popping layers but that is an implementation detail.)


<P>


As a consequence of the fact that <TT>&quot;:raw&quot;</TT> normally pops layers,
it usually only makes sense to have it as the only or first element in
a layer specification.  When used as the first element it provides
a known base on which to build e.g.


<P>




<PRE>
    open($fh,&quot;:raw:utf8&quot;,...)

</PRE>




<P>


will construct a ``binary'' stream, but then enable <FONT SIZE="-1">UTF-8</FONT> translation.
<DT>:pop<DD>
<A NAME="ixAAM"></A>
A pseudo layer that removes the top-most layer. Gives perl code
a way to manipulate the layer stack. Should be considered
as experimental. Note that <TT>&quot;:pop&quot;</TT> only works on real layers
and will not undo the effects of pseudo layers like <TT>&quot;:utf8&quot;</TT>.
An example of a possible use might be:


<P>




<PRE>
    open($fh,...)
    ...
    binmode($fh,&quot;:encoding(...)&quot;);  # next chunk is encoded
    ...
    binmode($fh,&quot;:pop&quot;);            # back to un-encoded

</PRE>




<P>


A more elegant (and safer) interface is needed.
<DT>:win32<DD>
<A NAME="ixAAN"></A>
On Win32 platforms this <I>experimental</I> layer uses the native ``handle'' <FONT SIZE="-1">IO</FONT>
rather than the unix-like numeric file descriptor layer. Known to be
buggy as of perl 5.8.2.
</DL>
<A NAME="lbAE">&nbsp;</A>
<H3>Custom Layers</H3>

<A NAME="ixAAO"></A>
It is possible to write custom layers in addition to the above builtin
ones, both in C/XS and Perl.  Two such layers (and one example written
in Perl using the latter) come with the Perl distribution.
<DL COMPACT>
<DT>:encoding<DD>
<A NAME="ixAAP"></A>
Use <TT>&quot;:encoding(ENCODING)&quot;</TT> either in <I>open()</I> or <I>binmode()</I> to install
a layer that transparently does character set and encoding transformations,
for example from Shift-JIS to Unicode.  Note that under <TT>&quot;stdio&quot;</TT>
an <TT>&quot;:encoding&quot;</TT> also enables <TT>&quot;:utf8&quot;</TT>.  See PerlIO::encoding
for more information.
<DT>:via<DD>
<A NAME="ixAAQ"></A>
Use <TT>&quot;:via(MODULE)&quot;</TT> either in <I>open()</I> or <I>binmode()</I> to install a layer
that does whatever transformation (for example compression /
decompression, encryption / decryption) to the filehandle.
See PerlIO::via for more information.
</DL>
<A NAME="lbAF">&nbsp;</A>
<H3>Alternatives to raw</H3>

<A NAME="ixAAR"></A>
To get a binary stream an alternate method is to use:
<P>



<PRE>
    open($fh,&quot;whatever&quot;)
    binmode($fh);

</PRE>


<P>

this has the advantage of being backward compatible with how such things have
had to be coded on some platforms for years.
<P>

To get an unbuffered stream specify an unbuffered layer (e.g. <TT>&quot;:unix&quot;</TT>)
in the open call:
<P>



<PRE>
    open($fh,&quot;&lt;:unix&quot;,$path)

</PRE>


<A NAME="lbAG">&nbsp;</A>
<H3>Defaults and how to override them</H3>

<A NAME="ixAAS"></A>
If the platform is MS-DOS like and normally does <FONT SIZE="-1">CRLF</FONT> to ``\n''
translation for text files then the default layers are :
<P>



<PRE>
  unix crlf

</PRE>


<P>

(The low level ``unix'' layer may be replaced by a platform specific low
level layer.)
<P>

Otherwise if <TT>&quot;Configure&quot;</TT> found out how to do ``fast'' <FONT SIZE="-1">IO</FONT> using the system's
stdio, then the default layers are:
<P>



<PRE>
  unix stdio

</PRE>


<P>

Otherwise the default layers are
<P>



<PRE>
  unix perlio

</PRE>


<P>

These defaults may change once perlio has been better tested and tuned.
<P>

The default can be overridden by setting the environment variable
<FONT SIZE="-1">PERLIO</FONT> to a space separated list of layers (<TT>&quot;unix&quot;</TT> or platform low
level layer is always pushed first).
<P>

This can be used to see the effect of/bugs in the various layers e.g.
<P>



<PRE>
  cd .../perl/t
  PERLIO=stdio  ./perl harness
  PERLIO=perlio ./perl harness

</PRE>


<P>

For the various values of <FONT SIZE="-1">PERLIO</FONT> see ``<FONT SIZE="-1">PERLIO</FONT>'' in perlrun.
<A NAME="lbAH">&nbsp;</A>
<H3>Querying the layers of filehandles</H3>

<A NAME="ixAAT"></A>
The following returns the <B>names</B> of the PerlIO layers on a filehandle.
<P>



<PRE>
   my @layers = PerlIO::get_layers($fh); # Or FH, *FH, &quot;FH&quot;.

</PRE>


<P>

The layers are returned in the order an <I>open()</I> or <I>binmode()</I> call would
use them.  Note that the ``default stack'' depends on the operating
system and on the Perl version, and both the compile-time and
runtime configurations of Perl.
<P>

The following table summarizes the default layers on UNIX-like and
DOS-like platforms and depending on the setting of <TT>$ENV{PERLIO}</TT>:
<P>



<PRE>
 PERLIO     UNIX-like                   DOS-like
 ------     ---------                   --------
 unset / &quot;&quot; unix perlio / stdio [1]     unix crlf
 stdio      unix perlio / stdio [1]     stdio
 perlio     unix perlio                 unix perlio
 mmap       unix mmap                   unix mmap

 # [1] &quot;stdio&quot; if Configure found out how to do &quot;fast stdio&quot; (depends
 # on the stdio implementation) and in Perl 5.8, otherwise &quot;unix perlio&quot;

</PRE>


<P>

By default the layers from the input side of the filehandle are
returned; to get the output side, use the optional <TT>&quot;output&quot;</TT> argument:
<P>



<PRE>
   my @layers = PerlIO::get_layers($fh, output =&gt; 1);

</PRE>


<P>

(Usually the layers are identical on either side of a filehandle but
for example with sockets there may be differences, or if you have
been using the <TT>&quot;open&quot;</TT> pragma.)
<P>

There is no <I>set_layers()</I>, nor does <I>get_layers()</I> return a tied array
mirroring the stack, or anything fancy like that.  This is not
accidental or unintentional.  The PerlIO layer stack is a bit more
complicated than just a stack (see for example the behaviour of <TT>&quot;:raw&quot;</TT>).
You are supposed to use <I>open()</I> and <I>binmode()</I> to manipulate the stack.
<P>

<B>Implementation details follow, please close your eyes.</B>
<P>

The arguments to layers are by default returned in parentheses after
the name of the layer, and certain layers (like <TT>&quot;utf8&quot;</TT>) are not real
layers but instead flags on real layers; to get all of these returned
separately, use the optional <TT>&quot;details&quot;</TT> argument:
<P>



<PRE>
   my @layer_and_args_and_flags = PerlIO::get_layers($fh, details =&gt; 1);

</PRE>


<P>

The result will be up to be three times the number of layers:
the first element will be a name, the second element the arguments
(unspecified arguments will be <TT>&quot;undef&quot;</TT>), the third element the flags,
the fourth element a name again, and so forth.
<P>

<B>You may open your eyes now.</B>
<A NAME="lbAI">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixAAU"></A>
Nick Ing-Simmons &lt;<A HREF="mailto:nick@ing-simmons.net">nick@ing-simmons.net</A>&gt;
<A NAME="lbAJ">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAV"></A>
``binmode'' in perlfunc, ``open'' in perlfunc, perlunicode, perliol,
Encode
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE">Custom Layers</A><DD>
<DT><A HREF="#lbAF">Alternatives to raw</A><DD>
<DT><A HREF="#lbAG">Defaults and how to override them</A><DD>
<DT><A HREF="#lbAH">Querying the layers of filehandles</A><DD>
</DL>
<DT><A HREF="#lbAI">AUTHOR</A><DD>
<DT><A HREF="#lbAJ">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:36 GMT, December 24, 2015
</div></body>
</HTML>
