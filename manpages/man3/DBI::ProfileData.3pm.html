<!DOCTYPE html>

<HTML><head><TITLE>Manpage of DBI::ProfileData</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>DBI::ProfileData</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2007-09-27<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

DBI::ProfileData - manipulate DBI::ProfileDumper data dumps
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>
The easiest way to use this module is through the dbiprof frontend
(see dbiprof for details):
<P>



<PRE>
  dbiprof --number 15 --sort count

</PRE>


<P>

This module can also be used to roll your own profile analysis:
<P>



<PRE>
  # load data from dbi.prof
  $prof = DBI::ProfileData-&gt;new(File =&gt; &quot;dbi.prof&quot;);

  # get a count of the records (unique paths) in the data set
  $count = $prof-&gt;count();

  # sort by longest overall time
  $prof-&gt;sort(field =&gt; &quot;longest&quot;);

  # sort by longest overall time, least to greatest
  $prof-&gt;sort(field =&gt; &quot;longest&quot;, reverse =&gt; 1);

  # exclude records with key2 eq 'disconnect'
  $prof-&gt;exclude(key2 =&gt; 'disconnect');

  # exclude records with key1 matching /^UPDATE/i
  $prof-&gt;exclude(key1 =&gt; qr/^UPDATE/i);

  # remove all records except those where key1 matches /^SELECT/i
  $prof-&gt;match(key1 =&gt; qr/^SELECT/i);

  # produce a formatted report with the given number of items
  $report = $prof-&gt;report(number =&gt; 10); 

  # clone the profile data set
  $clone = $prof-&gt;clone();

  # get access to hash of header values
  $header = $prof-&gt;header();

  # get access to sorted array of nodes
  $nodes = $prof-&gt;nodes();

  # format a single node in the same style as report()
  $text = $prof-&gt;format($nodes-&gt;[0]);

  # get access to Data hash in DBI::Profile format
  $Data = $prof-&gt;Data();

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
This module offers the ability to read, manipulate and format
DBI::ProfileDumper profile data.
<P>

Conceptually, a profile consists of a series of records, or nodes,
each of each has a set of statistics and set of keys.  Each record
must have a unique set of keys, but there is no requirement that every
record have the same number of keys.
<A NAME="lbAE">&nbsp;</A>
<H2>METHODS</H2>

<A NAME="ixAAE"></A>
The following methods are supported by DBI::ProfileData objects.
<A NAME="lbAF">&nbsp;</A>
<H3>$prof = DBI::ProfileData-&gt;new(File =&gt; dbi.prof)</H3>



<A NAME="ixAAF"></A>
<A NAME="lbAG">&nbsp;</A>
<H3>$prof = DBI::ProfileData-&gt;new(File =&gt; dbi.prof, Filter =&gt; sub { ... })</H3>



<A NAME="ixAAG"></A>
<A NAME="lbAH">&nbsp;</A>
<H3>$prof = DBI::ProfileData-&gt;new(Files =&gt; [ dbi.prof.1, dbi.prof.2 ])</H3>



<A NAME="ixAAH"></A>
Creates a a new DBI::ProfileData object.  Takes either a single file
through the File option or a list of Files in an array ref.  If
multiple files are specified then the header data from the first file
is used.
<P>

<I>Files</I>
<A NAME="ixAAI"></A>
<P>

Reference to an array of file names to read.
<P>

<I>File</I>
<A NAME="ixAAJ"></A>
<P>

Name of file to read. Takes precedence over <TT>&quot;Files&quot;</TT>.
<P>

<I>DeleteFiles</I>
<A NAME="ixAAK"></A>
<P>

If true, the files are deleted after being read.
<P>

Actually the files are renamed with a C.deleteme&gt; suffix before being read,
and then, after reading all the files, they're all deleted together.
<P>

The files are locked while being read which, combined with the rename, makes it
safe to 'consume' files that are still being generated by DBI::ProfileDumper.
<P>

<I>Filter</I>
<A NAME="ixAAL"></A>
<P>

The <TT>&quot;Filter&quot;</TT> parameter can be used to supply a code reference that can
manipulate the profile data as it is being read. This is most useful for
editing <FONT SIZE="-1">SQL</FONT> statements so that slightly different statements in the raw data
will be merged and aggregated in the loaded data. For example:
<P>



<PRE>
  Filter =&gt; sub {
      my ($path_ref, $data_ref) = @_;
      s/foo = '.*?'/foo = '...'/ for @$path_ref;
  }

</PRE>


<P>

Here's an example that performs some normalization on the <FONT SIZE="-1">SQL</FONT>. It converts all
numbers to <TT>&quot;N&quot;</TT> and all quoted strings to <TT>&quot;S&quot;</TT>.  It can also convert digits to
N within names. Finally, it summarizes long ``<FONT SIZE="-1">IN</FONT> (...)'' clauses.
<P>

It's aggressive and simplistic, but it's often sufficient, and serves as an
example that you can tailor to suit your own needs:
<P>



<PRE>
  Filter =&gt; sub {
      my ($path_ref, $data_ref) = @_;
      local $_ = $path_ref-&gt;[0]; # whichever element contains the SQL Statement
      s/\b\d+\b/N/g;             # 42 -&gt; N
      s/\b0x[0-9A-Fa-f]+\b/N/g;  # 0xFE -&gt; N
      s/'.*?'/'S'/g;             # single quoted strings (doesn't handle escapes)
      s/&quot;.*?&quot;/&quot;S&quot;/g;             # double quoted strings (doesn't handle escapes)
      # convert names like log_20001231 into log_NNNNNNNN, controlled by $opt{n}
      s/([a-z_]+)(\d{$opt{n},})/$1.('N' x length($2))/ieg if $opt{n};
      # abbreviate massive &quot;in (...)&quot; statements and similar
      s!(([NS],){100,})!sprintf(&quot;$2,{repeated %d times}&quot;,length($1)/2)!eg;
  }

</PRE>


<P>

It's often better to perform this kinds of normalization in the <FONT SIZE="-1">DBI</FONT> while the
data is being collected, to avoid too much memory being used by storing profile
data for many different <FONT SIZE="-1">SQL</FONT> statement. See DBI::Profile.
<A NAME="lbAI">&nbsp;</A>
<H3>$copy = $prof-&gt;<I>clone()</I>;</H3>



<A NAME="ixAAM"></A>
Clone a profile data set creating a new object.
<A NAME="lbAJ">&nbsp;</A>
<H3>$header = $prof-&gt;<I>header()</I>;</H3>



<A NAME="ixAAN"></A>
Returns a reference to a hash of header values.  These are the key
value pairs included in the header section of the DBI::ProfileDumper
data format.  For example:
<P>



<PRE>
  $header = {
    Path    =&gt; [ '!Statement', '!MethodName' ],
    Program =&gt; 't/42profile_data.t',
  };

</PRE>


<P>

Note that modifying this hash will modify the header data stored
inside the profile object.
<A NAME="lbAK">&nbsp;</A>
<H3>$nodes = $prof-&gt;<I>nodes()</I></H3>



<A NAME="ixAAO"></A>
Returns a reference the sorted nodes array.  Each element in the array
is a single record in the data set.  The first seven elements are the
same as the elements provided by DBI::Profile.  After that each key is
in a separate element.  For example:
<P>



<PRE>
 $nodes = [
            [
              2,                      # 0, count
              0.0312958955764771,     # 1, total duration
              0.000490069389343262,   # 2, first duration
              0.000176072120666504,   # 3, shortest duration
              0.00140702724456787,    # 4, longest duration
              1023115819.83019,       # 5, time of first event
              1023115819.86576,       # 6, time of last event
              'SELECT foo FROM bar'   # 7, key1
              'execute'               # 8, key2
                                      # 6+N, keyN
            ],
                                      # ...
          ];

</PRE>


<P>

Note that modifying this array will modify the node data stored inside
the profile object.
<A NAME="lbAL">&nbsp;</A>
<H3>$count = $prof-&gt;<I>count()</I></H3>



<A NAME="ixAAP"></A>
Returns the number of items in the profile data set.
<A NAME="lbAM">&nbsp;</A>
<H3>$prof-&gt;sort(field =&gt; field)</H3>



<A NAME="ixAAQ"></A>
<A NAME="lbAN">&nbsp;</A>
<H3>$prof-&gt;sort(field =&gt; field, reverse =&gt; 1)</H3>



<A NAME="ixAAR"></A>
Sorts data by the given field.  Available fields are:
<P>



<PRE>
  longest
  total
  count
  shortest

</PRE>


<P>

The default sort is greatest to smallest, which is the opposite of the
normal Perl meaning.  This, however, matches the expected behavior of
the dbiprof frontend.
<A NAME="lbAO">&nbsp;</A>
<H3>$count = $prof-&gt;exclude(key2 =&gt; disconnect)</H3>



<A NAME="ixAAS"></A>
<A NAME="lbAP">&nbsp;</A>
<H3>$count = $prof-&gt;exclude(key2 =&gt; disconnect, case_sensitive =&gt; 1)</H3>



<A NAME="ixAAT"></A>
<A NAME="lbAQ">&nbsp;</A>
<H3>$count = $prof-&gt;exclude(key1 =&gt; qr/^SELECT/i)</H3>



<A NAME="ixAAU"></A>
Removes records from the data set that match the given string or
regular expression.  This method modifies the data in a permanent
fashion - use <I>clone()</I> first to maintain the original data after
<I>exclude()</I>.  Returns the number of nodes left in the profile data set.
<A NAME="lbAR">&nbsp;</A>
<H3>$count = $prof-&gt;match(key2 =&gt; disconnect)</H3>



<A NAME="ixAAV"></A>
<A NAME="lbAS">&nbsp;</A>
<H3>$count = $prof-&gt;match(key2 =&gt; disconnect, case_sensitive =&gt; 1)</H3>



<A NAME="ixAAW"></A>
<A NAME="lbAT">&nbsp;</A>
<H3>$count = $prof-&gt;match(key1 =&gt; qr/^SELECT/i)</H3>



<A NAME="ixAAX"></A>
Removes records from the data set that do not match the given string
or regular expression.  This method modifies the data in a permanent
fashion - use <I>clone()</I> first to maintain the original data after
<I>match()</I>.  Returns the number of nodes left in the profile data set.
<A NAME="lbAU">&nbsp;</A>
<H3>$Data = $prof-&gt;<I>Data()</I></H3>



<A NAME="ixAAY"></A>
Returns the same Data hash structure as seen in DBI::Profile.  This
structure is not sorted.  The <I>nodes()</I> structure probably makes more
sense for most analysis.
<A NAME="lbAV">&nbsp;</A>
<H3>$text = $prof-&gt;format($nodes-&gt;[0])</H3>



<A NAME="ixAAZ"></A>
Formats a single node into a human-readable block of text.
<A NAME="lbAW">&nbsp;</A>
<H3>$text = $prof-&gt;report(number =&gt; 10)</H3>



<A NAME="ixABA"></A>
Produces a report with the given number of items.
<A NAME="lbAX">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixABB"></A>
Sam Tregar &lt;<A HREF="mailto:sam@tregar.com">sam@tregar.com</A>&gt;
<A NAME="lbAY">&nbsp;</A>
<H2>COPYRIGHT AND LICENSE</H2>

<A NAME="ixABC"></A>
Copyright (C) 2002 Sam Tregar
<P>

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl 5 itself.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">METHODS</A><DD>
<DL>
<DT><A HREF="#lbAF">$prof = DBI::ProfileData-&gt;new(File =&gt; dbi.prof)</A><DD>
<DT><A HREF="#lbAG">$prof = DBI::ProfileData-&gt;new(File =&gt; dbi.prof, Filter =&gt; sub { ... })</A><DD>
<DT><A HREF="#lbAH">$prof = DBI::ProfileData-&gt;new(Files =&gt; [ dbi.prof.1, dbi.prof.2 ])</A><DD>
<DT><A HREF="#lbAI">$copy = $prof-&gt;<I>clone()</I>;</A><DD>
<DT><A HREF="#lbAJ">$header = $prof-&gt;<I>header()</I>;</A><DD>
<DT><A HREF="#lbAK">$nodes = $prof-&gt;<I>nodes()</I></A><DD>
<DT><A HREF="#lbAL">$count = $prof-&gt;<I>count()</I></A><DD>
<DT><A HREF="#lbAM">$prof-&gt;sort(field =&gt; field)</A><DD>
<DT><A HREF="#lbAN">$prof-&gt;sort(field =&gt; field, reverse =&gt; 1)</A><DD>
<DT><A HREF="#lbAO">$count = $prof-&gt;exclude(key2 =&gt; disconnect)</A><DD>
<DT><A HREF="#lbAP">$count = $prof-&gt;exclude(key2 =&gt; disconnect, case_sensitive =&gt; 1)</A><DD>
<DT><A HREF="#lbAQ">$count = $prof-&gt;exclude(key1 =&gt; qr/^SELECT/i)</A><DD>
<DT><A HREF="#lbAR">$count = $prof-&gt;match(key2 =&gt; disconnect)</A><DD>
<DT><A HREF="#lbAS">$count = $prof-&gt;match(key2 =&gt; disconnect, case_sensitive =&gt; 1)</A><DD>
<DT><A HREF="#lbAT">$count = $prof-&gt;match(key1 =&gt; qr/^SELECT/i)</A><DD>
<DT><A HREF="#lbAU">$Data = $prof-&gt;<I>Data()</I></A><DD>
<DT><A HREF="#lbAV">$text = $prof-&gt;format($nodes-&gt;[0])</A><DD>
<DT><A HREF="#lbAW">$text = $prof-&gt;report(number =&gt; 10)</A><DD>
</DL>
<DT><A HREF="#lbAX">AUTHOR</A><DD>
<DT><A HREF="#lbAY">COPYRIGHT AND LICENSE</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:22 GMT, December 24, 2015
</div></div>
</body>
</HTML>
