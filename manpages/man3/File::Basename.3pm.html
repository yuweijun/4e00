<!DOCTYPE html>

<HTML><head><TITLE>Manpage of File::Basename</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux manpages</a></div>
 <div class="site-description">{"type":"documentation"}</div>
 </div>
 </header>
 <div class="page-content"><div class="wrap">
<H1>File::Basename</H1>
Section: Perl Programmers Reference Guide (3pm)<BR>Updated: 2009-02-12<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

File::Basename - Parse file paths into directory, filename and suffix.
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
    use File::Basename;

    ($name,$path,$suffix) = fileparse($fullname,@suffixlist);
    $name = fileparse($fullname,@suffixlist);

    $basename = basename($fullname,@suffixlist);
    $dirname  = dirname($fullname);

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
These routines allow you to parse file paths into their directory, filename
and suffix.
<P>

<B></B><FONT SIZE="-1"><B>NOTE</B></FONT><B></B>: <TT>&quot;dirname()&quot;</TT> and <TT>&quot;basename()&quot;</TT> emulate the behaviours, and
quirks, of the shell and C functions of the same name.  See each
function's documentation for details.  If your concern is just parsing
paths it is safer to use File::Spec's <TT>&quot;splitpath()&quot;</TT> and
<TT>&quot;splitdir()&quot;</TT> methods.
<P>

It is guaranteed that
<P>



<PRE>
    # Where $path_separator is / for Unix, \ for Windows, etc...
    dirname($path) . $path_separator . basename($path);

</PRE>


<P>

is equivalent to the original path for all systems but <FONT SIZE="-1">VMS</FONT>.
<DL COMPACT>
<DT>fileparse<DD>


<A NAME="ixAAE"></A>
<A NAME="ixAAF"></A>


<PRE>
    my($filename, $directories, $suffix) = fileparse($path);
    my($filename, $directories, $suffix) = fileparse($path, @suffixes);
    my $filename                         = fileparse($path, @suffixes);

</PRE>




<P>


The <TT>&quot;fileparse()&quot;</TT> routine divides a file path into its <TT>$directories</TT>, <TT>$filename</TT>
and (optionally) the filename <TT>$suffix</TT>.


<P>


<TT>$directories</TT> contains everything up to and including the last
directory separator in the <TT>$path</TT> including the volume (if applicable).
The remainder of the <TT>$path</TT> is the <TT>$filename</TT>.


<P>




<PRE>
     # On Unix returns (&quot;baz&quot;, &quot;/foo/bar/&quot;, &quot;&quot;)
     fileparse(&quot;/foo/bar/baz&quot;);

     # On Windows returns (&quot;baz&quot;, &quot;C:\foo\bar\&quot;, &quot;&quot;)
     fileparse(&quot;C:\foo\bar\baz&quot;);

     # On Unix returns (&quot;&quot;, &quot;/foo/bar/baz/&quot;, &quot;&quot;)
     fileparse(&quot;/foo/bar/baz/&quot;);

</PRE>




<P>


If <TT>@suffixes</TT> are given each element is a pattern (either a string or a
<TT>&quot;qr//&quot;</TT>) matched against the end of the <TT>$filename</TT>.  The matching
portion is removed and becomes the <TT>$suffix</TT>.


<P>




<PRE>
     # On Unix returns (&quot;baz&quot;, &quot;/foo/bar/&quot;, &quot;.txt&quot;)
     fileparse(&quot;/foo/bar/baz.txt&quot;, qr/\.[^.]*/);

</PRE>




<P>


If type is non-Unix (see <TT>&quot;fileparse_set_fstype()&quot;</TT>) then the pattern
matching for suffix removal is performed case-insensitively, since
those systems are not case-sensitive when opening existing files.


<P>


You are guaranteed that <TT>&quot;$directories . $filename . $suffix&quot;</TT> will
denote the same location as the original <TT>$path</TT>.
<DT>basename<DD>


<A NAME="ixAAG"></A>
<A NAME="ixAAH"></A>


<PRE>
    my $filename = basename($path);
    my $filename = basename($path, @suffixes);

</PRE>




<P>


This function is provided for compatibility with the Unix shell command
<TT><A HREF="/manpages/index.html?1+basename">basename</A>(1)</TT>.  It does <B></B><FONT SIZE="-1"><B>NOT</B></FONT><B></B> always return the file name portion of a
path as you might expect.  To be safe, if you want the file name portion of
a path use <TT>&quot;fileparse()&quot;</TT>.


<P>


<TT>&quot;basename()&quot;</TT> returns the last level of a filepath even if the last
level is clearly directory.  In effect, it is acting like <TT>&quot;pop()&quot;</TT> for
paths.  This differs from <TT>&quot;fileparse()&quot;</TT>'s behaviour.


<P>




<PRE>
    # Both return &quot;bar&quot;
    basename(&quot;/foo/bar&quot;);
    basename(&quot;/foo/bar/&quot;);

</PRE>




<P>


<TT>@suffixes</TT> work as in <TT>&quot;fileparse()&quot;</TT> except all regex metacharacters are
quoted.


<P>




<PRE>
    # These two function calls are equivalent.
    my $filename = basename(&quot;/foo/bar/baz.txt&quot;,  &quot;.txt&quot;);
    my $filename = fileparse(&quot;/foo/bar/baz.txt&quot;, qr/\Q.txt\E/);

</PRE>




<P>


Also note that in order to be compatible with the shell command,
<TT>&quot;basename()&quot;</TT> does not strip off a suffix if it is identical to the
remaining characters in the filename.
<DT>dirname<DD>


<A NAME="ixAAI"></A>
<A NAME="ixAAJ"></A>
This function is provided for compatibility with the Unix shell
command <TT><A HREF="/manpages/index.html?1+dirname">dirname</A>(1)</TT> and has inherited some of its quirks.  In spite of
its name it does <B></B><FONT SIZE="-1"><B>NOT</B></FONT><B></B> always return the directory name as you might
expect.  To be safe, if you want the directory name of a path use
<TT>&quot;fileparse()&quot;</TT>.


<P>


Only on <FONT SIZE="-1">VMS</FONT> (where there is no ambiguity between the file and directory
portions of a path) and AmigaOS (possibly due to an implementation quirk in
this module) does <TT>&quot;dirname()&quot;</TT> work like <TT>&quot;fileparse($path)&quot;</TT>, returning just the
<TT>$directories</TT>.


<P>




<PRE>
    # On VMS and AmigaOS
    my $directories = dirname($path);

</PRE>




<P>


When using Unix or <FONT SIZE="-1">MSDOS</FONT> syntax this emulates the <TT><A HREF="/manpages/index.html?1+dirname">dirname</A>(1)</TT> shell function
which is subtly different from how <TT>&quot;fileparse()&quot;</TT> works.  It returns all but
the last level of a file path even if the last level is clearly a directory.
In effect, it is not returning the directory portion but simply the path one
level up acting like <TT>&quot;chop()&quot;</TT> for file paths.


<P>


Also unlike <TT>&quot;fileparse()&quot;</TT>, <TT>&quot;dirname()&quot;</TT> does not include a trailing slash on
its returned path.


<P>




<PRE>
    # returns /foo/bar.  fileparse() would return /foo/bar/
    dirname(&quot;/foo/bar/baz&quot;);

    # also returns /foo/bar despite the fact that baz is clearly a 
    # directory.  fileparse() would return /foo/bar/baz/
    dirname(&quot;/foo/bar/baz/&quot;);

    # returns '.'.  fileparse() would return 'foo/'
    dirname(&quot;foo/&quot;);

</PRE>




<P>


Under <FONT SIZE="-1">VMS</FONT>, if there is no directory information in the <TT>$path</TT>, then the
current default device and directory is used.
<DT>fileparse_set_fstype<DD>


<A NAME="ixAAK"></A>
<A NAME="ixAAL"></A>


<PRE>
  my $type = fileparse_set_fstype();
  my $previous_type = fileparse_set_fstype($type);

</PRE>




<P>


Normally File::Basename will assume a file path type native to your current
operating system (ie. /foo/bar style on Unix, \foo\bar on Windows, etc...).
With this function you can override that assumption.


<P>


Valid <TT>$types</TT> are ``MacOS'', ``<FONT SIZE="-1">VMS</FONT>'', ``AmigaOS'', ``<FONT SIZE="-1">OS2</FONT>'', ``<FONT SIZE="-1">RISCOS</FONT>'',
``MSWin32'', ``<FONT SIZE="-1">DOS</FONT>'' (also ``<FONT SIZE="-1">MSDOS</FONT>'' for backwards bug compatibility),
``Epoc'' and ``Unix'' (all case-insensitive).  If an unrecognized <TT>$type</TT> is
given ``Unix'' will be assumed.


<P>


If you've selected <FONT SIZE="-1">VMS</FONT> syntax, and the file specification you pass to
one of these routines contains a ``/'', they assume you are using Unix
emulation and apply the Unix syntax rules instead, for that function
call only.
</DL>
<A NAME="lbAE">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAM"></A>
<I><A HREF="/manpages/index.html?1+dirname">dirname</A></I>(1), <I><A HREF="http://localhost/cgi-bin/man/man2html?1+basename">basename</A></I>(1), File::Spec
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:27 GMT, December 24, 2015
</div></div>
</body>
</HTML>
