<!DOCTYPE html>

<HTML><head><TITLE>Manpage of BIO_f_ssl</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/manpages/index.html">linux man pages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>BIO_f_ssl</H1>
Section: OpenSSL (3)<BR>Updated: 2009-06-25<BR><A HREF="#index">Index</A>
<A HREF="/manpages/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

BIO_f_ssl, BIO_set_ssl, BIO_get_ssl, BIO_set_ssl_mode, BIO_set_ssl_renegotiate_bytes,
BIO_get_num_renegotiates, BIO_set_ssl_renegotiate_timeout, BIO_new_ssl,
BIO_new_ssl_connect, BIO_new_buffer_ssl_connect, BIO_ssl_copy_session_id,
BIO_ssl_shutdown - SSL BIO
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
 #include &lt;<A HREF="file:/usr/include/openssl/bio.h">openssl/bio.h</A>&gt;
 #include &lt;<A HREF="file:/usr/include/openssl/ssl.h">openssl/ssl.h</A>&gt;

 BIO_METHOD *BIO_f_ssl(void);

 #define BIO_set_ssl(b,ssl,c)   BIO_ctrl(b,BIO_C_SET_SSL,c,(char *)ssl)
 #define BIO_get_ssl(b,sslp)    BIO_ctrl(b,BIO_C_GET_SSL,0,(char *)sslp)
 #define BIO_set_ssl_mode(b,client)     BIO_ctrl(b,BIO_C_SSL_MODE,client,NULL)
 #define BIO_set_ssl_renegotiate_bytes(b,num) \
        BIO_ctrl(b,BIO_C_SET_SSL_RENEGOTIATE_BYTES,num,NULL);
 #define BIO_set_ssl_renegotiate_timeout(b,seconds) \
        BIO_ctrl(b,BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT,seconds,NULL);
 #define BIO_get_num_renegotiates(b) \
        BIO_ctrl(b,BIO_C_SET_SSL_NUM_RENEGOTIATES,0,NULL);

 BIO *BIO_new_ssl(SSL_CTX *ctx,int client);
 BIO *BIO_new_ssl_connect(SSL_CTX *ctx);
 BIO *BIO_new_buffer_ssl_connect(SSL_CTX *ctx);
 int BIO_ssl_copy_session_id(BIO *to,BIO *from);
 void BIO_ssl_shutdown(BIO *bio);

 #define BIO_do_handshake(b)    BIO_ctrl(b,BIO_C_DO_STATE_MACHINE,0,NULL)

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
<I>BIO_f_ssl()</I> returns the <FONT SIZE="-1">SSL</FONT> <FONT SIZE="-1">BIO</FONT> method. This is a filter <FONT SIZE="-1">BIO</FONT> which
is a wrapper round the OpenSSL <FONT SIZE="-1">SSL</FONT> routines adding a <FONT SIZE="-1">BIO</FONT> ``flavour'' to
<FONT SIZE="-1">SSL</FONT> I/O.
<P>

I/O performed on an <FONT SIZE="-1">SSL</FONT> <FONT SIZE="-1">BIO</FONT> communicates using the <FONT SIZE="-1">SSL</FONT> protocol with
the SSLs read and write BIOs. If an <FONT SIZE="-1">SSL</FONT> connection is not established
then an attempt is made to establish one on the first I/O call.
<P>

If a <FONT SIZE="-1">BIO</FONT> is appended to an <FONT SIZE="-1">SSL</FONT> <FONT SIZE="-1">BIO</FONT> using <I>BIO_push()</I> it is automatically
used as the <FONT SIZE="-1">SSL</FONT> BIOs read and write BIOs.
<P>

Calling <I>BIO_reset()</I> on an <FONT SIZE="-1">SSL</FONT> <FONT SIZE="-1">BIO</FONT> closes down any current <FONT SIZE="-1">SSL</FONT> connection
by calling <I>SSL_shutdown()</I>. <I>BIO_reset()</I> is then sent to the next <FONT SIZE="-1">BIO</FONT> in
the chain: this will typically disconnect the underlying transport.
The <FONT SIZE="-1">SSL</FONT> <FONT SIZE="-1">BIO</FONT> is then reset to the initial accept or connect state.
<P>

If the close flag is set when an <FONT SIZE="-1">SSL</FONT> <FONT SIZE="-1">BIO</FONT> is freed then the internal
<FONT SIZE="-1">SSL</FONT> structure is also freed using <I>SSL_free()</I>.
<P>

<I>BIO_set_ssl()</I> sets the internal <FONT SIZE="-1">SSL</FONT> pointer of <FONT SIZE="-1">BIO</FONT> <B>b</B> to <B>ssl</B> using
the close flag <B>c</B>.
<P>

<I>BIO_get_ssl()</I> retrieves the <FONT SIZE="-1">SSL</FONT> pointer of <FONT SIZE="-1">BIO</FONT> <B>b</B>, it can then be
manipulated using the standard <FONT SIZE="-1">SSL</FONT> library functions.
<P>

<I>BIO_set_ssl_mode()</I> sets the <FONT SIZE="-1">SSL</FONT> <FONT SIZE="-1">BIO</FONT> mode to <B>client</B>. If <B>client</B>
is 1 client mode is set. If <B>client</B> is 0 server mode is set.
<P>

<I>BIO_set_ssl_renegotiate_bytes()</I> sets the renegotiate byte count
to <B>num</B>. When set after every <B>num</B> bytes of I/O (read and write) 
the <FONT SIZE="-1">SSL</FONT> session is automatically renegotiated. <B>num</B> must be at
least 512 bytes.
<P>

<I>BIO_set_ssl_renegotiate_timeout()</I> sets the renegotiate timeout to
<B>seconds</B>. When the renegotiate timeout elapses the session is
automatically renegotiated.
<P>

<I>BIO_get_num_renegotiates()</I> returns the total number of session
renegotiations due to I/O or timeout.
<P>

<I>BIO_new_ssl()</I> allocates an <FONT SIZE="-1">SSL</FONT> <FONT SIZE="-1">BIO</FONT> using <FONT SIZE="-1">SSL_CTX</FONT> <B>ctx</B> and using
client mode if <B>client</B> is non zero.
<P>

<I>BIO_new_ssl_connect()</I> creates a new <FONT SIZE="-1">BIO</FONT> chain consisting of an
<FONT SIZE="-1">SSL</FONT> <FONT SIZE="-1">BIO</FONT> (using <B>ctx</B>) followed by a connect <FONT SIZE="-1">BIO</FONT>.
<P>

<I>BIO_new_buffer_ssl_connect()</I> creates a new <FONT SIZE="-1">BIO</FONT> chain consisting
of a buffering <FONT SIZE="-1">BIO</FONT>, an <FONT SIZE="-1">SSL</FONT> <FONT SIZE="-1">BIO</FONT> (using <B>ctx</B>) and a connect
<FONT SIZE="-1">BIO</FONT>.
<P>

<I>BIO_ssl_copy_session_id()</I> copies an <FONT SIZE="-1">SSL</FONT> session id between 
<FONT SIZE="-1">BIO</FONT> chains <B>from</B> and <B>to</B>. It does this by locating the
<FONT SIZE="-1">SSL</FONT> BIOs in each chain and calling <I>SSL_copy_session_id()</I> on
the internal <FONT SIZE="-1">SSL</FONT> pointer.
<P>

<I>BIO_ssl_shutdown()</I> closes down an <FONT SIZE="-1">SSL</FONT> connection on <FONT SIZE="-1">BIO</FONT>
chain <B>bio</B>. It does this by locating the <FONT SIZE="-1">SSL</FONT> <FONT SIZE="-1">BIO</FONT> in the
chain and calling <I>SSL_shutdown()</I> on its internal <FONT SIZE="-1">SSL</FONT>
pointer.
<P>

<I>BIO_do_handshake()</I> attempts to complete an <FONT SIZE="-1">SSL</FONT> handshake on the
supplied <FONT SIZE="-1">BIO</FONT> and establish the <FONT SIZE="-1">SSL</FONT> connection. It returns 1
if the connection was established successfully. A zero or negative
value is returned if the connection could not be established, the
call <I>BIO_should_retry()</I> should be used for non blocking connect BIOs
to determine if the call should be retried. If an <FONT SIZE="-1">SSL</FONT> connection has
already been established this call has no effect.
<A NAME="lbAE">&nbsp;</A>
<H2>NOTES</H2>

<A NAME="ixAAE"></A>
<FONT SIZE="-1">SSL</FONT> BIOs are exceptional in that if the underlying transport
is non blocking they can still request a retry in exceptional
circumstances. Specifically this will happen if a session
renegotiation takes place during a <I>BIO_read()</I> operation, one
case where this happens is when <FONT SIZE="-1">SGC</FONT> or step up occurs.
<P>

In OpenSSL 0.9.6 and later the <FONT SIZE="-1">SSL</FONT> flag <FONT SIZE="-1">SSL_AUTO_RETRY</FONT> can be
set to disable this behaviour. That is when this flag is set
an <FONT SIZE="-1">SSL</FONT> <FONT SIZE="-1">BIO</FONT> using a blocking transport will never request a
retry.
<P>

Since unknown <I>BIO_ctrl()</I> operations are sent through filter
BIOs the servers name and port can be set using <I>BIO_set_host()</I>
on the <FONT SIZE="-1">BIO</FONT> returned by <I>BIO_new_ssl_connect()</I> without having
to locate the connect <FONT SIZE="-1">BIO</FONT> first.
<P>

Applications do not have to call <I>BIO_do_handshake()</I> but may wish
to do so to separate the handshake process from other I/O
processing.
<A NAME="lbAF">&nbsp;</A>
<H2>RETURN VALUES</H2>

<A NAME="ixAAF"></A>
<FONT SIZE="-1">TBA</FONT>
<A NAME="lbAG">&nbsp;</A>
<H2>EXAMPLE</H2>

<A NAME="ixAAG"></A>
This <FONT SIZE="-1">SSL/TLS</FONT> client example, attempts to retrieve a page from an
<FONT SIZE="-1">SSL/TLS</FONT> web server. The I/O routines are identical to those of the
unencrypted example in <I><A HREF="/manpages/index.html?3+BIO_s_connect">BIO_s_connect</A></I>(3).
<P>



<PRE>
 BIO *sbio, *out;
 int len;
 char tmpbuf[1024];
 SSL_CTX *ctx;
 SSL *ssl;

 ERR_load_crypto_strings();
 ERR_load_SSL_strings();
 OpenSSL_add_all_algorithms();

 /* We would seed the PRNG here if the platform didn't
  * do it automatically
  */

 ctx = SSL_CTX_new(SSLv23_client_method());

 /* We'd normally set some stuff like the verify paths and
  * mode here because as things stand this will connect to
  * any server whose certificate is signed by any CA.
  */

 sbio = BIO_new_ssl_connect(ctx);

 BIO_get_ssl(sbio, &amp;ssl);

 if(!ssl) {
   fprintf(stderr, &quot;Can't locate SSL pointer\n&quot;);
   /* whatever ... */
 }

 /* Don't want any retries */
 SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);

 /* We might want to do other things with ssl here */

 BIO_set_conn_hostname(sbio, &quot;localhost:https&quot;);

 out = BIO_new_fp(stdout, BIO_NOCLOSE);
 if(BIO_do_connect(sbio) &lt;= 0) {
        fprintf(stderr, &quot;Error connecting to server\n&quot;);
        ERR_print_errors_fp(stderr);
        /* whatever ... */
 }

 if(BIO_do_handshake(sbio) &lt;= 0) {
        fprintf(stderr, &quot;Error establishing SSL connection\n&quot;);
        ERR_print_errors_fp(stderr);
        /* whatever ... */
 }

 /* Could examine ssl here to get connection info */

 BIO_puts(sbio, &quot;GET / HTTP/1.0\n\n&quot;);
 for(;;) {      
        len = BIO_read(sbio, tmpbuf, 1024);
        if(len &lt;= 0) break;
        BIO_write(out, tmpbuf, len);
 }
 BIO_free_all(sbio);
 BIO_free(out);

</PRE>


<P>

Here is a simple server example. It makes use of a buffering
<FONT SIZE="-1">BIO</FONT> to allow lines to be read from the <FONT SIZE="-1">SSL</FONT> <FONT SIZE="-1">BIO</FONT> using BIO_gets.
It creates a pseudo web page containing the actual request from
a client and also echoes the request to standard output.
<P>



<PRE>
 BIO *sbio, *bbio, *acpt, *out;
 int len;
 char tmpbuf[1024];
 SSL_CTX *ctx;
 SSL *ssl;

 ERR_load_crypto_strings();
 ERR_load_SSL_strings();
 OpenSSL_add_all_algorithms();

 /* Might seed PRNG here */

 ctx = SSL_CTX_new(SSLv23_server_method());

 if (!SSL_CTX_use_certificate_file(ctx,&quot;server.pem&quot;,SSL_FILETYPE_PEM)
        || !SSL_CTX_use_PrivateKey_file(ctx,&quot;server.pem&quot;,SSL_FILETYPE_PEM)
        || !SSL_CTX_check_private_key(ctx)) {

        fprintf(stderr, &quot;Error setting up SSL_CTX\n&quot;);
        ERR_print_errors_fp(stderr);
        return 0;
 }

 /* Might do other things here like setting verify locations and
  * DH and/or RSA temporary key callbacks
  */

 /* New SSL BIO setup as server */
 sbio=BIO_new_ssl(ctx,0);

 BIO_get_ssl(sbio, &amp;ssl);

 if(!ssl) {
   fprintf(stderr, &quot;Can't locate SSL pointer\n&quot;);
   /* whatever ... */
 }

 /* Don't want any retries */
 SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);

 /* Create the buffering BIO */

 bbio = BIO_new(BIO_f_buffer());

 /* Add to chain */
 sbio = BIO_push(bbio, sbio);

 acpt=BIO_new_accept(&quot;4433&quot;);

 /* By doing this when a new connection is established
  * we automatically have sbio inserted into it. The
  * BIO chain is now 'swallowed' by the accept BIO and
  * will be freed when the accept BIO is freed. 
  */
 
 BIO_set_accept_bios(acpt,sbio);

 out = BIO_new_fp(stdout, BIO_NOCLOSE);

 /* Setup accept BIO */
 if(BIO_do_accept(acpt) &lt;= 0) {
        fprintf(stderr, &quot;Error setting up accept BIO\n&quot;);
        ERR_print_errors_fp(stderr);
        return 0;
 }

 /* Now wait for incoming connection */
 if(BIO_do_accept(acpt) &lt;= 0) {
        fprintf(stderr, &quot;Error in connection\n&quot;);
        ERR_print_errors_fp(stderr);
        return 0;
 }

 /* We only want one connection so remove and free
  * accept BIO
  */

 sbio = BIO_pop(acpt);

 BIO_free_all(acpt);

 if(BIO_do_handshake(sbio) &lt;= 0) {
        fprintf(stderr, &quot;Error in SSL handshake\n&quot;);
        ERR_print_errors_fp(stderr);
        return 0;
 }

 BIO_puts(sbio, &quot;HTTP/1.0 200 OK\r\nContent-type: text/plain\r\n\r\n&quot;);
 BIO_puts(sbio, &quot;\r\nConnection Established\r\nRequest headers:\r\n&quot;);
 BIO_puts(sbio, &quot;--------------------------------------------------\r\n&quot;);

 for(;;) {
        len = BIO_gets(sbio, tmpbuf, 1024);
        if(len &lt;= 0) break;
        BIO_write(sbio, tmpbuf, len);
        BIO_write(out, tmpbuf, len);
        /* Look for blank line signifying end of headers*/
        if((tmpbuf[0] == '\r') || (tmpbuf[0] == '\n')) break;
 }

 BIO_puts(sbio, &quot;--------------------------------------------------\r\n&quot;);
 BIO_puts(sbio, &quot;\r\n&quot;);

 /* Since there is a buffering BIO present we had better flush it */
 BIO_flush(sbio);

 BIO_free_all(sbio);

</PRE>


<A NAME="lbAH">&nbsp;</A>
<H2>BUGS</H2>

<A NAME="ixAAH"></A>
In OpenSSL versions before 1.0.0 the <I>BIO_pop()</I> call was handled incorrectly,
the I/O <FONT SIZE="-1">BIO</FONT> reference count was incorrectly incremented (instead of
decremented) and dissociated with the <FONT SIZE="-1">SSL</FONT> <FONT SIZE="-1">BIO</FONT> even if the <FONT SIZE="-1">SSL</FONT> <FONT SIZE="-1">BIO</FONT> was not
explicitly being popped (e.g. a pop higher up the chain). Applications which
included workarounds for this bug (e.g. freeing BIOs more than once) should
be modified to handle this fix or they may free up an already freed <FONT SIZE="-1">BIO</FONT>.
<A NAME="lbAI">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAI"></A>
<FONT SIZE="-1">TBA</FONT>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">NOTES</A><DD>
<DT><A HREF="#lbAF">RETURN VALUES</A><DD>
<DT><A HREF="#lbAG">EXAMPLE</A><DD>
<DT><A HREF="#lbAH">BUGS</A><DD>
<DT><A HREF="#lbAI">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/manpages/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:13 GMT, December 24, 2015
</div></body>
</HTML>
