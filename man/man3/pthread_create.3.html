<!DOCTYPE html>

<HTML><head><TITLE>Manpage of PTHREAD_CREATE</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/man/index.html">linux man pages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>PTHREAD_CREATE</H1>
Section: Linux Programmer's Manual (3)<BR>Updated: 2008-11-11<BR><A HREF="#index">Index</A>
<A HREF="/man/index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

pthread_create - create a new thread
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<PRE>
<B>#include &lt;<A HREF="file:/usr/include/pthread.h">pthread.h</A>&gt;</B>

<B>int pthread_create(pthread_t *</B><I>thread</I><B>, const pthread_attr_t *</B><I>attr</I><B>,</B>
<B>                   void *(*</B><I>start_routine</I><B>) (void *), void *</B><I>arg</I><B>);</B>
</PRE>

<P>
Compile and link with <I>-pthread</I>.
<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

The
<B>pthread_create</B>()

function starts a new thread in the calling process.
The new thread starts execution by invoking
<I>start_routine</I>();

<I>arg</I>

is passed as the sole argument of
<I>start_routine</I>().

<P>
The new thread terminates in one of the following ways:
<DL COMPACT>
<DT>*<DD>
It calls
<B><A HREF="/man/index.html?3+pthread_exit">pthread_exit</A></B>(3),

specifying an exit status value that is available to another thread
in the same process that calls
<B><A HREF="/man/index.html?3+pthread_join">pthread_join</A></B>(3).

<DT>*<DD>
It returns from
<I>start_routine</I>().

This is equivalent to calling
<B><A HREF="/man/index.html?3+pthread_exit">pthread_exit</A></B>(3)

with the value supplied in the
<I>return</I>

statement.
<DT>*<DD>
It is canceled (see
<B><A HREF="/man/index.html?3+pthread_cancel">pthread_cancel</A></B>(3)).

<DT>*<DD>
Any of the threads in the process calls
<B><A HREF="/man/index.html?3+exit">exit</A></B>(3),

or the main thread performs a return from
<I>main</I>().

This causes the termination of all threads in the process.
</DL>
<P>

The
<I>attr</I>

argument points to a
<I>pthread_attr_t</I>

structure whose contents are used at thread creation time to
determine attributes for the new thread;
this structure is initialized using
<B><A HREF="/man/index.html?3+pthread_attr_init">pthread_attr_init</A></B>(3)

and related functions.
If
<I>attr</I>

is NULL,
then the thread is created with default attributes.
<P>
Before returning, a successful call to
<B>pthread_create</B>()

stores the ID of the new thread in the buffer pointed to by
<I>thread</I>;

this identifier is used to refer to the thread
in subsequent calls to other pthreads functions.
<P>
The new thread inherits a copy of the creating thread's signal mask
(<B><A HREF="/man/index.html?3+pthread_sigmask">pthread_sigmask</A></B>(3)).

The set of pending signals for the new thread is empty
(<B><A HREF="/man/index.html?2+sigpending">sigpending</A></B>(2)).

The new thread does not inherit the creating thread's
alternate signal stack
(<B><A HREF="/man/index.html?2+sigaltstack">sigaltstack</A></B>(2)).

<P>
The new thread inherits the calling thread's floating-point environment
(<B><A HREF="/man/index.html?3+fenv">fenv</A></B>(3)).

<P>
The initial value of the new thread's CPU-time clock is 0
(see
<B><A HREF="/man/index.html?3+pthread_getcpuclockid">pthread_getcpuclockid</A></B>(3)).


<A NAME="lbAE">&nbsp;</A>
<H3>Linux-specific details</H3>

The new thread inherits copies of the calling thread's capability sets
(see
<B><A HREF="/man/index.html?7+capabilities">capabilities</A></B>(7))

and CPU affinity mask (see
<B><A HREF="/man/index.html?2+sched_setaffinity">sched_setaffinity</A></B>(2)).

<A NAME="lbAF">&nbsp;</A>
<H2>RETURN VALUE</H2>

On success,
<B>pthread_create</B>()

returns 0;
on error, it returns an error number, and the contents of
<I>*thread</I>

are undefined.
<A NAME="lbAG">&nbsp;</A>
<H2>ERRORS</H2>

<DL COMPACT>
<DT><B>EAGAIN</B>

<DD>
Insufficient resources to create another thread,
or a system-imposed limit on the number of threads was encountered.
The latter case may occur in two ways:
the
<B>RLIMIT_NPROC</B>

soft resource limit (set via
<B><A HREF="/man/index.html?2+setrlimit">setrlimit</A></B>(2)),

which limits the number of process for a real user ID,
was reached;
or the kernel's system-wide limit on the number of threads,
<I>/proc/sys/kernel/threads-max</I>,

was reached.
<DT><B>EINVAL</B>

<DD>
Invalid settings in
<I>attr</I>.

<DT>
<DD>
<B>EPERM</B>

No permission to set the scheduling policy and parameters specified in
<I>attr</I>.

</DL>
<A NAME="lbAH">&nbsp;</A>
<H2>CONFORMING TO</H2>

POSIX.1-2001.
<A NAME="lbAI">&nbsp;</A>
<H2>NOTES</H2>

See
<B><A HREF="/man/index.html?3+pthread_self">pthread_self</A></B>(3)

for further information on the thread ID returned in
<I>*thread</I>

by
<B>pthread_create</B>().

Unless real-time scheduling policies are being employed,
after a call to
<B>pthread_create</B>(),

it is indeterminate which thread---the caller or the new thread---will
next execute.
<P>
A thread may either be
<I>joinable</I>

or
<I>detached</I>.

If a thread is joinable, then another thread can call
<B><A HREF="/man/index.html?3+pthread_join">pthread_join</A></B>(3)

to wait for the thread to terminate and fetch its exit status.
Only when a terminated joinable thread has been joined are
the last of its resources released back to the system.
When a detached thread terminates,
its resources are automatically released back to the system:
it is not possible to join with the thread in order to obtain
its exit status.
Making a thread detached is useful for some types of daemon threads
whose exit status the application does not need to care about.
By default, a new thread is created in a joinable state, unless
<I>attr</I>

was set to create the thread in a detached state (using
<B><A HREF="/man/index.html?3+pthread_attr_setdetachstate">pthread_attr_setdetachstate</A></B>(3)).

<P>


On Linux/x86-32, the default stack size for a new thread is 2 megabytes.
Under the NPTL threading implementation, if the
<B>RLIMIT_STACK</B>

soft resource limit
<I>at the time the program started</I>

has any value other than &quot;unlimited&quot;,
then it determines the default stack size of new threads.
Using
<B><A HREF="/man/index.html?3+pthread_attr_setstacksize">pthread_attr_setstacksize</A></B>(3),

the stack size attribute can be explicitly set in the
<I>attr</I>

argument used to create a thread,
in order to obtain a stack size other than the default.
<A NAME="lbAJ">&nbsp;</A>
<H2>EXAMPLE</H2>

The program below demonstrates the use of
<B>pthread_create</B>(),

as well as a number of other functions in the pthreads API.
<P>
In the following run,
on a system providing the NPTL threading implementation,
the stack size defaults to the value given by the
&quot;stack size&quot; resource limit:
<P>

<PRE>
$<B> ulimit -s</B>
8192            # The stack size limit is 8 MB (0x80000 bytes)
$<B> ./a.out hola salut servus</B>
Thread 1: top of stack near 0xb7dd03b8; argv_string=hola
Thread 2: top of stack near 0xb75cf3b8; argv_string=salut
Thread 3: top of stack near 0xb6dce3b8; argv_string=servus
Joined with thread 1; returned value was HOLA
Joined with thread 2; returned value was SALUT
Joined with thread 3; returned value was SERVUS
</PRE>


<P>
In the next run, the program explicitly sets a stack size of 1MB (using
<B><A HREF="/man/index.html?3+pthread_attr_setstacksize">pthread_attr_setstacksize</A></B>(3))

for the created threads:
<P>

<PRE>
$<B> ./a.out -s 0x100000 hola salut servus</B>
Thread 1: top of stack near 0xb7d723b8; argv_string=hola
Thread 2: top of stack near 0xb7c713b8; argv_string=salut
Thread 3: top of stack near 0xb7b703b8; argv_string=servus
Joined with thread 1; returned value was HOLA
Joined with thread 2; returned value was SALUT
Joined with thread 3; returned value was SERVUS
</PRE>


<A NAME="lbAK">&nbsp;</A>
<H3>Program source</H3>


<PRE>
#include &lt;<A HREF="file:/usr/include/pthread.h">pthread.h</A>&gt;
#include &lt;<A HREF="file:/usr/include/string.h">string.h</A>&gt;
#include &lt;<A HREF="file:/usr/include/stdio.h">stdio.h</A>&gt;
#include &lt;<A HREF="file:/usr/include/stdlib.h">stdlib.h</A>&gt;
#include &lt;<A HREF="file:/usr/include/unistd.h">unistd.h</A>&gt;
#include &lt;<A HREF="file:/usr/include/errno.h">errno.h</A>&gt;
#include &lt;<A HREF="file:/usr/include/ctype.h">ctype.h</A>&gt;

#define handle_error_en(en, msg) \
        do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

#define handle_error(msg) \
        do { perror(msg); exit(EXIT_FAILURE); } while (0)

struct thread_info {    /* Used as argument to thread_start() */
    pthread_t thread_id;        /* ID returned by pthread_create() */
    int       thread_num;       /* Application-defined thread # */
    char     *argv_string;      /* From command-line argument */
};

/* Thread start function: display address near top of our stack,
   and return upper-cased copy of argv_string */

static void *
thread_start(void *arg)
{
    struct thread_info *tinfo = (struct thread_info *) arg;
    char *uargv, *p;

    printf(&quot;Thread %d: top of stack near %p; argv_string=%s\n&quot;,
            tinfo-&gt;thread_num, &amp;p, tinfo-&gt;argv_string);

    uargv = strdup(tinfo-&gt;argv_string);
    if (uargv == NULL)
        handle_error(&quot;strdup&quot;);

    for (p = uargv; *p != aq\0aq; p++)
        *p = toupper(*p);

    return uargv;
}

int
main(int argc, char *argv[])
{
    int s, tnum, opt, num_threads;
    struct thread_info *tinfo;
    pthread_attr_t attr;
    int stack_size;
    void *res;

    /* The &quot;-s&quot; option specifies a stack size for our threads */

    stack_size = -1;
    while ((opt = getopt(argc, argv, &quot;s:&quot;)) != -1) {
        switch (opt) {
        case aqsaq:
            stack_size = strtoul(optarg, NULL, 0);
            break;

        default:
            fprintf(stderr, &quot;Usage: %s [-s stack-size] arg...\n&quot;,
                    argv[0]);
            exit(EXIT_FAILURE);
        }
    }

    num_threads = argc - optind;

    /* Initialize thread creation attributes */

    s = pthread_attr_init(&amp;attr);
    if (s != 0)
        handle_error_en(s, &quot;pthread_attr_init&quot;);

    if (stack_size &gt; 0) {
        s = pthread_attr_setstacksize(&amp;attr, stack_size);
        if (s != 0)
            handle_error_en(s, &quot;pthread_attr_setstacksize&quot;);
    }

    /* Allocate memory for pthread_create() arguments */

    tinfo = calloc(num_threads, sizeof(struct thread_info));
    if (tinfo == NULL)
        handle_error(&quot;calloc&quot;);

    /* Create one thread for each command-line argument */

    for (tnum = 0; tnum &lt; num_threads; tnum++) {
        tinfo[tnum].thread_num = tnum + 1;
        tinfo[tnum].argv_string = argv[optind + tnum];

        /* The pthread_create() call stores the thread ID into
           corresponding element of tinfo[] */

        s = pthread_create(&amp;tinfo[tnum].thread_id, &amp;attr,
                           &amp;thread_start, &amp;tinfo[tnum]);
        if (s != 0)
            handle_error_en(s, &quot;pthread_create&quot;);
    }

    /* Destroy the thread attributes object, since it is no
       longer needed */

    s = pthread_attr_destroy(&amp;attr);
    if (s != 0)
        handle_error_en(s, &quot;pthread_attr_destroy&quot;);

    /* Now join with each thread, and display its returned value */

    for (tnum = 0; tnum &lt; num_threads; tnum++) {
        s = pthread_join(tinfo[tnum].thread_id, &amp;res);
        if (s != 0)
            handle_error_en(s, &quot;pthread_join&quot;);

        printf(&quot;Joined with thread %d; returned value was %s\n&quot;,
                tinfo[tnum].thread_num, (char *) res);
        free(res);      /* Free memory allocated by thread */
    }

    free(tinfo);
    exit(EXIT_SUCCESS);
}
</PRE>

<A NAME="lbAL">&nbsp;</A>
<H2>BUGS</H2>

In the obsolete LinuxThreads implementation,
each of the threads in a process has a different process ID.
This is in violation of the POSIX threads specification,
and is the source of many other non-conformances to the standard; see
<B><A HREF="/man/index.html?7+pthreads">pthreads</A></B>(7).

<A NAME="lbAM">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="/man/index.html?2+getrlimit">getrlimit</A></B>(2),

<B><A HREF="/man/index.html?3+pthread_attr_init">pthread_attr_init</A></B>(3),

<B><A HREF="/man/index.html?3+pthread_cancel">pthread_cancel</A></B>(3),

<B><A HREF="/man/index.html?3+pthread_detach">pthread_detach</A></B>(3),

<B><A HREF="/man/index.html?3+pthread_equal">pthread_equal</A></B>(3),

<B><A HREF="/man/index.html?3+pthread_exit">pthread_exit</A></B>(3),

<B><A HREF="/man/index.html?3+pthread_getattr_np">pthread_getattr_np</A></B>(3),

<B><A HREF="/man/index.html?3+pthread_join">pthread_join</A></B>(3),

<B><A HREF="/man/index.html?3+pthread_self">pthread_self</A></B>(3),

<B><A HREF="/man/index.html?7+pthreads">pthreads</A></B>(7)

<A NAME="lbAN">&nbsp;</A>
<H2>COLOPHON</H2>

This page is part of release 3.22 of the Linux
<I>man-pages</I>

project.
A description of the project,
and information about reporting bugs,
can be found at
<A HREF="http://www.kernel.org/doc/man-pages/.">http://www.kernel.org/doc/man-pages/.</A>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE">Linux-specific details</A><DD>
</DL>
<DT><A HREF="#lbAF">RETURN VALUE</A><DD>
<DT><A HREF="#lbAG">ERRORS</A><DD>
<DT><A HREF="#lbAH">CONFORMING TO</A><DD>
<DT><A HREF="#lbAI">NOTES</A><DD>
<DT><A HREF="#lbAJ">EXAMPLE</A><DD>
<DL>
<DT><A HREF="#lbAK">Program source</A><DD>
</DL>
<DT><A HREF="#lbAL">BUGS</A><DD>
<DT><A HREF="#lbAM">SEE ALSO</A><DD>
<DT><A HREF="#lbAN">COLOPHON</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/man/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:37 GMT, December 24, 2015
</div></body>
</HTML>
