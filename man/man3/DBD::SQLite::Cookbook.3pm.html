<!DOCTYPE html>

<HTML><head><TITLE>Manpage of DBD::SQLite::Cookbook</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/man/index.html">linux man pages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>DBD::SQLite::Cookbook</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2009-11-23<BR><A HREF="#index">Index</A>
<A HREF="/man/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

DBD::SQLite::Cookbook - The DBD::SQLite Cookbook
<A NAME="lbAC">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAC"></A>
This is the DBD::SQLite cookbook.
<P>

It is intended to provide a place to keep a variety of functions and
formals for use in callback APIs in DBD::SQLite.
<A NAME="lbAD">&nbsp;</A>
<H3>Variance</H3>

<A NAME="ixAAD"></A>
This is a simple aggregate function which returns a variance. It is
adapted from an example implementation in pysqlite.
<P>



<PRE>
  package variance;
  
  sub new { bless [], shift; }
  
  sub step {
      my ( $self, $value ) = @_;
  
      push @$self, $value;
  }
  
  sub finalize {
      my $self = $_[0];
  
      my $n = @$self;
  
      # Variance is NULL unless there is more than one row
      return undef unless $n || $n == 1;
  
      my $mu = 0;
      foreach my $v ( @$self ) {
          $mu += $v;
      }
      $mu /= $n;
  
      my $sigma = 0;
      foreach my $v ( @$self ) {
          $sigma += ($x - $mu)**2;
      }
      $sigma = $sigma / ($n - 1);
  
      return $sigma;
  }
  
  # NOTE: If you use an older DBI (&lt; 1.608),
  # use $dbh-&gt;func(..., &quot;create_aggregate&quot;) instead.
  $dbh-&gt;sqlite_create_aggregate( &quot;variance&quot;, 1, 'variance' );

</PRE>


<P>

The function can then be used as:
<P>



<PRE>
  SELECT group_name, variance(score)
  FROM results
  GROUP BY group_name;

</PRE>


<A NAME="lbAE">&nbsp;</A>
<H3>Variance (Memory Efficient)</H3>

<A NAME="ixAAE"></A>
A more efficient variance function, optimized for memory usage at the
expense of precision:
<P>



<PRE>
  package variance2;
  
  my $sum   = 0;
  my $count = 0;
  my %hash;
  
  sub new { bless [], shift; }
  
  sub step {
      my ( $self, $value ) = @_;
  
      # by truncating and hashing, we can comsume many more data points
      $value = int($value); # change depending on need for precision
                            # use sprintf for arbitrary fp precision
      if (defined $hash{$value}) {
          $hash{$value}++;
      } else {
          $hash{$value} = 1;
      }
      $sum += $value;
      $count++;
  }
  
  sub finalize {
      my $self = $_[0];
  
      # Variance is NULL unless there is more than one row
      return undef unless $count &gt; 1;
  
      # calculate avg
      my $mu = $sum / $count;
  
      my $sigma = 0;
      foreach my $h (keys %hash) {
          $sigma += (($h - $mu)**2) * $hash{$h};
      }
      $sigma = $sigma / ($count - 1);
  
      return $sigma;
  }

</PRE>


<P>

The function can then be used as:
<P>



<PRE>
  SELECT group_name, variance2(score)
  FROM results
  GROUP BY group_name;

</PRE>


<A NAME="lbAF">&nbsp;</A>
<H3>Variance (Highly Scalable)</H3>

<A NAME="ixAAF"></A>
A third variable implementation, designed for arbitrarily large data sets:
<P>



<PRE>
  package variance;
  
  my $mu = 0;
  my $count = 0;
  my $S = 0
  
  sub new { bless [], shift; }
  
  sub step {
      my ( $self, $value ) = @_;
      $count++;
      $delta = $value - $mu;
      $mu = $mu + $delta/$count
      $S = $S + $delta*($value - $mu);
  }
  
  sub finalize {
      my $self = $_[0];
      return $S / ($count - 1);
  }

</PRE>


<P>

The function can then be used as:
<P>



<PRE>
  SELECT group_name, variance3(score)
  FROM results
  GROUP BY group_name;

</PRE>


<A NAME="lbAG">&nbsp;</A>
<H2>SUPPORT</H2>

<A NAME="ixAAG"></A>
Bugs should be reported via the <FONT SIZE="-1">CPAN</FONT> bug tracker at
<P>

&lt;<A HREF="http://rt.cpan.org/NoAuth/ReportBug.html?Queue=DBD-SQLite">http://rt.cpan.org/NoAuth/ReportBug.html?Queue=DBD-SQLite</A>&gt;
<A NAME="lbAH">&nbsp;</A>
<H2>TO DO</H2>

<A NAME="ixAAH"></A>
* Add more and varied cookbook recipes, until we have enough to
turn them into a seperate <FONT SIZE="-1">CPAN</FONT> distribution.
<P>

* Create a series of tests scripts that validate the cookbook recipies.
<A NAME="lbAI">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixAAI"></A>
Adam Kennedy &lt;<A HREF="mailto:adamk@cpan.org">adamk@cpan.org</A>&gt;
<A NAME="lbAJ">&nbsp;</A>
<H2>COPYRIGHT</H2>

<A NAME="ixAAJ"></A>
Copyright 2009 Adam Kennedy.
<P>

This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
<P>

The full text of the license can be found in the
<FONT SIZE="-1">LICENSE</FONT> file included with this module.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAD">Variance</A><DD>
<DT><A HREF="#lbAE">Variance (Memory Efficient)</A><DD>
<DT><A HREF="#lbAF">Variance (Highly Scalable)</A><DD>
</DL>
<DT><A HREF="#lbAG">SUPPORT</A><DD>
<DT><A HREF="#lbAH">TO DO</A><DD>
<DT><A HREF="#lbAI">AUTHOR</A><DD>
<DT><A HREF="#lbAJ">COPYRIGHT</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/man/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:22 GMT, December 24, 2015
</div></body>
</HTML>
