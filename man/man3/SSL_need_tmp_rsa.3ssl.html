<!DOCTYPE html>

<HTML><head><TITLE>Manpage of SSL_CTX_set_tmp_rsa_callback</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/man/index.html">linux man pages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>SSL_CTX_set_tmp_rsa_callback</H1>
Section: OpenSSL (3)<BR>Updated: 2006-12-06<BR><A HREF="#index">Index</A>
<A HREF="/man/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

SSL_CTX_set_tmp_rsa_callback, SSL_CTX_set_tmp_rsa, SSL_CTX_need_tmp_rsa, SSL_set_tmp_rsa_callback, SSL_set_tmp_rsa, SSL_need_tmp_rsa - handle RSA keys for ephemeral key exchange
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
 #include &lt;<A HREF="file:/usr/include/openssl/ssl.h">openssl/ssl.h</A>&gt;

 void SSL_CTX_set_tmp_rsa_callback(SSL_CTX *ctx,
            RSA *(*tmp_rsa_callback)(SSL *ssl, int is_export, int keylength));
 long SSL_CTX_set_tmp_rsa(SSL_CTX *ctx, RSA *rsa);
 long SSL_CTX_need_tmp_rsa(SSL_CTX *ctx);

 void SSL_set_tmp_rsa_callback(SSL_CTX *ctx,
            RSA *(*tmp_rsa_callback)(SSL *ssl, int is_export, int keylength));
 long SSL_set_tmp_rsa(SSL *ssl, RSA *rsa)
 long SSL_need_tmp_rsa(SSL *ssl)

 RSA *(*tmp_rsa_callback)(SSL *ssl, int is_export, int keylength);

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
<I>SSL_CTX_set_tmp_rsa_callback()</I> sets the callback function for <B>ctx</B> to be
used when a temporary/ephemeral <FONT SIZE="-1">RSA</FONT> key is required to <B>tmp_rsa_callback</B>.
The callback is inherited by all <FONT SIZE="-1">SSL</FONT> objects newly created from <B>ctx</B>
with &lt;<I><A HREF="/man/index.html?3+SSL_new">SSL_new</A></I>(3)|<I><A HREF="http://localhost/cgi-bin/man/man2html?3+SSL_new">SSL_new</A></I>(3)&gt;. Already created <FONT SIZE="-1">SSL</FONT> objects are not affected.
<P>

<I>SSL_CTX_set_tmp_rsa()</I> sets the temporary/ephemeral <FONT SIZE="-1">RSA</FONT> key to be used to be
<B>rsa</B>. The key is inherited by all <FONT SIZE="-1">SSL</FONT> objects newly created from <B>ctx</B>
with &lt;<I><A HREF="/man/index.html?3+SSL_new">SSL_new</A></I>(3)|<I><A HREF="http://localhost/cgi-bin/man/man2html?3+SSL_new">SSL_new</A></I>(3)&gt;. Already created <FONT SIZE="-1">SSL</FONT> objects are not affected.
<P>

<I>SSL_CTX_need_tmp_rsa()</I> returns 1, if a temporary/ephemeral <FONT SIZE="-1">RSA</FONT> key is needed
for RSA-based strength-limited 'exportable' ciphersuites because a <FONT SIZE="-1">RSA</FONT> key
with a keysize larger than 512 bits is installed.
<P>

<I>SSL_set_tmp_rsa_callback()</I> sets the callback only for <B>ssl</B>.
<P>

<I>SSL_set_tmp_rsa()</I> sets the key only for <B>ssl</B>.
<P>

<I>SSL_need_tmp_rsa()</I> returns 1, if a temporary/ephemeral <FONT SIZE="-1">RSA</FONT> key is needed,
for RSA-based strength-limited 'exportable' ciphersuites because a <FONT SIZE="-1">RSA</FONT> key
with a keysize larger than 512 bits is installed.
<P>

These functions apply to <FONT SIZE="-1">SSL/TLS</FONT> servers only.
<A NAME="lbAE">&nbsp;</A>
<H2>NOTES</H2>

<A NAME="ixAAE"></A>
When using a cipher with <FONT SIZE="-1">RSA</FONT> authentication, an ephemeral <FONT SIZE="-1">RSA</FONT> key exchange
can take place. In this case the session data are negotiated using the
ephemeral/temporary <FONT SIZE="-1">RSA</FONT> key and the <FONT SIZE="-1">RSA</FONT> key supplied and certified
by the certificate chain is only used for signing.
<P>

Under previous export restrictions, ciphers with <FONT SIZE="-1">RSA</FONT> keys shorter (512 bits)
than the usual key length of 1024 bits were created. To use these ciphers
with <FONT SIZE="-1">RSA</FONT> keys of usual length, an ephemeral key exchange must be performed,
as the normal (certified) key cannot be directly used.
<P>

Using ephemeral <FONT SIZE="-1">RSA</FONT> key exchange yields forward secrecy, as the connection
can only be decrypted, when the <FONT SIZE="-1">RSA</FONT> key is known. By generating a temporary
<FONT SIZE="-1">RSA</FONT> key inside the server application that is lost when the application
is left, it becomes impossible for an attacker to decrypt past sessions,
even if he gets hold of the normal (certified) <FONT SIZE="-1">RSA</FONT> key, as this key was
used for signing only. The downside is that creating a <FONT SIZE="-1">RSA</FONT> key is
computationally expensive.
<P>

Additionally, the use of ephemeral <FONT SIZE="-1">RSA</FONT> key exchange is only allowed in
the <FONT SIZE="-1">TLS</FONT> standard, when the <FONT SIZE="-1">RSA</FONT> key can be used for signing only, that is
for export ciphers. Using ephemeral <FONT SIZE="-1">RSA</FONT> key exchange for other purposes
violates the standard and can break interoperability with clients.
It is therefore strongly recommended to not use ephemeral <FONT SIZE="-1">RSA</FONT> key
exchange and use <FONT SIZE="-1">EDH</FONT> (Ephemeral Diffie-Hellman) key exchange instead
in order to achieve forward secrecy (see
<I><A HREF="/man/index.html?3+SSL_CTX_set_tmp_dh_callback">SSL_CTX_set_tmp_dh_callback</A></I>(3)).
<P>

On OpenSSL servers ephemeral <FONT SIZE="-1">RSA</FONT> key exchange is therefore disabled by default
and must be explicitly enabled  using the <FONT SIZE="-1">SSL_OP_EPHEMERAL_RSA</FONT> option of
<I><A HREF="/man/index.html?3+SSL_CTX_set_options">SSL_CTX_set_options</A></I>(3), violating the <FONT SIZE="-1">TLS/SSL</FONT>
standard. When ephemeral <FONT SIZE="-1">RSA</FONT> key exchange is required for export ciphers,
it will automatically be used without this option!
<P>

An application may either directly specify the key or can supply the key via
a callback function. The callback approach has the advantage, that the
callback may generate the key only in case it is actually needed. As the
generation of a <FONT SIZE="-1">RSA</FONT> key is however costly, it will lead to a significant
delay in the handshake procedure.  Another advantage of the callback function
is that it can supply keys of different size (e.g. for <FONT SIZE="-1">SSL_OP_EPHEMERAL_RSA</FONT>
usage) while the explicit setting of the key is only useful for key size of
512 bits to satisfy the export restricted ciphers and does give away key length
if a longer key would be allowed.
<P>

The <B>tmp_rsa_callback</B> is called with the <B>keylength</B> needed and
the <B>is_export</B> information. The <B>is_export</B> flag is set, when the
ephemeral <FONT SIZE="-1">RSA</FONT> key exchange is performed with an export cipher.
<A NAME="lbAF">&nbsp;</A>
<H2>EXAMPLES</H2>

<A NAME="ixAAF"></A>
Generate temporary <FONT SIZE="-1">RSA</FONT> keys to prepare ephemeral <FONT SIZE="-1">RSA</FONT> key exchange. As the
generation of a <FONT SIZE="-1">RSA</FONT> key costs a lot of computer time, they saved for later
reuse. For demonstration purposes, two keys for 512 bits and 1024 bits
respectively are generated.
<P>



<PRE>
 ...
 /* Set up ephemeral RSA stuff */
 RSA *rsa_512 = NULL;
 RSA *rsa_1024 = NULL;

 rsa_512 = RSA_generate_key(512,RSA_F4,NULL,NULL);
 if (rsa_512 == NULL)
     evaluate_error_queue();

 rsa_1024 = RSA_generate_key(1024,RSA_F4,NULL,NULL);
 if (rsa_1024 == NULL)
   evaluate_error_queue();

 ...

 RSA *tmp_rsa_callback(SSL *s, int is_export, int keylength)
 {
    RSA *rsa_tmp=NULL;

    switch (keylength) {
    case 512:
      if (rsa_512)
        rsa_tmp = rsa_512;
      else { /* generate on the fly, should not happen in this example */
        rsa_tmp = RSA_generate_key(keylength,RSA_F4,NULL,NULL);
        rsa_512 = rsa_tmp; /* Remember for later reuse */
      }
      break;
    case 1024:
      if (rsa_1024)
        rsa_tmp=rsa_1024;
      else
        should_not_happen_in_this_example();
      break;
    default:
      /* Generating a key on the fly is very costly, so use what is there */
      if (rsa_1024)
        rsa_tmp=rsa_1024;
      else
        rsa_tmp=rsa_512; /* Use at least a shorter key */
    }
    return(rsa_tmp);
 }

</PRE>


<A NAME="lbAG">&nbsp;</A>
<H2>RETURN VALUES</H2>

<A NAME="ixAAG"></A>
<I>SSL_CTX_set_tmp_rsa_callback()</I> and <I>SSL_set_tmp_rsa_callback()</I> do not return
diagnostic output.
<P>

<I>SSL_CTX_set_tmp_rsa()</I> and <I>SSL_set_tmp_rsa()</I> do return 1 on success and 0
on failure. Check the error queue to find out the reason of failure.
<P>

<I>SSL_CTX_need_tmp_rsa()</I> and <I>SSL_need_tmp_rsa()</I> return 1 if a temporary
<FONT SIZE="-1">RSA</FONT> key is needed and 0 otherwise.
<A NAME="lbAH">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixAAH"></A>
<I><A HREF="/man/index.html?3+ssl">ssl</A></I>(3), <I><A HREF="http://localhost/cgi-bin/man/man2html?3+SSL_CTX_set_cipher_list">SSL_CTX_set_cipher_list</A></I>(3),
<I><A HREF="/man/index.html?3+SSL_CTX_set_options">SSL_CTX_set_options</A></I>(3),
<I><A HREF="/man/index.html?3+SSL_CTX_set_tmp_dh_callback">SSL_CTX_set_tmp_dh_callback</A></I>(3),
<I><A HREF="/man/index.html?3+SSL_new">SSL_new</A></I>(3), <I><A HREF="http://localhost/cgi-bin/man/man2html?1+ciphers">ciphers</A></I>(1)
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">NOTES</A><DD>
<DT><A HREF="#lbAF">EXAMPLES</A><DD>
<DT><A HREF="#lbAG">RETURN VALUES</A><DD>
<DT><A HREF="#lbAH">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/man/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:41 GMT, December 24, 2015
</div></body>
</HTML>
