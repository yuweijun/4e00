<!DOCTYPE html>

<HTML><head><TITLE>Manpage of Locale::Messages</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/man/index.html">linux man pages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>Locale::Messages</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2010-08-21<BR><A HREF="#index">Index</A>
<A HREF="/man/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Locale::Messages - Gettext Like Message Retrieval
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
 use Locale::Messages (:locale_h :libintl_h);

 gettext $msgid;
 dgettext $textdomain, $msgid;
 dcgettext $textdomain, $msgid, LC_MESSAGES;
 ngettext $msgid, $msgid_plural, $count;
 dngettext $textdomain, $msgid, $msgid_plural, $count;
 dcngettext $textdomain, $msgid, $msgid_plural, $count, LC_MESSAGES;
 pgettext $msgctxt, $msgid;
 dpgettext $textdomain, $msgctxt, $msgid;
 dcpgettext $textdomain, $msgctxt, $msgid, LC_MESSAGES;
 npgettext $msgctxt, $msgid, $msgid_plural, $count;
 dnpgettext $textdomain, $msgctxt, $msgid, $msgid_plural, $count;
 dcnpgettext $textdomain, $msgctxt, $msgid, $msgid_plural, $count, LC_MESSAGES;
 textdomain $textdomain;
 bindtextdomain $textdomain, $directory;
 bind_textdomain_codeset $textdomain, $encoding;
 bind_textdomain_filter $textdomain, \&amp;filter, $data;
 turn_utf_8_on ($variable);
 turn_utf_8_off ($variable);
 nl_putenv ('OUTPUT_CHARSET=koi8-r');
 my $category = LC_CTYPE;
 my $category = LC_NUMERIC;
 my $category = LC_TIME;
 my $category = LC_COLLATE;
 my $category = LC_MONETARY;
 my $category = LC_MESSAGES;
 my $category = LC_ALL;

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
The module <B>Locale::Messages</B> is a wrapper around the interface to
message translation according to the Uniforum approach that is
for example used in <FONT SIZE="-1">GNU</FONT> gettext and Sun's Solaris.  It is intended
to allow <I><A HREF="/man/index.html?3+Locale::Messages">Locale::Messages</A></I>(3) to switch between different implementations
of the lower level libraries but this is not yet implemented.
<P>

Normally you should not use this module directly, but the high
level interface <I><A HREF="/man/index.html?3+Locale::TextDomain">Locale::TextDomain</A></I>(3) that provides a much simpler
interface.  This description is therefore deliberately kept
brief.  Please refer to the <FONT SIZE="-1">GNU</FONT> gettext documentation available at
&lt;<A HREF="http://www.gnu.org/manual/gettext/">http://www.gnu.org/manual/gettext/</A>&gt; for in-depth and background 
information on the topic.
<P>

The lower level module <I><A HREF="/man/index.html?3+Locale::gettext_pp">Locale::gettext_pp</A></I>(3) provides the Perl
implementation of <I>gettext()</I> and related functions.
<A NAME="lbAE">&nbsp;</A>
<H2>FUNCTIONS</H2>

<A NAME="ixAAE"></A>
The module exports by default nothing.  Every function has to be
imported explicitely or via an export tag (``<FONT SIZE="-1">EXPORT</FONT> <FONT SIZE="-1">TAGS</FONT>'').
<DL COMPACT>
<DT><B>gettext </B><FONT SIZE="-1"><B>MSGID</B></FONT><B></B><DD>
<A NAME="ixAAF"></A>
Returns the translation for <B></B><FONT SIZE="-1"><B>MSGID</B></FONT><B></B>.  Example:


<P>




<PRE>
    print gettext &quot;Hello World!\n&quot;;

</PRE>




<P>


If no translation can be found, the unmodified <B></B><FONT SIZE="-1"><B>MSGID</B></FONT><B></B> is returned,
i. e. the function can <I>never</I> fail, and will <I>never</I> mess up your
original message.


<P>


Note for Perl 5.6 and later: The returned string will <I>always</I> have
the <FONT SIZE="-1">UTF-8</FONT> flag off by default.  See the documentation for function
<I>bind_textdomain_filter()</I> for a way to change this behavior.


<P>


One common mistake is this:


<P>




<PRE>
    print gettext &quot;Hello $name!&quot;;

</PRE>




<P>


Perl will interpolate the variable <TT>$name</TT> <I>before</I> the function
will see the string.  Unless the corresponding message catalog 
contains a message ``Hello Tom!'', ``Hello Dick!'' or ``Hello Harry!'',
no translation will be found.


<P>


Using <I>printf()</I> and friends has its own problems:


<P>




<PRE>
    print sprintf (gettext (&quot;This is the %s %s.&quot;), $color, $thing);

</PRE>




<P>


(The example is stupid because neither color nor thing will get
translated here ...).


<P>


In English the adjective (the color) will precede the noun, many
other languages (for example French or Italian) differ here.  The 
translator of the message may therefore have a hard time to find
a translation that will still work and not sound stupid in the 
target language.  Many C implementations of <I>printf()</I> allow to 
change the order of the arguments, and a French translator could
then say:


<P>




<PRE>
    &quot;C'est le %$2s %$1s.&quot;

</PRE>




<P>


Perl <I>printf()</I> implements this feature as of version 5.8 or better.
Consequently you can only use it, if you are sure that your software
will run with Perl 5.8 or a later version.


<P>


Another disadvantage of using <I>printf()</I> is its cryptic syntax (maybe
not for you but translators of your software may have their own
opinion).


<P>


See the description of the function <TT>&quot;__x()&quot;</TT> in <I><A HREF="/man/index.html?3+Locale::TextDomain">Locale::TextDomain</A></I>(3)
for a much better way to get around this problem.


<P>


Non-ASCII message ids ...


<P>


You should note that the function (and all other similar functions
in this module) does a bytewise comparison of the <B></B><FONT SIZE="-1"><B>MSGID</B></FONT><B></B> for the
lookup in the translation catalog, no matter whether obscure utf-8
flags are set on it, whether the string looks like utf-8, whether
the <I><A HREF="/man/index.html?3pm+utf8">utf8</A></I>(3pm) pragma is used, or whatever other weird method past
or future <I><A HREF="/man/index.html?1+perl">perl</A></I>(1) versions invent for guessing character sets of
strings.


<P>


Using other than us-ascii characters in Perl source code is a call
for trouble, a compatibility nightmare.  Furthermore, <FONT SIZE="-1">GNU</FONT> gettext
only lately introduced support for non-ascii character sets in sources,
and support for this feature may not be available everywhere.  If
you absolutely want to use <B></B><FONT SIZE="-1"><B>MSGID</B></FONT><B></B>s in non-ascii character sets,
it is wise to choose utf-8.  This will minimize the risk that <I><A HREF="/man/index.html?1+perl">perl</A></I>(1)
itself will mess with the strings, and it will also be a guaranty
that you can later translate your project into arbitrary target
languages.


<P>


Other character sets can theoretically work.  Yet, using another
character set in the Perl source code than the one used in your
message catalogs will <B>never</B> work, since the lookup is done bytewise,
and all strings with non-ascii characters will not be found.


<P>


Even if you have solved all these problems, there is still one show
stopper left: The gettext runtime <FONT SIZE="-1">API</FONT> lacks a possibility to specify 
the character set of the source code (including the original strings).
Consequently - in absence of a hint for the input encoding - strings 
without a translation are not subject to output character set conversion.
In other words: If the (non-determinable) output character set differs
from the character set used in the source code, output can be a
mixture of two character sets.  There is no point in trying to address
this problem in the pure Perl version of the gettext functions.  because
breaking compatibilty between the Perl and the C version is a price too
high to pay.


<P>


This all boils down to: Only use <FONT SIZE="-1">ASCII</FONT> characters in your translatable
strings!
<DT><B>dgettext </B><FONT SIZE="-1"><B>TEXTDOMAIN</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID</B></FONT><B></B><DD>
<A NAME="ixAAG"></A>
Like <I>gettext()</I>, but retrieves the message for the specified 
<B></B><FONT SIZE="-1"><B>TEXTDOMAIN</B></FONT><B></B> instead of the default domain.  In case you wonder what
a textdomain is, you should really read on with <I><A HREF="/man/index.html?3+Locale::TextDomain">Locale::TextDomain</A></I>(3).
<DT><B>dcgettext </B><FONT SIZE="-1"><B>TEXTDOMAIN</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID</B></FONT><B>, </B><FONT SIZE="-1"><B>CATEGORY</B></FONT><B></B><DD>
<A NAME="ixAAH"></A>
Like <I>dgettext()</I> but retrieves the message from the specified <B></B><FONT SIZE="-1"><B>CATEGORY</B></FONT><B></B>
instead of the default category <TT>&quot;LC_MESSAGES&quot;</TT>.
<DT><B>ngettext </B><FONT SIZE="-1"><B>MSGID</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID_PLURAL</B></FONT><B>, </B><FONT SIZE="-1"><B>COUNT</B></FONT><B></B><DD>
<A NAME="ixAAI"></A>
Retrieves the correct translation for <B></B><FONT SIZE="-1"><B>COUNT</B></FONT><B></B> items.  In legacy software
you will often find something like:


<P>




<PRE>
    print &quot;$count file(s) deleted.\n&quot;;

</PRE>




<P>


or


<P>




<PRE>
    printf &quot;$count file%s deleted.\n&quot;, $count == 1 ? '' : 's';

</PRE>




<P>


The first example looks awkward, the second will only work in English
and languages with similar plural rules.  Before <I>ngettext()</I> was introduced,
the best practice for internationalized programs was:


<P>




<PRE>
    if ($count == 1) {
        print gettext &quot;One file deleted.\n&quot;;
    } else {
        printf gettext &quot;%d files deleted.\n&quot;;
    }

</PRE>




<P>


This is a nuisance for the programmer and often still not sufficient
for an adequate translation.  Many languages have completely different
ideas on numerals.  Some (French, Italian, ...) treat 0 and 1 alike,
others make no distinction at all (Japanese, Korean, Chinese, ...),
others have two or more plural forms (Russian, Latvian, Czech,
Polish, ...).  The solution is:


<P>




<PRE>
    printf (ngettext (&quot;One file deleted.\n&quot;,
                     &quot;%d files deleted.\n&quot;,
                     $count), # argument to ngettext!
            $count);          # argument to printf!

</PRE>




<P>


In English, or if no translation can be found, the first argument
(<B></B><FONT SIZE="-1"><B>MSGID</B></FONT><B></B>) is picked if <TT>$count</TT> is one, the second one otherwise.
For other languages, the correct plural form (of 1, 2, 3, 4, ...)
is automatically picked, too.  You don't have to know anything about
the plural rules in the target language, <I>ngettext()</I> will take care
of that.


<P>


This is most of the time sufficient but you will have to prove your
creativity in cases like


<P>




<PRE>
    printf &quot;%d file(s) deleted, and %d file(s) created.\n&quot;;

</PRE>


<DT><B>dngettext </B><FONT SIZE="-1"><B>TEXTDOMAIN</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID_PLURAL</B></FONT><B>, </B><FONT SIZE="-1"><B>COUNT</B></FONT><B></B><DD>
<A NAME="ixAAJ"></A>
Like <I>ngettext()</I> but retrieves the translation from the specified
textdomain instead of the default domain.
<DT><B>dcngettext </B><FONT SIZE="-1"><B>TEXTDOMAIN</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID_PLURAL</B></FONT><B>, </B><FONT SIZE="-1"><B>COUNT</B></FONT><B>, </B><FONT SIZE="-1"><B>CATEGORY</B></FONT><B></B><DD>
<A NAME="ixAAK"></A>
Like <I>dngettext()</I> but retrieves the translation from the specified
category, instead of the default category <TT>&quot;LC_MESSAGES&quot;</TT>.
<DT><B>pgettext </B><FONT SIZE="-1"><B>MSGCTXT</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID</B></FONT><B></B><DD>
<A NAME="ixAAL"></A>
Returns the translation of <FONT SIZE="-1">MSGID</FONT>, given the context of <FONT SIZE="-1">MSGCTXT</FONT>.


<P>


Both items are used as a unique key into the message catalog.


<P>


This allows the translator to have two entries for words that may
translate to different foreign words based on their context. For
example, the word ``View'' may be a noun or a verb, which may be
used in a menu as File-&gt;View or View-&gt;Source.


<P>




<PRE>
    pgettext &quot;Verb: To View&quot;, &quot;View\n&quot;;
    pgettext &quot;Noun: A View&quot;, &quot;View\n&quot;;

</PRE>




<P>


The above will both lookup different entries in the message catalog.


<P>


A typical usage are <FONT SIZE="-1">GUI</FONT> programs.  Imagine a program with a main
menu and the notorious ``Open'' entry in the ``File'' menu.  Now imagine,
there is another menu entry Preferences-&gt;Advanced-&gt;Policy where you have 
a choice between the alternatives ``Open'' and ``Closed''.  In English, ``Open''
is the adequate text at both places.  In other languages, it is very
likely that you need two different translations.  Therefore, you would
now write:


<P>




<PRE>
    pgettext &quot;File|&quot;, &quot;Open&quot;;
    pgettext &quot;Preferences|Advanced|Policy&quot;, &quot;Open&quot;;

</PRE>




<P>


In English, or if no translation can be found, the second argument
(<FONT SIZE="-1">MSGID</FONT>) is returned.


<P>


The function was introduced with libintl-perl version 1.17.
<DT><B>dpgettext </B><FONT SIZE="-1"><B>TEXTDOMAIN</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGCTXT</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID</B></FONT><B></B><DD>
<A NAME="ixAAM"></A>
Like <I>pgettext()</I>, but retrieves the message for the specified 
<B></B><FONT SIZE="-1"><B>TEXTDOMAIN</B></FONT><B></B> instead of the default domain.


<P>


The function was introduced with libintl-perl version 1.17.
<DT><B>dcpgettext </B><FONT SIZE="-1"><B>TEXTDOMAIN</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGCTXT</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID</B></FONT><B>, </B><FONT SIZE="-1"><B>CATEGORY</B></FONT><B></B><DD>
<A NAME="ixAAN"></A>
Like <I>dpgettext()</I> but retrieves the message from the specified <B></B><FONT SIZE="-1"><B>CATEGORY</B></FONT><B></B>
instead of the default category <TT>&quot;LC_MESSAGES&quot;</TT>.


<P>


The function was introduced with libintl-perl version 1.17.
<DT><B>npgettext </B><FONT SIZE="-1"><B>MSGCTXT</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID_PLURAL</B></FONT><B>, </B><FONT SIZE="-1"><B>COUNT</B></FONT><B></B><DD>
<A NAME="ixAAO"></A>
Like <I>ngettext()</I> with the addition of context as in <I>pgettext()</I>.


<P>


In English, or if no translation can be found, the second argument
(<FONT SIZE="-1">MSGID</FONT>) is picked if <TT>$count</TT> is one, the third one otherwise.


<P>


The function was introduced with libintl-perl version 1.17.
<DT><B>dnpgettext </B><FONT SIZE="-1"><B>TEXTDOMAIN</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGCTXT</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID_PLURAL</B></FONT><B>, </B><FONT SIZE="-1"><B>COUNT</B></FONT><B></B><DD>
<A NAME="ixAAP"></A>
Like <I>npgettext()</I> but retrieves the translation from the specified
textdomain instead of the default domain.


<P>


The function was introduced with libintl-perl version 1.17.
<DT><B>dcnpgettext </B><FONT SIZE="-1"><B>TEXTDOMAIN</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGCTXT</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID</B></FONT><B>, </B><FONT SIZE="-1"><B>MSGID_PLURAL</B></FONT><B>, </B><FONT SIZE="-1"><B>COUNT</B></FONT><B>, </B><FONT SIZE="-1"><B>CATEGORY</B></FONT><B></B><DD>
<A NAME="ixAAQ"></A>
Like <I>dnpgettext()</I> but retrieves the translation from the specified
category, instead of the default category <TT>&quot;LC_MESSAGES&quot;</TT>.


<P>


The function was introduced with libintl-perl version 1.17.
<DT><B>textdomain </B><FONT SIZE="-1"><B>TEXTDOMAIN</B></FONT><B></B><DD>
<A NAME="ixAAR"></A>
Sets the default textdomain (initially 'messages').
<DT><B>bindtextdomain </B><FONT SIZE="-1"><B>TEXTDOMAIN</B></FONT><B>, </B><FONT SIZE="-1"><B>DIRECTORY</B></FONT><B></B><DD>
<A NAME="ixAAS"></A>
Binds <B></B><FONT SIZE="-1"><B>TEXTDOMAIN</B></FONT><B></B> to <B></B><FONT SIZE="-1"><B>DIRECTORY</B></FONT><B></B>.  Huh? An example:


<P>




<PRE>
    bindtextdomain &quot;my-package&quot;, &quot;./mylocale&quot;;

</PRE>




<P>


Say, the selected locale (actually the selected locale for category
<TT>&quot;LC_MESSAGES&quot;</TT>) of the program is 'fr_CH', then the message catalog
will be expected in <I>./mylocale/fr_CH/LC_MESSAGES/my-package.mo</I>.
<DT><B>bind_textdomain_codeset </B><FONT SIZE="-1"><B>TEXTDOMAIN</B></FONT><B>, </B><FONT SIZE="-1"><B>ENCODING</B></FONT><B></B><DD>
<A NAME="ixAAT"></A>
Sets the output encoding for <B></B><FONT SIZE="-1"><B>TEXTDOMAIN</B></FONT><B></B> to <B></B><FONT SIZE="-1"><B>ENCODING</B></FONT><B></B>.
<DT><B>bind_textdomain_filter </B><FONT SIZE="-1"><B>TEXTDOMAN</B></FONT><B>, </B><FONT SIZE="-1"><B>CODEREF</B></FONT><B>, </B><FONT SIZE="-1"><B>DATA</B></FONT><B></B><DD>
<A NAME="ixAAU"></A>

<DT><B>bind_textdomain_filter </B><FONT SIZE="-1"><B>TEXTDOMAN</B></FONT><B>, </B><FONT SIZE="-1"><B>CODEREF</B></FONT><B></B><DD>
<A NAME="ixAAV"></A>

By default, Locale::Messages will turn the utf-8 flag of all returned
messages off.  If you want to change this behavior, you can pass
a reference to a subroutine that does different things - for example
turn the utf-8 flag on, or leave it untouched.  The callback function 
will be called with <B></B><FONT SIZE="-1"><B>DATA</B></FONT><B></B> as the first, and the possibly 
translated string as the second argument.  It should return the
possibly modified string.


<P>


If you want an object method to be called, pass the object itself
in the data parameter and write a wrapper function.  Example:


<P>




<PRE>
    sub wrapper { 
        my ($string, $obj) = @_;
 
        $obj-&gt;filterMethod ($string);
    }
    my $obj = MyPackage-&gt;new;

    bind_textdomain_filter ('mydomain', \&amp;wrapper, $obj);

</PRE>




<P>


The function cannot fail and always returns a true value.


<P>


<B>Attention:</B> If you use the function for setting the utf-8 flag,
it is <B>your</B> responsability to ensure that the output is really
utf-8.  You should only use it, if you have set the environment
variable <B></B><FONT SIZE="-1"><B>OUTPUT_CHARSET</B></FONT><B></B> to ``utf-8''.  Additionally you should
call <I>bind_textdomain_codeset()</I> with ``utf-8'' as the second
argument.


<P>


This function has been introduced in libintl-perl 1.16 and it is
<B>not</B> part of the standard gettext <FONT SIZE="-1">API</FONT>.
<DT><B>turn_utf_8_on </B><FONT SIZE="-1"><B>VARIABLE</B></FONT><B></B><DD>
<A NAME="ixAAW"></A>
Returns <FONT SIZE="-1">VARIABLE</FONT> but with the <FONT SIZE="-1">UTF-8</FONT> flag (only known in Perl &gt;=5.6)
guaranteed to be turned on.  This function does not really fit into
the module, but it is often handy nevertheless.


<P>


The flag does <B>not</B> mean that the string is in fact valid utf-8!


<P>


The function was introduced with libintl-perl version 1.16.
<DT><B>turn_utf_8_off </B><FONT SIZE="-1"><B>VARIABLE</B></FONT><B></B><DD>
<A NAME="ixAAX"></A>
Returns <FONT SIZE="-1">VARIABLE</FONT> but with the <FONT SIZE="-1">UTF-8</FONT> flag (only known in Perl &gt;=5.6)
guaranteed to be turned off.  This function does not really fit into
the module, but it is often handy nevertheless.


<P>


The function was introduced with libintl-perl version 1.07.
<DT><B>select_package </B><FONT SIZE="-1"><B>PACKAGE</B></FONT><B></B><DD>
<A NAME="ixAAY"></A>
By default, <B>Locale::Messages</B> will try to load the <FONT SIZE="-1">XS</FONT> version of
the gettext implementation, i. e. <I><A HREF="/man/index.html?3+Locale::gettext_xs">Locale::gettext_xs</A></I>(3) and will fall
back to the pure Perl implementation <I><A HREF="/man/index.html?3+Locale::gettext_pp">Locale::gettext_pp</A></I>(3).  You can
override this behavior by passing the string ``gettext_pp'' or
``gettext_xs'' to the function <I>select_package()</I>.  Passing ``gettext_pp''
here, will prefer the pure Perl implementation.


<P>


You will normally want to use that in a <FONT SIZE="-1">BEGIN</FONT> block of your main
script.


<P>


The function was introduced with libintl-perl version 1.03 and is not
part of the standard gettext <FONT SIZE="-1">API</FONT>.
<DT><B>nl_putenv </B><FONT SIZE="-1"><B>ENVSPEC</B></FONT><B></B><DD>
<A NAME="ixAAZ"></A>
Resembles the <FONT SIZE="-1">ANSI</FONT> C <I><A HREF="/man/index.html?3+putenv">putenv</A></I>(3) function.  The sole purpose of this 
function is to work around some ideosyncrasies in the environment
processing of Windows systems.  If you want to portably set or
unset environment variables, use this function instead of directly
manipulating <TT>%ENV</TT>.


<P>


The argument <B></B><FONT SIZE="-1"><B>ENVSPEC</B></FONT><B></B> may have three different forms.
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>LANGUAGE=fr_CH</B><DD>
<A NAME="ixABA"></A>
This would set the environment variable <TT>&quot;LANGUAGE&quot;</TT> to ``fr_CH''.
<DT><B>LANGUAGE=</B><DD>
<A NAME="ixABB"></A>
Normally, this will set the environment variable <TT>&quot;LANGUAGE&quot;</TT> to an
empty string.  Under Windows, however, the environment variable will
be deleted instead (and is no longer present in <TT>%ENV</TT>).  Since
within libintl-perl empty environment variables are useless, consider
this usage as deprecated.
<DT><B></B><FONT SIZE="-1"><B>LANGUAGE</B></FONT><B></B><DD>
<A NAME="ixABC"></A>
This will delete the environment variable <B></B><FONT SIZE="-1"><B>LANGUAGE</B></FONT><B></B>.  If you are
familiar with the brain-damaged implementation of <I><A HREF="/man/index.html?3+putenv">putenv</A></I>(3) (resp.
<I>_putenv()</I>) in the so-called standard C library of MS-Windows, you
may suspect that this is an invalid argument.  This is not the case!
Passing a variable name not followed by an equal sign will always
delete the variable, no matter which operating system you use.
</DL>
</DL>

<DL COMPACT><DT><DD>


<P>


The function returns true for success, and false for failure.  Possible
reasons for failure are an invalid syntax or - only under Windows -
failure to allocate space for the new environment entry ($! will be
set accordingly in this case).


<P>


Why all this hassle?  The 32-bit versions of MS-DOS (currently
Windows 95/98/ME/NT/2000/XP/CE/.NET) maintain two distinct blocks
of environment variables per process.  Which block is considered
the ``correct'' environment is a compile-time option of the Perl
interpreter.  Unfortunately, if you have build the <FONT SIZE="-1">XS</FONT> version 
<I><A HREF="/man/index.html?3+Locale::gettext_xs">Locale::gettext_xs</A></I>(3) under Windows, the underlying library may use 
a different environment block, and changes you make to <TT>%ENV</TT> may
not be visible to the library.


<P>


The function <I>nl_putenv()</I> is mostly a funny way of saying


<P>




<PRE>
    LANGUAGE=some_value

</PRE>




<P>


but it does its best, to pass this information to the gettext 
library.  Under other operating systems than Windows, it only
operates on <TT>%ENV</TT>, under Windows it will call the C library
function <I>_putenv()</I> (after doing some cleanup to its arguments),
before manipulating <TT>%ENV</TT>.


<P>


Please note, that you <TT>%ENV</TT> is updated by <I>nl_putenv()</I> automatically.


<P>


The function has been introduced in libintl-perl version 1.10.
</DL>

</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>CONSTANTS</H2>

<A NAME="ixABD"></A>
You can (maybe) get the same constants from <FONT SIZE="-1"><I><A HREF="/man/index.html?3+POSIX">POSIX</A></I></FONT><I></I>(3); see there for
a detailed description
<DL COMPACT>
<DT><B></B><FONT SIZE="-1"><B>LC_CTYPE</B></FONT><B></B><DD>
<A NAME="ixABE"></A>

<DT><B></B><FONT SIZE="-1"><B>LC_NUMERIC</B></FONT><B></B><DD>
<A NAME="ixABF"></A>
<DT><B></B><FONT SIZE="-1"><B>LC_TIME</B></FONT><B></B><DD>
<A NAME="ixABG"></A>
<DT><B></B><FONT SIZE="-1"><B>LC_COLLATE</B></FONT><B></B><DD>
<A NAME="ixABH"></A>
<DT><B></B><FONT SIZE="-1"><B>LC_MONETARY</B></FONT><B></B><DD>
<A NAME="ixABI"></A>
<DT><B></B><FONT SIZE="-1"><B>LC_MESSAGES</B></FONT><B></B><DD>
<A NAME="ixABJ"></A>

This locale category was the reason that these constants from <FONT SIZE="-1"><I><A HREF="/man/index.html?3+POSIX">POSIX</A></I></FONT><I></I>(3)
were included here.  Even if it was present in your systems C include
file <I>locale.h</I>, it was not provided by <FONT SIZE="-1"><I><A HREF="/man/index.html?3+POSIX">POSIX</A></I></FONT><I></I>(3).  Perl 5.8 and later
seems to export the constant if available, although it is not documented
in <FONT SIZE="-1"><I><A HREF="/man/index.html?3+POSIX">POSIX</A></I></FONT><I></I>(3).


<P>


<I><A HREF="/man/index.html?3+Locale::Messages">Locale::Messages</A></I>(3) makes an attempt to guess the value of this category for
all systems, and assumes the arbitrary value 1729 otherwise.
<DT><B></B><FONT SIZE="-1"><B>LC_ALL</B></FONT><B></B><DD>
<A NAME="ixABK"></A>
If you specify the category <B></B><FONT SIZE="-1"><B>LC_ALL</B></FONT><B></B> as the first argument to
<I>POSIX::setlocale()</I>, <I>all</I> locale categories will be affected at once.
</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>EXPORT TAGS</H2>

<A NAME="ixABL"></A>
The module does not export anything unless explicitely requested.
You can import groups of functions via two tags:
<DL COMPACT>
<DT><B>use Locale::Messages (':locale_h')</B><DD>
<A NAME="ixABM"></A>
Imports the functions that are normally defined in the C include
file <I>locale.h</I>:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B></B>gettext()<B></B><DD>
<A NAME="ixABN"></A>

<DT><B></B>dgettext()<B></B><DD>
<A NAME="ixABO"></A>
<DT><B></B>dcgettext()<B></B><DD>
<A NAME="ixABP"></A>
<DT><B></B>ngettext()<B></B><DD>
<A NAME="ixABQ"></A>
<DT><B></B>dngettext()<B></B><DD>
<A NAME="ixABR"></A>
<DT><B></B>dcngettext()<B></B><DD>
<A NAME="ixABS"></A>
<DT><B></B>pgettext()<B></B><DD>
<A NAME="ixABT"></A>
<DT><B></B>dpgettext()<B></B><DD>
<A NAME="ixABU"></A>
<DT><B></B>dcpgettext()<B></B><DD>
<A NAME="ixABV"></A>
<DT><B></B>npgettext()<B></B><DD>
<A NAME="ixABW"></A>
<DT><B></B>dnpgettext()<B></B><DD>
<A NAME="ixABX"></A>
<DT><B></B>dcnpgettext()<B></B><DD>
<A NAME="ixABY"></A>
<DT><B></B>textdomain()<B></B><DD>
<A NAME="ixABZ"></A>
<DT><B></B>bindtextdomain()<B></B><DD>
<A NAME="ixACA"></A>
<DT><B></B>bind_textdomain_codeset()<B></B><DD>
<A NAME="ixACB"></A>
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>

<DT><B>use Locale::Messages (':libintl_h')</B><DD>
<A NAME="ixACC"></A>

Imports the locale category constants:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B></B><FONT SIZE="-1"><B>LC_CTYPE</B></FONT><B></B><DD>
<A NAME="ixACD"></A>

<DT><B></B><FONT SIZE="-1"><B>LC_NUMERIC</B></FONT><B></B><DD>
<A NAME="ixACE"></A>
<DT><B></B><FONT SIZE="-1"><B>LC_TIME</B></FONT><B></B><DD>
<A NAME="ixACF"></A>
<DT><B></B><FONT SIZE="-1"><B>LC_COLLATE</B></FONT><B></B><DD>
<A NAME="ixACG"></A>
<DT><B></B><FONT SIZE="-1"><B>LC_MONETARY</B></FONT><B></B><DD>
<A NAME="ixACH"></A>
<DT><B></B><FONT SIZE="-1"><B>LC_MESSAGES</B></FONT><B></B><DD>
<A NAME="ixACI"></A>
<DT><B></B><FONT SIZE="-1"><B>LC_ALL</B></FONT><B></B><DD>
<A NAME="ixACJ"></A>
</DL>
</DL>

<DL COMPACT><DT><DD>
</DL>


</DL>
<A NAME="lbAH">&nbsp;</A>
<H2>OTHER EXPORTS</H2>

<A NAME="ixACK"></A>
<DL COMPACT>
<DT><B>select_package </B><FONT SIZE="-1"><B>PACKAGE</B></FONT><B></B><DD>
<A NAME="ixACL"></A>
</DL>
<A NAME="lbAI">&nbsp;</A>
<H2>USAGE</H2>

<A NAME="ixACM"></A>
A complete example:
<P>



<PRE>
    1: use Locale::Messages qw (:locale_h :libintl_h);
    2: use POSIX qw (setlocale);
    3: setlocale (LC_MESSAGES, '');
    4: textdomain ('my-package');
    5: bindtextdomain ('my-package' =&gt; '/usr/local/share/locale');
    6:
    7: print gettext (&quot;Hello world!\n&quot;);

</PRE>


<P>

Step by step: Line 1 imports the necessary functions and constants.
In line 3 we set the locale for category <FONT SIZE="-1">LC_MESSAGES</FONT> to the default
user settings.  For C programs you will often read that <FONT SIZE="-1">LC_ALL</FONT>
is the best category here but this will also change the locale for
<FONT SIZE="-1">LC_NUMERIC</FONT> and many programs will not work reliably after changing
that category in Perl; choose your own poison!
<P>

In line 4 we say that all messages (translations) without an explicit
domain specification should be retrieved from the message catalog
for the domain 'my-package'.  Line 5 has the effect that the message
catalog will be searched under the directory <I>/usr/local/share/locale</I>.
<P>

If the user has selected the locale 'fr_CH', and if the file 
<I>/usr/local/share/locale/fr_CH/LC_MESSAGES/my-package.mo</I>
exists, and if it contains a <FONT SIZE="-1">GNU</FONT> message object file with a translation
for the string ``Hello world!\n'', then line 7 will print the French
translation (for Switzerland <FONT SIZE="-1">CH</FONT>) to <FONT SIZE="-1">STDOUT</FONT>.
<P>

The documentation for <FONT SIZE="-1">GNU</FONT> gettext explains how to extract translatable
strings from your Perl files and how to create message catalogs.
<P>

Another less portable example: If your system uses the <FONT SIZE="-1">GNU</FONT> libc you
should be able to find various files with the name <I>libc.mo</I>, the
message catalog for the library itself.  If you have found these
files under <I>/usr/share/locale</I>, then you can try the following:
<P>



<PRE>
    use Locale::Messages qw (:locale_h :libintl_h);
    use POSIX qw (setlocale);

    setlocale LC_MESSAGES, &quot;&quot;;
    textdomain &quot;libc&quot;;

    # The following is actually not needed, since this is
    # one of the default search directories.
    bindtextdomain libc =&gt; '/usr/share/locale';
    bind_textdomain_codeset libc =&gt; 'iso-8859-1';

    print gettext (&quot;No such file or directory&quot;);

</PRE>


<P>

See <I><A HREF="/man/index.html?3+Locale::TextDomain">Locale::TextDomain</A></I>(3) for much simpler ways.
<A NAME="lbAJ">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixACN"></A>
Copyright (C) 2002-2009, Guido Flohr &lt;<A HREF="mailto:guido@imperia.net">guido@imperia.net</A>&gt;, all
rights reserved.  See the source code for details.
<P>

This software is contributed to the Perl community by Imperia 
(&lt;<A HREF="http://www.imperia.net/">http://www.imperia.net/</A>&gt;).
<A NAME="lbAK">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixACO"></A>
<I><A HREF="/man/index.html?3pm+Locale::TextDomain">Locale::TextDomain</A></I>(3pm), <I><A HREF="http://localhost/cgi-bin/man/man2html?3pm+Locale::gettext_pp">Locale::gettext_pp</A></I>(3pm), <I><A HREF="http://localhost/cgi-bin/man/man2html?3pm+Encode">Encode</A></I>(3pm),
<I><A HREF="/man/index.html?3pm+perllocale">perllocale</A></I>(3pm), <FONT SIZE="-1"><I><A HREF="http://localhost/cgi-bin/man/man2html?3pm+POSIX">POSIX</A></I></FONT><I></I>(3pm), <I><A HREF="http://localhost/cgi-bin/man/man2html?1+perl">perl</A></I>(1), <I><A HREF="http://localhost/cgi-bin/man/man2html?1+gettext">gettext</A></I>(1), <I><A HREF="http://localhost/cgi-bin/man/man2html?3+gettext">gettext</A></I>(3)
<A NAME="lbAL">&nbsp;</A>
<H2>POD ERRORS</H2>

<A NAME="ixACP"></A>
Hey! <B>The above document had some coding errors, which are explained below:</B>
<DL COMPACT>
<DT>Around line 943:<DD>
<A NAME="ixACQ"></A>
'=item' outside of any '=over'
<DT>Around line 945:<DD>
<A NAME="ixACR"></A>
You forgot a '=back' before '=head1'
<P>
</DL>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">FUNCTIONS</A><DD>
<DT><A HREF="#lbAF">CONSTANTS</A><DD>
<DT><A HREF="#lbAG">EXPORT TAGS</A><DD>
<DT><A HREF="#lbAH">OTHER EXPORTS</A><DD>
<DT><A HREF="#lbAI">USAGE</A><DD>
<DT><A HREF="#lbAJ">AUTHOR</A><DD>
<DT><A HREF="#lbAK">SEE ALSO</A><DD>
<DT><A HREF="#lbAL">POD ERRORS</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/man/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:32 GMT, December 24, 2015
</div></body>
</HTML>
