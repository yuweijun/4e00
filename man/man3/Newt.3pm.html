<!DOCTYPE html>

<HTML><head><TITLE>Manpage of Newt</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/man/index.html">linux man pages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>Newt</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2010-11-11<BR><A HREF="#index">Index</A>
<A HREF="/man/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Newt - Perl bindings for Red Hat newt library
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
  use Newt;

  Newt::Init();
  Newt::Cls();

  #A lot of Newt operations...

  Newt::Finished();

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
The Newt module implements perl bindings for the Red Hat newt windowing
system, a terminal-based window and widget library for writing
applications with a simple, but user-friendly, interface.
<A NAME="lbAE">&nbsp;</A>
<H2>Basic Newt functions</H2>

<A NAME="ixAAE"></A>
<DL COMPACT>
<DT>Newt::Init()<DD>


<A NAME="ixAAF"></A>
Starts Newt services. You must use this command first.
<DT>Newt::Finished()<DD>


<A NAME="ixAAG"></A>
Ends Newt services.
<DT>Newt::Cls()<DD>


<A NAME="ixAAH"></A>
Clears the background.
<DT>Newt::Refresh()<DD>


<A NAME="ixAAI"></A>
Foreces an inmediate update of the modified portions of the screen.
<DT>Newt::Bell()<DD>


<A NAME="ixAAJ"></A>
Sends a beep to the terminal.
<DT>Newt::GetScreenSize()<DD>


<A NAME="ixAAK"></A>
Returns a tuple containing the screen dimensions.
</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>Keyboard input</H2>

<A NAME="ixAAL"></A>
<DL COMPACT>
<DT>Newt::WaitForKey()<DD>


<A NAME="ixAAM"></A>
Stops program execution until a key is pressed.
<DT>Newt::ClearKeyBuffer()<DD>


<A NAME="ixAAN"></A>
Discards the contents of the terminal's input buffer without waiting
for additional input.
</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>Drawing text on the root window</H2>

<A NAME="ixAAO"></A>
<DL COMPACT>
<DT>Newt::DrawRootText($left, $top, $text)<DD>


<A NAME="ixAAP"></A>
Displays the text in the indicated position.
<DT>Newt::PushHelpLine($text)<DD>


<A NAME="ixAAQ"></A>
Saves the current help line on a stack and displays the new line. If
the text is null, Newt's default help line is displayed. If text is a
string of length 0, the help line is cleared.
<DT>Newt::PopHelpLine()<DD>


<A NAME="ixAAR"></A>
Replaces the current help line with the previous one. It is important
not to pop more lines than the ones pushed.
</DL>
<A NAME="lbAH">&nbsp;</A>
<H2>Suspending Newt applications</H2>

<A NAME="ixAAS"></A>
By default, Newt programs cannot be suspended by the user. Instead,
programs can specify a callback function which gets invoked whe the
user presses the suspend key. To register such function, you can do
something like this:
<P>



<PRE>
    sub my_cb {
      ...
    }   

    Newt::SetSuspendCallback(\&amp;my_cb);

</PRE>


<P>

If the application should suspend and continue like most user
applications, the suspend callback needs two other newt functions:
<P>



<PRE>
    Newt::Suspend();
    Newt::Resume();

</PRE>


<P>

The first one tells Newt to return the terminal to its initial
state. Once this is done, the application can suspend itself by
sending <FONT SIZE="-1">SIGSTP</FONT>, fork a child program or whatever. When it wants to
resume using the Newt interface, is must call <TT>&quot;Newt::Resume()&quot;</TT> before
doing so.
<P>

For more information on suspending newt applications, read the
original newt documentation.
<A NAME="lbAI">&nbsp;</A>
<H2>Components</H2>

<A NAME="ixAAT"></A>
Components are the basic blocks for construction of Newt interfaces.
They all are created in a similar manner. You just have to
call the constructor to receive a blessed object of the specified
class:
<P>



<PRE>
    $object = Newt::Foo();

</PRE>


<P>

Once you have a component, you can add it to a panel to create a
complex user input interface.
<A NAME="lbAJ">&nbsp;</A>
<H3>General component manipulation</H3>

<A NAME="ixAAU"></A>
You can attach a callback for a component like this:
<P>



<PRE>
    sub comp_cb {
        ...
    }

    $component-&gt;AddCallback(\%comp_cb);

</PRE>


<P>

Exactly when (if ever) the callback is invoked depens on the type of
the component.
<P>

Yo can tell if a component takes or not focus when traversing a form
with the following function:
<P>



<PRE>
    $component-&gt;TakesFocus($true_or_false);

</PRE>


<P>

It is handy to set some arbitrary information on a component for later
retrieval. You do this by setting its tag:
<P>



<PRE>
    $button-&gt;Tag(&quot;OK&quot;);

</PRE>


<P>

If you call this function without an argument, it replies with the
actual tag for that component.
<P>

In general when the return value of any method of a component isn't
described the method returns the component itself to allow constructions
like:
<P>



<PRE>
    $panel
        -&gt;Add(0,0, $componet1-&gt;Set( .... ) )
        -&gt;Add(0,1, Newt::Label( .... ) )
        -&gt;Add(0,2, Newt::Panel( .... )
            -&gt;Add( .... )
            -&gt;Add( .... ) )
        -&gt;Add( .... );

</PRE>


<A NAME="lbAK">&nbsp;</A>
<H3>Buttons</H3>

<A NAME="ixAAV"></A>
There are two kinds of buttons: full and compact:
<P>



<PRE>
    $normal_button = Newt::Button($text);
    $compact_button = Newt::CompactButton($text);

</PRE>


<A NAME="lbAL">&nbsp;</A>
<H3>Labels</H3>

<A NAME="ixAAW"></A>
Labels are quite simple:
<P>



<PRE>
    $label = Newt::Label($text);

</PRE>


<P>

You can set the text of an existing label like this:
<P>



<PRE>
    $label-&gt;Set($text);

</PRE>


<A NAME="lbAM">&nbsp;</A>
<H3>Entry boxes</H3>

<A NAME="ixAAX"></A>
Entry boxes are used to enter text:
<P>



<PRE>
    $entry = Newt::Entry($width, $flags, $initial_text);

</PRE>


<P>

The initial text is optional. After an entry has been created, it's
contents can be set by using:
<P>



<PRE>
    $entry-&gt;Set($text, $cursor_at_end);

</PRE>


<P>

The last parameter is optional, and signals if the cursor should be
moved to the end of the new value.
<P>

To get the current value of the entry box, you do this:
<P>



<PRE>
    $entry-&gt;Get();

</PRE>


<P>

You can filter the characters that may be entered by using a callback
filter like this:
<P>



<PRE>
    sub my_filter {
      my ($proposed_char, $cursor_position) = @_;

      ...

      return(0) if $char_shoud_be_ignored;
      return($proposed_char)    # Accept the char
    }

    $entry-&gt;SetFilter(\&amp;my_filter);

</PRE>


<P>

As can be seen, filter callbacks receive a char and an integer which
indicates the position that the proposed char would take on the entry.
The filter function can return the very same char to indicate that it
was accepted, but it can also return another char, to actually
substitute the original one. If the filter wants to simply reject the
keystroke, it only returns 0.
<P>

When an entry is created, some flags may be specified. The flags are
the following and may be <TT>&quot;OR&quot;</TT>ed:
<DL COMPACT>
<DT>NEWT::NEWT_ENTRY_SCROLL<DD>


<A NAME="ixAAY"></A>
If not specified, the user cannot enter text into the entry box which
is wider than the entry box itself. This flag removes this limitation,
and lets the user enter data of an arbitrary length.
<DT>NEWT::NEWT_FLAG_HIDDEN<DD>


<A NAME="ixAAZ"></A>
If specified, the value of the entry is not displayed. Useful when an
applications needs a password.
<DT>NEWT::NEWT_FLAG_RETURNEXIT<DD>


<A NAME="ixABA"></A>
When specified, the entry will cause the form to stop running if the
user pressed return inside the entry box. Nice shortcut for users.
</DL>
<A NAME="lbAN">&nbsp;</A>
<H3>Checkboxes</H3>

<A NAME="ixABB"></A>
Newt checkboxes are peculiar, since they may have more than two
states. To create a normal one (checked or unchecked), do this:
<P>



<PRE>
    $check = Newt::Checkbox(&quot;Normal checkbox&quot;);

</PRE>


<P>

But you can create, for example, a checkbox that switches from not
checked to checked with an asterisk and then to checked with an 'M':
<P>



<PRE>
    $check = Newt::Checkbox(&quot;Normal checkbox&quot;, &quot; &quot;, &quot; *M&quot;);

</PRE>


<P>

As you can see, you can use the two optional parameters to tell the
default char first and then the possible chars.
<P>

To know if a checkbox is checked after the for is ran, you use the following:
<P>



<PRE>
    print &quot;Is checked\n&quot; if $check-&gt;Checked();

</PRE>


<P>

And you can always get the actual state like this:
<P>



<PRE>
    $state = $check-&gt;Get();

</PRE>


<A NAME="lbAO">&nbsp;</A>
<H3>Radio groups</H3>

<A NAME="ixABC"></A>
You create two kinds of radio button groups, vertical and horizontal,
by doing this:
<P>



<PRE>
    $radio_group1 = Newt::VRadiogroup('Red', 'Green', 'Blue');
    $radio_group2 = Newt::HRadiogroup('Red', 'Green', 'Blue');

</PRE>


<P>

You can put any number of options and the first one will always be
preselected. To know the index of the selected option after the form
has run, you do this:
<P>



<PRE>
    $index = $radio_group-&gt;Get();

</PRE>


<A NAME="lbAP">&nbsp;</A>
<H3>Listboxes</H3>

<A NAME="ixABD"></A>
Listboxes are the most complicated components Newt provides. They can
allow single or multiple selection, and are easy to update. They are
created as follows:
<P>



<PRE>
    $listbox = Newt::Listbox($height, $flags);

</PRE>


<P>

A listbox is created at a certain position and a given height. The
<TT>$height</TT> is used for two things. First of all, it is the minimum
height the listbox will use. If there are less items in the listbox
then the height, suggests the listbox will still take up that minimum
amount of space. Secondly, if the listbox is set to be scrollable (by
setting the <TT>&quot;NEWT_FLAG_SCROLL&quot;</TT> flag, <TT>$height</TT> is also the maximum
height of the listbox. If the listbox may not scroll, it increases its
height to display all of its items.
<P>

The following flags may be used when creating a listbox:
<DL COMPACT>
<DT>NEWT_FLAG_SCROLL<DD>


<A NAME="ixABE"></A>
The listbox should scroll to display all of the items it contains.
<DT>NEWT_FLAG_RETURNEXIT<DD>


<A NAME="ixABF"></A>
When the user presses return on an item in the list, the form should
return.
<DT>NEWT_FLAG_BORDER<DD>


<A NAME="ixABG"></A>
A frame is drawn around the listbox, which can make it easier to see
which listbox has the focus when a form contains multiple listboxes.
<DT>NEWT_FLAG_MULTIPLE<DD>


<A NAME="ixABH"></A>
By default, a listbox only lets the user select one item in the list
at a time. When this flag is specified, they may select multiple items
from the list.
</DL>
<A NAME="lbAQ">&nbsp;</A>
<H3></H3>

<A NAME="ixABI"></A>
Once a listbox has been created, items are appended to the bottom like
this:
<P>



<PRE>
    $listbox-&gt;Append($item1, $item2, ...);

</PRE>


<P>

Appending is not the only way to add items to the list. You can insert
items in any position by telling the item that should be before with
the following command:
<P>



<PRE>
    $listbox-&gt;Insert($before, $item1, $item2, ...);

</PRE>


<P>

And you can change any item just by telling:
<P>



<PRE>
    $listbox-&gt;Set($original, $new);

</PRE>


<P>

Of course you can delete entries:
<P>



<PRE>
    $listbox-&gt;Delete($item1, $item2, ...);

</PRE>


<P>

Or just clear out the listbox:
<P>



<PRE>
    $listbox-&gt;Clear();

</PRE>


<P>

You can select and unselect items, with the following:
<P>



<PRE>
    $listbox-&gt;Select($item1, $item2, ...);

    $listbox-&gt;Unselect($item1, $item2, ...);

    $listbox-&gt;ClearSelection();

</PRE>


<P>

but if you did not sepecify the flag <TT>&quot;NEWT_FLAG_MULTIPLE&quot;</TT> when
constructing your listbox, only the last item on the argument list of
<TT>&quot;Unselect()&quot;</TT> will remain selected.
<P>

To get a list of the selected items, just issue:
<P>



<PRE>
    @selected_items = $listbox-&gt;Get();

</PRE>


<A NAME="lbAR">&nbsp;</A>
<H3>Scales</H3>

<A NAME="ixABJ"></A>
Scales provide an easy way for telling the user the advance on some
lengthy operation. It is a horizontal bar graph which the application
updates as the operation continues:
<P>



<PRE>
    $scale = Newt::Scale($width, $fullvalue);

</PRE>


<P>

It is set as expected:
<P>



<PRE>
    $scale-&gt;Set($amount);

</PRE>


<A NAME="lbAS">&nbsp;</A>
<H3>Textboxes</H3>

<A NAME="ixABK"></A>
A text box is used for displaying large amounts of text. They are
created as follows:
<P>



<PRE>
    $textbox = Newt::Textbox($width, $height, $flags, $text, ...);

</PRE>


<P>

The <TT>$text</TT> parameter is optional, and if not supplied, the textbox
is created only, but it does not fill it with data. To do so, use:
<P>



<PRE>
    $textbox-&gt;Set($text, ...);

</PRE>


<P>

All the arguments are simply concatenated using the double quote
operator.
<P>

The flags that can be passed to the constructor are the following:
<DL COMPACT>
<DT>NEWT_FLAG_WRAP<DD>


<A NAME="ixABL"></A>
All text in the textbox should be wrapped to fit the width of the
textbox. If this flag is not specified, each newline-delimited line in
the text is truncated if it is too long to fit.


<P>


When Newt wraps text, it tries not to break lines on spaces or
tabs. Literal newline characters are respected, and may be used to
force line breaks.
<DT>NEWT_FLAG_SCROLL<DD>


<A NAME="ixABM"></A>
The text should be scrollable. When this option is used, the scrollbar
which is added increases the width of the area used by the textbox by
2 characters.
</DL>
<A NAME="lbAT">&nbsp;</A>
<H3>Reflowing text</H3>

<A NAME="ixABN"></A>
When applications need to display large amounts of text, it is common
not to know exactly where the linebreaks should go. While textboxes
are quite willing to scroll the text, the programmer still must know
what width the text will look ``best'' at (where ``best'' means most
exactly rectangular; no lines much shorter or much longer then the
rest). This common is specially prevalent in internationalized
programs, which need to make a wide variety of message string look
good on a screen.
<P>

To help with this, Newt provides routines to reformat text to look
good. It tries different widths to figure out which one will look
``best'' to the user. As these commons are almost always used to
format text for textbox components, Newt makes it easy to
construct a textbox with reflowed text.
<P>

The following function reflows the provided text to a target
width. the actual width of the longest line in the returned text is
between <TT>&quot;$width - $flexdown&quot;</TT> and <TT>&quot;$width + $flexup&quot;</TT>; the actual
maximum line length is chosen to make displayed text look
rectangular. The function returns a tuple consisting of the reflowed
text and the actual width and height of it.
<P>



<PRE>
    ($r_text, $width, $height) = Newt::ReflowText($width,
                                                  $flexdown,
                                                  $flexup,
                                                  $text);

</PRE>


<P>

When the reflowed text is being placed in a textbox it may be easier
to use the following:
<P>



<PRE>
    $textbox = Newt::TextboxReflowed($width, $flexdown, 
                                     $flexup, $flags,
                                     $text, ...);

</PRE>


<P>

which creates a textbox, reflows the text, and places the reflowed
text in the listbox. Its parameters consist of the position of the
final textbox, the width and flex values for the text (which are
identical to the parameters passed to <TT>&quot;Newt::Reflow()&quot;</TT>, and the flags
for the textbox (which are the same as the flags for
<TT>&quot;Newt::Textbox()&quot;</TT>. This function does not let you limit the height of
the textbox, however, making limiting its use to constructing
textboxes which do not need to scroll.
<P>

To find out how tall the textbox created by <TT>&quot;Newt::TextboxReflowed()&quot;</TT> is, 
use <TT>&quot;Newt::GetNumLines()&quot;</TT>, which returns the number of lines in the
textbox. For textboxes created by <TT>&quot;Newt::TextboxReflowed()&quot;</TT>, this is
always the same as the height of the textbox.
<P>

Please note that the order of the parameters of Newt::ReflowText and 
Newt::TextboxReflowed differs from the C <FONT SIZE="-1">API</FONT> to allow lists of text but
currently only TextboxReflowed allows this.
<A NAME="lbAU">&nbsp;</A>
<H3>Scrollbars</H3>

<A NAME="ixABO"></A>
Scrollbars may be attached to forms to let them contain more data than
they have space for. Currently, there can only be vertical scrollbars:
<P>



<PRE>
    $scroll = Newt::VScrollbar($height, 
                               $normalColorset, 
                               $thumbColorset);

</PRE>


<P>

When a scrollbar is created, it is given a position on the screen, a
height, and two colors. The first color is the color used for drawing
the scrollbar, and the second color is used for drawing the
thumb. This is the only place in newt where an application
specifically sets colors for a component. It s done here to let the
colors a scrollbar use match the colors of the component the scrollbar
is mated too. When a scrollbar is being used with a form,
<TT>$normalColorset</TT> is often <TT>&quot;NEWT_COLORSET_WINDOW&quot;</TT> and
<TT>$thumbColorset</TT> <TT>&quot;NEWT_COLORSET_ACTCHECKBOX&quot;</TT>.
<P>

If you do not want to bother with colors, you can omit the last two
parameters and let Newt use the defaults.
<P>

As the scrollbar is normally updated by the component it is mated with,
there is no public interface for moving the thumb.
<A NAME="lbAV">&nbsp;</A>
<H2>Panels</H2>

<A NAME="ixABP"></A>
Panels are high level grid-like constructs that are used to group
components. You create them by specifying the number of columns and
rows you want, as well as a caption to be used when the panel is
displayed as a toplevel:
<P>



<PRE>
    $panel = Newt::Panel(2, 3, &quot;Panel example&quot;);

</PRE>


<P>

When run, panels are centered by default, but you can specify a
position relative to the topleft corner of the screen by appending two
optional integers:
<P>



<PRE>
    $panel = Newt::Panel(2, 3, &quot;Panel example&quot;, 5, 5);

</PRE>


<P>

Adding components to a panel is straightforward, you just have to
indicate the position the component will take in the grid:
<P>



<PRE>
   $panel1-&gt;Add(0, 0, $mycomponent);

</PRE>


<P>

Several optional parameters my however be used when adding components:
<P>



<PRE>
    $panel1-&gt;Add($col, 
                 $row, 
                 $mycomponent,
                 $anchor,
                 $padleft, 
                 $padtop,
                 $padright,
                 $padbottom,
                 $flag);

</PRE>


<P>

You can specify the side of the cell to which the component will be
aligned by specifying an anchor. The anchor values avalaible are
<TT>&quot;NEWT_ANCHOR_LEFT&quot;</TT>, <TT>&quot;NEWT_ANCHOR_RIGHT&quot;</TT>, <TT>&quot;NEWT_ANCHOR_TOP&quot;</TT>,
<TT>&quot;NEWT_ANCHOR_BOTTOM&quot;</TT>.
<P>

You can ask for more space on the sides of the component, perhaps to
get a cleaner, less cluttered presentation using the padding
parameters, and specifiying an integer value.
<P>

Panels may be nested. For this to be done you only have to add a panel
to another as you would with any other component.
<P>

To run a panel as a toplevel and get user input, you may do the
following:
<P>



<PRE>
    ($reason, $data) = $panel-&gt;Run();

    if ($reason eq NEWT_EXIT_HOTKEY) {
      if ($data eq NEWT_KEY_F12) {
        print &quot;F12 hotkey was pressed\n&quot;;
      } else {
        print &quot;Some hotkey other than F12 was pressed\n&quot;;
      }
    } else {
      print 'Form terminated by button ', $data-&gt;Tag(), &quot;\n&quot;;
    }

</PRE>


<P>

As can be seen on the example, when called in a list context
<TT>&quot;Run()&quot;</TT> returns two values, one is the reason why the form terminated
and the other is an associated data. In a scalar context only the data
is returned. Posible values for the reason are:
<DL COMPACT>
<DT>NEWT_EXIT_HOTKEY<DD>


<A NAME="ixABQ"></A>
The form exited because a hotkey was pressed. The associated data
contains the key pressed, that is, one of NEWT_KEY_* values. See
Hotkeys later for more information.
<DT>NEWT_EXIT_COMPONENT<DD>


<A NAME="ixABR"></A>
The form exited because a component was activated, a button, for
instance a button. The associated data is a reference to the
component involved.
</DL>
<A NAME="lbAW">&nbsp;</A>
<H3>Hotkeys</H3>

<A NAME="ixABS"></A>
Normally, a panel terminates when the user presses a button, but you
can define some keys as ``hotkeys'' that will make the <TT>&quot;Run()&quot;</TT> function
return with <TT>&quot;NEWT_EXIT_HOTKEY&quot;</TT>. Yo do this by issuing the folowing:
<P>



<PRE>
   $panel-&gt;AddHotKey(NEWT_KEY_F11);

</PRE>


<P>

F12 is always defined to be a hotkey.
<A NAME="lbAX">&nbsp;</A>
<H3>Drawing panels instead of running them</H3>

<A NAME="ixABT"></A>
When you run a panel the terminal is blocked until the user presses a
component or a key that causes the panel to exit. Sometimes is useful
to present the interface to the user without blocking the execution of
code. This can be done by only drawing the panel, not running it. It
is easy to show an advance status for a lengthy operation like this:
<P>



<PRE>
   $i = 1;
   foreach (@items) {
      $label-&gt;Set(&quot;Processing item $i&quot;);
      $panel-&gt;Draw();
      $scale-&gt;Set($i);
      process_item($_);
      $i++
   }

</PRE>


<A NAME="lbAY">&nbsp;</A>
<H3>Hiding panels</H3>

<A NAME="ixABU"></A>
Panels can be hidden in case you want by using the following:
<P>



<PRE>
    $panel-&gt;Hide()

</PRE>


<A NAME="lbAZ">&nbsp;</A>
<H2>Constants</H2>

<A NAME="ixABV"></A>
You can import all the constants exported by this package as needed
or using several predefined tags, with the following syntax:
<P>



<PRE>
    use Newt qw(:exits :keys);

</PRE>


<DL COMPACT>
<DT>exits NEWT_EXIT_* constants<DD>
<A NAME="ixABW"></A>

<DT>keys NEWT_KEY_* constants<DD>
<A NAME="ixABX"></A>
<DT>anchors NEWT_ANCHOR_* constants<DD>
<A NAME="ixABY"></A>
<DT>colorsets NEWT_COLORSET_* constanst<DD>
<A NAME="ixABZ"></A>
<DT>flags NEWT_FLAG_* constants<DD>
<A NAME="ixACA"></A>
<DT>entry NEWT_ENTRY_* constants<DD>
<A NAME="ixACB"></A>
<DT>fd NEWT_FD_* constants<DD>
<A NAME="ixACC"></A>
<DT>grid NEWT_GRID_* constants<DD>
<A NAME="ixACD"></A>
<DT>textbox NEWT_TEXTBOX_* constants<DD>
<A NAME="ixACE"></A>
<DT>macros<DD>
<A NAME="ixACF"></A>

macros to make useful buttons and panels: <FONT SIZE="-1">OK_BUTTON</FONT>, <FONT SIZE="-1">CANCEL_BUTTON</FONT>,
<FONT SIZE="-1">QUIT_BUTTON</FONT>, <FONT SIZE="-1">BACK_BUTTON</FONT>, <FONT SIZE="-1">OK_CANCEL_PANEL</FONT>, <FONT SIZE="-1">OK_BACK_PANEL</FONT>. This macros
only create components which are properly tagged.
</DL>
<A NAME="lbBA">&nbsp;</A>
<H2>TO DO</H2>

<A NAME="ixACG"></A>
<DL COMPACT>
<DT>Scrollable panels.<DD>
<A NAME="ixACH"></A>

<DT>Some forms stuff, like watching file descriptors.<DD>
<A NAME="ixACI"></A>

</DL>
<A NAME="lbBB">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixACJ"></A>
<I>Writing programs using Newt</I>, by Erik Troan.
<A NAME="lbBC">&nbsp;</A>
<H2>THANKS TO</H2>

<A NAME="ixACK"></A>
Erik Troan, for writing this useful library. Thanks for his tutorial,
too, from where I stole complete paragraphs for this documentation,
I'm afraid.
<A NAME="lbBD">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixACL"></A>
The original author of the Red Hat newt library is Erik Troan,
&lt;<I><A HREF="mailto:ewt@redhat.com">ewt@redhat.com</A></I>&gt; The author of this Perl bindings is Alejandro
Escalante Medina, &lt;<I><A HREF="mailto:amedina@msg.com.mx">amedina@msg.com.mx</A></I>&gt;
<A NAME="lbBE">&nbsp;</A>
<H2>DATE</H2>

<A NAME="ixACM"></A>
Version 0.1, 5th Nov 1998
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">Basic Newt functions</A><DD>
<DT><A HREF="#lbAF">Keyboard input</A><DD>
<DT><A HREF="#lbAG">Drawing text on the root window</A><DD>
<DT><A HREF="#lbAH">Suspending Newt applications</A><DD>
<DT><A HREF="#lbAI">Components</A><DD>
<DL>
<DT><A HREF="#lbAJ">General component manipulation</A><DD>
<DT><A HREF="#lbAK">Buttons</A><DD>
<DT><A HREF="#lbAL">Labels</A><DD>
<DT><A HREF="#lbAM">Entry boxes</A><DD>
<DT><A HREF="#lbAN">Checkboxes</A><DD>
<DT><A HREF="#lbAO">Radio groups</A><DD>
<DT><A HREF="#lbAP">Listboxes</A><DD>
<DT><A HREF="#lbAQ"></A><DD>
<DT><A HREF="#lbAR">Scales</A><DD>
<DT><A HREF="#lbAS">Textboxes</A><DD>
<DT><A HREF="#lbAT">Reflowing text</A><DD>
<DT><A HREF="#lbAU">Scrollbars</A><DD>
</DL>
<DT><A HREF="#lbAV">Panels</A><DD>
<DL>
<DT><A HREF="#lbAW">Hotkeys</A><DD>
<DT><A HREF="#lbAX">Drawing panels instead of running them</A><DD>
<DT><A HREF="#lbAY">Hiding panels</A><DD>
</DL>
<DT><A HREF="#lbAZ">Constants</A><DD>
<DT><A HREF="#lbBA">TO DO</A><DD>
<DT><A HREF="#lbBB">SEE ALSO</A><DD>
<DT><A HREF="#lbBC">THANKS TO</A><DD>
<DT><A HREF="#lbBD">AUTHOR</A><DD>
<DT><A HREF="#lbBE">DATE</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/man/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:35 GMT, December 24, 2015
</div></body>
</HTML>
