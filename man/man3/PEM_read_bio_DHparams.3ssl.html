<!DOCTYPE html>

<HTML><head><TITLE>Manpage of pem</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/man/index.html">linux man pages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>pem</H1>
Section: OpenSSL (3)<BR>Updated: 2009-06-02<BR><A HREF="#index">Index</A>
<A HREF="/man/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

PEM, PEM_read_bio_PrivateKey, PEM_read_PrivateKey, PEM_write_bio_PrivateKey, PEM_write_PrivateKey, PEM_write_bio_PKCS8PrivateKey, PEM_write_PKCS8PrivateKey, PEM_write_bio_PKCS8PrivateKey_nid, PEM_write_PKCS8PrivateKey_nid, PEM_read_bio_PUBKEY, PEM_read_PUBKEY, PEM_write_bio_PUBKEY, PEM_write_PUBKEY, PEM_read_bio_RSAPrivateKey, PEM_read_RSAPrivateKey, PEM_write_bio_RSAPrivateKey, PEM_write_RSAPrivateKey, PEM_read_bio_RSAPublicKey, PEM_read_RSAPublicKey, PEM_write_bio_RSAPublicKey, PEM_write_RSAPublicKey, PEM_read_bio_RSA_PUBKEY, PEM_read_RSA_PUBKEY, PEM_write_bio_RSA_PUBKEY, PEM_write_RSA_PUBKEY, PEM_read_bio_DSAPrivateKey, PEM_read_DSAPrivateKey, PEM_write_bio_DSAPrivateKey, PEM_write_DSAPrivateKey, PEM_read_bio_DSA_PUBKEY, PEM_read_DSA_PUBKEY, PEM_write_bio_DSA_PUBKEY, PEM_write_DSA_PUBKEY, PEM_read_bio_DSAparams, PEM_read_DSAparams, PEM_write_bio_DSAparams, PEM_write_DSAparams, PEM_read_bio_DHparams, PEM_read_DHparams, PEM_write_bio_DHparams, PEM_write_DHparams, PEM_read_bio_X509, PEM_read_X509, PEM_write_bio_X509, PEM_write_X509, PEM_read_bio_X509_AUX, PEM_read_X509_AUX, PEM_write_bio_X509_AUX, PEM_write_X509_AUX, PEM_read_bio_X509_REQ, PEM_read_X509_REQ, PEM_write_bio_X509_REQ, PEM_write_X509_REQ, PEM_write_bio_X509_REQ_NEW, PEM_write_X509_REQ_NEW, PEM_read_bio_X509_CRL, PEM_read_X509_CRL, PEM_write_bio_X509_CRL, PEM_write_X509_CRL, PEM_read_bio_PKCS7, PEM_read_PKCS7, PEM_write_bio_PKCS7, PEM_write_PKCS7, PEM_read_bio_NETSCAPE_CERT_SEQUENCE, PEM_read_NETSCAPE_CERT_SEQUENCE, PEM_write_bio_NETSCAPE_CERT_SEQUENCE, PEM_write_NETSCAPE_CERT_SEQUENCE - PEM routines
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
 #include &lt;<A HREF="file:/usr/include/openssl/pem.h">openssl/pem.h</A>&gt;

 EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x,
                                        pem_password_cb *cb, void *u);

 EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x,
                                        pem_password_cb *cb, void *u);

 int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);

 int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);

 int PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                        char *kstr, int klen,
                                        pem_password_cb *cb, void *u);

 int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                        char *kstr, int klen,
                                        pem_password_cb *cb, void *u);

 int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,
                                        char *kstr, int klen,
                                        pem_password_cb *cb, void *u);

 int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,
                                        char *kstr, int klen,
                                        pem_password_cb *cb, void *u);

 EVP_PKEY *PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x,
                                        pem_password_cb *cb, void *u);

 EVP_PKEY *PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x,
                                        pem_password_cb *cb, void *u);

 int PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x);
 int PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x);

 RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x,
                                        pem_password_cb *cb, void *u);

 RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **x,
                                        pem_password_cb *cb, void *u);

 int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);

 int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);

 RSA *PEM_read_bio_RSAPublicKey(BIO *bp, RSA **x,
                                        pem_password_cb *cb, void *u);

 RSA *PEM_read_RSAPublicKey(FILE *fp, RSA **x,
                                        pem_password_cb *cb, void *u);

 int PEM_write_bio_RSAPublicKey(BIO *bp, RSA *x);

 int PEM_write_RSAPublicKey(FILE *fp, RSA *x);

 RSA *PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x,
                                        pem_password_cb *cb, void *u);

 RSA *PEM_read_RSA_PUBKEY(FILE *fp, RSA **x,
                                        pem_password_cb *cb, void *u);

 int PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x);

 int PEM_write_RSA_PUBKEY(FILE *fp, RSA *x);

 DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **x,
                                        pem_password_cb *cb, void *u);

 DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **x,
                                        pem_password_cb *cb, void *u);

 int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);

 int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);

 DSA *PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x,
                                        pem_password_cb *cb, void *u);

 DSA *PEM_read_DSA_PUBKEY(FILE *fp, DSA **x,
                                        pem_password_cb *cb, void *u);

 int PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x);

 int PEM_write_DSA_PUBKEY(FILE *fp, DSA *x);

 DSA *PEM_read_bio_DSAparams(BIO *bp, DSA **x, pem_password_cb *cb, void *u);

 DSA *PEM_read_DSAparams(FILE *fp, DSA **x, pem_password_cb *cb, void *u);

 int PEM_write_bio_DSAparams(BIO *bp, DSA *x);

 int PEM_write_DSAparams(FILE *fp, DSA *x);

 DH *PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u);

 DH *PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u);

 int PEM_write_bio_DHparams(BIO *bp, DH *x);

 int PEM_write_DHparams(FILE *fp, DH *x);

 X509 *PEM_read_bio_X509(BIO *bp, X509 **x, pem_password_cb *cb, void *u);

 X509 *PEM_read_X509(FILE *fp, X509 **x, pem_password_cb *cb, void *u);

 int PEM_write_bio_X509(BIO *bp, X509 *x);

 int PEM_write_X509(FILE *fp, X509 *x);

 X509 *PEM_read_bio_X509_AUX(BIO *bp, X509 **x, pem_password_cb *cb, void *u);

 X509 *PEM_read_X509_AUX(FILE *fp, X509 **x, pem_password_cb *cb, void *u);

 int PEM_write_bio_X509_AUX(BIO *bp, X509 *x);

 int PEM_write_X509_AUX(FILE *fp, X509 *x);

 X509_REQ *PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x,
                                        pem_password_cb *cb, void *u);

 X509_REQ *PEM_read_X509_REQ(FILE *fp, X509_REQ **x,
                                        pem_password_cb *cb, void *u);

 int PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x);

 int PEM_write_X509_REQ(FILE *fp, X509_REQ *x);

 int PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x);

 int PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x);

 X509_CRL *PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x,
                                        pem_password_cb *cb, void *u);
 X509_CRL *PEM_read_X509_CRL(FILE *fp, X509_CRL **x,
                                        pem_password_cb *cb, void *u);
 int PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x);
 int PEM_write_X509_CRL(FILE *fp, X509_CRL *x);

 PKCS7 *PEM_read_bio_PKCS7(BIO *bp, PKCS7 **x, pem_password_cb *cb, void *u);

 PKCS7 *PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb *cb, void *u);

 int PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x);

 int PEM_write_PKCS7(FILE *fp, PKCS7 *x);

 NETSCAPE_CERT_SEQUENCE *PEM_read_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp,
                                                NETSCAPE_CERT_SEQUENCE **x,
                                                pem_password_cb *cb, void *u);

 NETSCAPE_CERT_SEQUENCE *PEM_read_NETSCAPE_CERT_SEQUENCE(FILE *fp,
                                                NETSCAPE_CERT_SEQUENCE **x,
                                                pem_password_cb *cb, void *u);

 int PEM_write_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE *x);

 int PEM_write_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE *x);

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
The <FONT SIZE="-1">PEM</FONT> functions read or write structures in <FONT SIZE="-1">PEM</FONT> format. In
this sense <FONT SIZE="-1">PEM</FONT> format is simply base64 encoded data surrounded
by header lines.
<P>

For more details about the meaning of arguments see the
<B></B><FONT SIZE="-1"><B>PEM</B></FONT><B> </B><FONT SIZE="-1"><B>FUNCTION</B></FONT><B> </B><FONT SIZE="-1"><B>ARGUMENTS</B></FONT><B></B> section.
<P>

Each operation has four functions associated with it. For
clarity the term &quot;<B>foobar</B> functions&quot; will be used to collectively
refer to the <I>PEM_read_bio_foobar()</I>, <I>PEM_read_foobar()</I>,
<I>PEM_write_bio_foobar()</I> and <I>PEM_write_foobar()</I> functions.
<P>

The <B>PrivateKey</B> functions read or write a private key in
<FONT SIZE="-1">PEM</FONT> format using an <FONT SIZE="-1">EVP_PKEY</FONT> structure. The write routines use
``traditional'' private key format and can handle both <FONT SIZE="-1">RSA</FONT> and <FONT SIZE="-1">DSA</FONT>
private keys. The read functions can additionally transparently
handle PKCS#8 format encrypted and unencrypted keys too.
<P>

<I>PEM_write_bio_PKCS8PrivateKey()</I> and <I>PEM_write_PKCS8PrivateKey()</I>
write a private key in an <FONT SIZE="-1">EVP_PKEY</FONT> structure in PKCS#8
EncryptedPrivateKeyInfo format using PKCS#5 v2.0 password based encryption
algorithms. The <B>cipher</B> argument specifies the encryption algoritm to
use: unlike all other <FONT SIZE="-1">PEM</FONT> routines the encryption is applied at the
PKCS#8 level and not in the <FONT SIZE="-1">PEM</FONT> headers. If <B>cipher</B> is <FONT SIZE="-1">NULL</FONT> then no
encryption is used and a PKCS#8 PrivateKeyInfo structure is used instead.
<P>

<I>PEM_write_bio_PKCS8PrivateKey_nid()</I> and <I>PEM_write_PKCS8PrivateKey_nid()</I>
also write out a private key as a PKCS#8 EncryptedPrivateKeyInfo however
it uses PKCS#5 v1.5 or PKCS#12 encryption algorithms instead. The algorithm
to use is specified in the <B>nid</B> parameter and should be the <FONT SIZE="-1">NID</FONT> of the
corresponding <FONT SIZE="-1">OBJECT</FONT> <FONT SIZE="-1">IDENTIFIER</FONT> (see <FONT SIZE="-1">NOTES</FONT> section).
<P>

The <B></B><FONT SIZE="-1"><B>PUBKEY</B></FONT><B></B> functions process a public key using an <FONT SIZE="-1">EVP_PKEY</FONT>
structure. The public key is encoded as a SubjectPublicKeyInfo
structure.
<P>

The <B>RSAPrivateKey</B> functions process an <FONT SIZE="-1">RSA</FONT> private key using an
<FONT SIZE="-1">RSA</FONT> structure. It handles the same formats as the <B>PrivateKey</B>
functions but an error occurs if the private key is not <FONT SIZE="-1">RSA</FONT>.
<P>

The <B>RSAPublicKey</B> functions process an <FONT SIZE="-1">RSA</FONT> public key using an
<FONT SIZE="-1">RSA</FONT> structure. The public key is encoded using a PKCS#1 RSAPublicKey
structure.
<P>

The <B></B><FONT SIZE="-1"><B>RSA_PUBKEY</B></FONT><B></B> functions also process an <FONT SIZE="-1">RSA</FONT> public key using
an <FONT SIZE="-1">RSA</FONT> structure. However the public key is encoded using a
SubjectPublicKeyInfo structure and an error occurs if the public
key is not <FONT SIZE="-1">RSA</FONT>.
<P>

The <B>DSAPrivateKey</B> functions process a <FONT SIZE="-1">DSA</FONT> private key using a
<FONT SIZE="-1">DSA</FONT> structure. It handles the same formats as the <B>PrivateKey</B>
functions but an error occurs if the private key is not <FONT SIZE="-1">DSA</FONT>.
<P>

The <B></B><FONT SIZE="-1"><B>DSA_PUBKEY</B></FONT><B></B> functions process a <FONT SIZE="-1">DSA</FONT> public key using
a <FONT SIZE="-1">DSA</FONT> structure. The public key is encoded using a
SubjectPublicKeyInfo structure and an error occurs if the public
key is not <FONT SIZE="-1">DSA</FONT>.
<P>

The <B>DSAparams</B> functions process <FONT SIZE="-1">DSA</FONT> parameters using a <FONT SIZE="-1">DSA</FONT>
structure. The parameters are encoded using a foobar structure.
<P>

The <B>DHparams</B> functions process <FONT SIZE="-1">DH</FONT> parameters using a <FONT SIZE="-1">DH</FONT>
structure. The parameters are encoded using a PKCS#3 DHparameter
structure.
<P>

The <B>X509</B> functions process an X509 certificate using an X509
structure. They will also process a trusted X509 certificate but
any trust settings are discarded.
<P>

The <B>X509_AUX</B> functions process a trusted X509 certificate using
an X509 structure.
<P>

The <B>X509_REQ</B> and <B>X509_REQ_NEW</B> functions process a PKCS#10
certificate request using an X509_REQ structure. The <B>X509_REQ</B>
write functions use <B></B><FONT SIZE="-1"><B>CERTIFICATE</B></FONT><B> </B><FONT SIZE="-1"><B>REQUEST</B></FONT><B></B> in the header whereas
the <B>X509_REQ_NEW</B> functions use <B></B><FONT SIZE="-1"><B>NEW</B></FONT><B> </B><FONT SIZE="-1"><B>CERTIFICATE</B></FONT><B> </B><FONT SIZE="-1"><B>REQUEST</B></FONT><B></B>
(as required by some CAs). The <B>X509_REQ</B> read functions will
handle either form so there are no <B>X509_REQ_NEW</B> read functions.
<P>

The <B>X509_CRL</B> functions process an X509 <FONT SIZE="-1">CRL</FONT> using an X509_CRL
structure.
<P>

The <B></B><FONT SIZE="-1"><B>PKCS7</B></FONT><B></B> functions process a PKCS#7 ContentInfo using a <FONT SIZE="-1">PKCS7</FONT>
structure.
<P>

The <B></B><FONT SIZE="-1"><B>NETSCAPE_CERT_SEQUENCE</B></FONT><B></B> functions process a Netscape Certificate
Sequence using a <FONT SIZE="-1">NETSCAPE_CERT_SEQUENCE</FONT> structure.
<A NAME="lbAE">&nbsp;</A>
<H2>PEM FUNCTION ARGUMENTS</H2>

<A NAME="ixAAE"></A>
The <FONT SIZE="-1">PEM</FONT> functions have many common arguments.
<P>

The <B>bp</B> <FONT SIZE="-1">BIO</FONT> parameter (if present) specifies the <FONT SIZE="-1">BIO</FONT> to read from
or write to.
<P>

The <B>fp</B> <FONT SIZE="-1">FILE</FONT> parameter (if present) specifies the <FONT SIZE="-1">FILE</FONT> pointer to
read from or write to.
<P>

The <FONT SIZE="-1">PEM</FONT> read functions all take an argument <B></B><FONT SIZE="-1"><B>TYPE</B></FONT><B> **x</B> and return
a <B></B><FONT SIZE="-1"><B>TYPE</B></FONT><B> *</B> pointer. Where <B></B><FONT SIZE="-1"><B>TYPE</B></FONT><B></B> is whatever structure the function
uses. If <B>x</B> is <FONT SIZE="-1">NULL</FONT> then the parameter is ignored. If <B>x</B> is not
<FONT SIZE="-1">NULL</FONT> but <B>*x</B> is <FONT SIZE="-1">NULL</FONT> then the structure returned will be written
to <B>*x</B>. If neither <B>x</B> nor <B>*x</B> is <FONT SIZE="-1">NULL</FONT> then an attempt is made
to reuse the structure at <B>*x</B> (but see <FONT SIZE="-1">BUGS</FONT> and <FONT SIZE="-1">EXAMPLES</FONT> sections).
Irrespective of the value of <B>x</B> a pointer to the structure is always
returned (or <FONT SIZE="-1">NULL</FONT> if an error occurred).
<P>

The <FONT SIZE="-1">PEM</FONT> functions which write private keys take an <B>enc</B> parameter
which specifies the encryption algorithm to use, encryption is done
at the <FONT SIZE="-1">PEM</FONT> level. If this parameter is set to <FONT SIZE="-1">NULL</FONT> then the private
key is written in unencrypted form.
<P>

The <B>cb</B> argument is the callback to use when querying for the pass
phrase used for encrypted <FONT SIZE="-1">PEM</FONT> structures (normally only private keys).
<P>

For the <FONT SIZE="-1">PEM</FONT> write routines if the <B>kstr</B> parameter is not <FONT SIZE="-1">NULL</FONT> then
<B>klen</B> bytes at <B>kstr</B> are used as the passphrase and <B>cb</B> is
ignored.
<P>

If the <B>cb</B> parameters is set to <FONT SIZE="-1">NULL</FONT> and the <B>u</B> parameter is not
<FONT SIZE="-1">NULL</FONT> then the <B>u</B> parameter is interpreted as a null terminated string
to use as the passphrase. If both <B>cb</B> and <B>u</B> are <FONT SIZE="-1">NULL</FONT> then the
default callback routine is used which will typically prompt for the
passphrase on the current terminal with echoing turned off.
<P>

The default passphrase callback is sometimes inappropriate (for example
in a <FONT SIZE="-1">GUI</FONT> application) so an alternative can be supplied. The callback
routine has the following form:
<P>



<PRE>
 int cb(char *buf, int size, int rwflag, void *u);

</PRE>


<P>

<B>buf</B> is the buffer to write the passphrase to. <B>size</B> is the maximum
length of the passphrase (i.e. the size of buf). <B>rwflag</B> is a flag
which is set to 0 when reading and 1 when writing. A typical routine
will ask the user to verify the passphrase (for example by prompting
for it twice) if <B>rwflag</B> is 1. The <B>u</B> parameter has the same
value as the <B>u</B> parameter passed to the <FONT SIZE="-1">PEM</FONT> routine. It allows
arbitrary data to be passed to the callback by the application
(for example a window handle in a <FONT SIZE="-1">GUI</FONT> application). The callback
<B>must</B> return the number of characters in the passphrase or 0 if
an error occurred.
<A NAME="lbAF">&nbsp;</A>
<H2>EXAMPLES</H2>

<A NAME="ixAAF"></A>
Although the <FONT SIZE="-1">PEM</FONT> routines take several arguments in almost all applications
most of them are set to 0 or <FONT SIZE="-1">NULL</FONT>.
<P>

Read a certificate in <FONT SIZE="-1">PEM</FONT> format from a <FONT SIZE="-1">BIO:</FONT>
<P>



<PRE>
 X509 *x;
 x = PEM_read_bio_X509(bp, NULL, 0, NULL);
 if (x == NULL)
        {
        /* Error */
        }

</PRE>


<P>

Alternative method:
<P>



<PRE>
 X509 *x = NULL;
 if (!PEM_read_bio_X509(bp, &amp;x, 0, NULL))
        {
        /* Error */
        }

</PRE>


<P>

Write a certificate to a <FONT SIZE="-1">BIO:</FONT>
<P>



<PRE>
 if (!PEM_write_bio_X509(bp, x))
        {
        /* Error */
        }

</PRE>


<P>

Write an unencrypted private key to a <FONT SIZE="-1">FILE</FONT> pointer:
<P>



<PRE>
 if (!PEM_write_PrivateKey(fp, key, NULL, NULL, 0, 0, NULL))
        {
        /* Error */
        }

</PRE>


<P>

Write a private key (using traditional format) to a <FONT SIZE="-1">BIO</FONT> using
triple <FONT SIZE="-1">DES</FONT> encryption, the pass phrase is prompted for:
<P>



<PRE>
 if (!PEM_write_bio_PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, NULL))
        {
        /* Error */
        }

</PRE>


<P>

Write a private key (using PKCS#8 format) to a <FONT SIZE="-1">BIO</FONT> using triple
<FONT SIZE="-1">DES</FONT> encryption, using the pass phrase ``hello'':
<P>



<PRE>
 if (!PEM_write_bio_PKCS8PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, &quot;hello&quot;))
        {
        /* Error */
        }

</PRE>


<P>

Read a private key from a <FONT SIZE="-1">BIO</FONT> using the pass phrase ``hello'':
<P>



<PRE>
 key = PEM_read_bio_PrivateKey(bp, NULL, 0, &quot;hello&quot;);
 if (key == NULL)
        {
        /* Error */
        }

</PRE>


<P>

Read a private key from a <FONT SIZE="-1">BIO</FONT> using a pass phrase callback:
<P>



<PRE>
 key = PEM_read_bio_PrivateKey(bp, NULL, pass_cb, &quot;My Private Key&quot;);
 if (key == NULL)
        {
        /* Error */
        }

</PRE>


<P>

Skeleton pass phrase callback:
<P>



<PRE>
 int pass_cb(char *buf, int size, int rwflag, void *u);
        {
        int len;
        char *tmp;
        /* We'd probably do something else if 'rwflag' is 1 */
        printf(&quot;Enter pass phrase for \&quot;%s\&quot;\n&quot;, u);

        /* get pass phrase, length 'len' into 'tmp' */
        tmp = &quot;hello&quot;;
        len = strlen(tmp);

        if (len &lt;= 0) return 0;
        /* if too long, truncate */
        if (len &gt; size) len = size;
        memcpy(buf, tmp, len);
        return len;
        }

</PRE>


<A NAME="lbAG">&nbsp;</A>
<H2>NOTES</H2>

<A NAME="ixAAG"></A>
The old <B>PrivateKey</B> write routines are retained for compatibility.
New applications should write private keys using the
<I>PEM_write_bio_PKCS8PrivateKey()</I> or <I>PEM_write_PKCS8PrivateKey()</I> routines
because they are more secure (they use an iteration count of 2048 whereas
the traditional routines use a count of 1) unless compatibility with older
versions of OpenSSL is important.
<P>

The <B>PrivateKey</B> read routines can be used in all applications because
they handle all formats transparently.
<P>

A frequent cause of problems is attempting to use the <FONT SIZE="-1">PEM</FONT> routines like
this:
<P>



<PRE>
 X509 *x;
 PEM_read_bio_X509(bp, &amp;x, 0, NULL);

</PRE>


<P>

this is a bug because an attempt will be made to reuse the data at <B>x</B>
which is an uninitialised pointer.
<A NAME="lbAH">&nbsp;</A>
<H2>PEM ENCRYPTION FORMAT</H2>

<A NAME="ixAAH"></A>
This old <B>PrivateKey</B> routines use a non standard technique for encryption.
<P>

The private key (or other data) takes the following form:
<P>



<PRE>
 -----BEGIN RSA PRIVATE KEY-----
 Proc-Type: 4,ENCRYPTED
 DEK-Info: DES-EDE3-CBC,3F17F5316E2BAC89

 ...base64 encoded data...
 -----END RSA PRIVATE KEY-----

</PRE>


<P>

The line beginning DEK-Info contains two comma separated pieces of information:
the encryption algorithm name as used by <I>EVP_get_cipherbyname()</I> and an 8
byte <B>salt</B> encoded as a set of hexadecimal digits.
<P>

After this is the base64 encoded encrypted data.
<P>

The encryption key is determined using <I>EVP_bytestokey()</I>, using <B>salt</B> and an
iteration count of 1. The <FONT SIZE="-1">IV</FONT> used is the value of <B>salt</B> and *not* the <FONT SIZE="-1">IV</FONT>
returned by <I>EVP_bytestokey()</I>.
<A NAME="lbAI">&nbsp;</A>
<H2>BUGS</H2>

<A NAME="ixAAI"></A>
The <FONT SIZE="-1">PEM</FONT> read routines in some versions of OpenSSL will not correctly reuse
an existing structure. Therefore the following:
<P>



<PRE>
 PEM_read_bio_X509(bp, &amp;x, 0, NULL);

</PRE>


<P>

where <B>x</B> already contains a valid certificate, may not work, whereas:
<P>



<PRE>
 X509_free(x);
 x = PEM_read_bio_X509(bp, NULL, 0, NULL);

</PRE>


<P>

is guaranteed to work.
<A NAME="lbAJ">&nbsp;</A>
<H2>RETURN CODES</H2>

<A NAME="ixAAJ"></A>
The read routines return either a pointer to the structure read or <FONT SIZE="-1">NULL</FONT>
if an error occurred.
<P>

The write routines return 1 for success or 0 for failure.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">PEM FUNCTION ARGUMENTS</A><DD>
<DT><A HREF="#lbAF">EXAMPLES</A><DD>
<DT><A HREF="#lbAG">NOTES</A><DD>
<DT><A HREF="#lbAH">PEM ENCRYPTION FORMAT</A><DD>
<DT><A HREF="#lbAI">BUGS</A><DD>
<DT><A HREF="#lbAJ">RETURN CODES</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/man/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:35 GMT, December 24, 2015
</div></body>
</HTML>
