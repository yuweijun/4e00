<!DOCTYPE html>

<HTML><head><TITLE>Manpage of Apache::TestUtil</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/man/index.html">linux man pages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>Apache::TestUtil</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2007-12-31<BR><A HREF="#index">Index</A>
<A HREF="/man/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Apache::TestUtil - Utility functions for writing tests
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
  use Apache::Test;
  use Apache::TestUtil;

  ok t_cmp(&quot;foo&quot;, &quot;foo&quot;, &quot;sanity check&quot;);
  t_write_file(&quot;filename&quot;, @content);
  my $fh = t_open_file($filename);
  t_mkdir(&quot;/foo/bar&quot;);
  t_rmtree(&quot;/foo/bar&quot;);
  t_is_equal($a, $b);

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
<TT>&quot;Apache::TestUtil&quot;</TT> automatically exports a number of functions useful
in writing tests.
<P>

All the files and directories created using the functions from this
package will be automatically destroyed at the end of the program
execution (via <FONT SIZE="-1">END</FONT> block). You should not use these functions other
than from within tests which should cleanup all the created
directories and files at the end of the test.
<A NAME="lbAE">&nbsp;</A>
<H2>FUNCTIONS</H2>

<A NAME="ixAAE"></A>
<DL COMPACT>
<DT><I>t_cmp()</I><DD>
<A NAME="ixAAF"></A>


<PRE>
  t_cmp($received, $expected, $comment);

</PRE>




<P>


<I>t_cmp()</I> prints the values of <I></I>$comment<I></I>, <I></I>$expected<I></I> and
<I></I>$received<I></I>. e.g.:


<P>




<PRE>
  t_cmp(1, 1, &quot;1 == 1?&quot;);

</PRE>




<P>


prints:


<P>




<PRE>
  # testing : 1 == 1?
  # expected: 1
  # received: 1

</PRE>




<P>


then it returns the result of comparison of the <I></I>$expected<I></I> and the
<I></I>$received<I></I> variables. Usually, the return value of this function is
fed directly to the <I>ok()</I> function, like this:


<P>




<PRE>
  ok t_cmp(1, 1, &quot;1 == 1?&quot;);

</PRE>




<P>


the third argument (<I></I>$comment<I></I>) is optional, mostly useful for
telling what the comparison is trying to do.


<P>


It is valid to use <TT>&quot;undef&quot;</TT> as an expected value. Therefore:


<P>




<PRE>
  my $foo;
  t_cmp(undef, $foo, &quot;undef == undef?&quot;);

</PRE>




<P>


will return a <I>true</I> value.


<P>


You can compare any two data-structures with <I>t_cmp()</I>. Just make sure
that if you pass non-scalars, you have to pass their references. The
datastructures can be deeply nested. For example you can compare:


<P>




<PRE>
  t_cmp({1 =&gt; [2..3,{5..8}], 4 =&gt; [5..6]},
        {1 =&gt; [2..3,{5..8}], 4 =&gt; [5..6]},
        &quot;hash of array of hashes&quot;);

</PRE>




<P>


You can also compare the second argument against the first as a
regex. Use the <TT>&quot;qr//&quot;</TT> function in the second argument. For example:


<P>




<PRE>
  t_cmp(&quot;abcd&quot;, qr/^abc/, &quot;regex compare&quot;);

</PRE>




<P>


will do:


<P>




<PRE>
  &quot;abcd&quot; =~ /^abc/;

</PRE>




<P>


This function is exported by default.
<DT><I>t_filepath_cmp()</I><DD>
<A NAME="ixAAG"></A>
This function is used to compare two filepaths via <I>t_cmp()</I>.
For non-Win32, it simply uses <I>t_cmp()</I> for the comparison,
but for Win32, <I>Win32::GetLongPathName()</I> is invoked to convert
the first two arguments to their <FONT SIZE="-1">DOS</FONT> long pathname. This is useful
when there is a possibility the two paths being compared
are not both represented by their long or short pathname.


<P>


This function is exported by default.
<DT><I>t_debug()</I><DD>
<A NAME="ixAAH"></A>


<PRE>
  t_debug(&quot;testing feature foo&quot;);
  t_debug(&quot;test&quot;, [1..3], 5, {a=&gt;[1..5]});

</PRE>




<P>


<I>t_debug()</I> prints out any datastructure while prepending <TT>&quot;#&quot;</TT> at the
beginning of each line, to make the debug printouts comply with
<TT>&quot;Test::Harness&quot;</TT>'s requirements. This function should be always used
for debug prints, since if in the future the debug printing will
change (e.g. redirected into a file) your tests won't need to be
changed.


<P>


the special global variable <TT>$Apache::TestUtil::DEBUG_OUTPUT</TT> can
be used to redirect the output from <I>t_debug()</I> and related calls
such as <I>t_write_file()</I>.  for example, from a server-side test
you would probably need to redirect it to <FONT SIZE="-1">STDERR:</FONT>


<P>




<PRE>
  sub handler {
    plan $r, tests =&gt; 1;

    local $Apache::TestUtil::DEBUG_OUTPUT = \*STDERR;

    t_write_file('/tmp/foo', 'bar');
    ...
  }

</PRE>




<P>


left to its own devices, <I>t_debug()</I> will collide with the standard
<FONT SIZE="-1">HTTP</FONT> protocol during server-side tests, resulting in a situation
both confusing difficult to debug.  but <FONT SIZE="-1">STDOUT</FONT> is left as the
default, since you probably don't want debug output under normal
circumstances unless running under verbose mode.


<P>


This function is exported by default.
<DT><I>t_write_test_lib()</I><DD>
<A NAME="ixAAI"></A>


<PRE>
  t_write_test_lib($filename, @lines)

</PRE>




<P>


<I>t_write_test_lib()</I> creates a new file at <I></I>$filename<I></I> or overwrites
the existing file with the content passed in <I></I>@lines<I></I>.  The file
is created in a temporary directory which is added to <TT>@INC</TT> at
test configuration time.  It is intended to be used for creating
temporary packages for testing which can be modified at run time,
see the Apache::Reload unit tests for an example.
<DT><I>t_write_file()</I><DD>
<A NAME="ixAAJ"></A>


<PRE>
  t_write_file($filename, @lines);

</PRE>




<P>


<I>t_write_file()</I> creates a new file at <I></I>$filename<I></I> or overwrites the
existing file with the content passed in <I></I>@lines<I></I>. If only the
<I></I>$filename<I></I> is passed, an empty file will be created.


<P>


If parent directories of <TT>$filename</TT> don't exist they will be
automagically created.


<P>


The generated file will be automatically deleted at the end of the
program's execution.


<P>


This function is exported by default.
<DT><I>t_append_file()</I><DD>
<A NAME="ixAAK"></A>


<PRE>
  t_append_file($filename, @lines);

</PRE>




<P>


<I>t_append_file()</I> is similar to <I>t_write_file()</I>, but it doesn't clobber
existing files and appends <TT>@lines</TT> to the end of the file. If the
file doesn't exist it will create it.


<P>


If parent directories of <TT>$filename</TT> don't exist they will be
automagically created.


<P>


The generated file will be registered to be automatically deleted at
the end of the program's execution, only if the file was created by
<I>t_append_file()</I>.


<P>


This function is exported by default.
<DT><I>t_write_shell_script()</I><DD>
<A NAME="ixAAL"></A>


<PRE>
  Apache::TestUtil::t_write_shell_script($filename, @lines);

</PRE>




<P>


Similar to <I>t_write_file()</I> but creates a portable shell/batch
script. The created filename is constructed from <TT>$filename</TT> and an
appropriate extension automatically selected according to the platform
the code is running under.


<P>


It returns the extension of the created file.
<DT><I>t_write_perl_script()</I><DD>
<A NAME="ixAAM"></A>


<PRE>
  Apache::TestUtil::t_write_perl_script($filename, @lines);

</PRE>




<P>


Similar to <I>t_write_file()</I> but creates a executable Perl script with
correctly set shebang line.
<DT><I>t_open_file()</I><DD>
<A NAME="ixAAN"></A>


<PRE>
  my $fh = t_open_file($filename);

</PRE>




<P>


<I>t_open_file()</I> opens a file <I></I>$filename<I></I> for writing and returns the
file handle to the opened file.


<P>


If parent directories of <TT>$filename</TT> don't exist they will be
automagically created.


<P>


The generated file will be automatically deleted at the end of the
program's execution.


<P>


This function is exported by default.
<DT><I>t_mkdir()</I><DD>
<A NAME="ixAAO"></A>


<PRE>
  t_mkdir($dirname);

</PRE>




<P>


<I>t_mkdir()</I> creates a directory <I></I>$dirname<I></I>. The operation will fail if
the parent directory doesn't exist.


<P>


If parent directories of <TT>$dirname</TT> don't exist they will be
automagically created.


<P>


The generated directory will be automatically deleted at the end of
the program's execution.


<P>


This function is exported by default.
<DT><I>t_rmtree()</I><DD>
<A NAME="ixAAP"></A>


<PRE>
  t_rmtree(@dirs);

</PRE>




<P>


<I>t_rmtree()</I> deletes the whole directories trees passed in <I></I>@dirs<I></I>.


<P>


This function is exported by default.
<DT><I>t_chown()</I><DD>
<A NAME="ixAAQ"></A>


<PRE>
  Apache::TestUtil::t_chown($file);

</PRE>




<P>


Change ownership of <TT>$file</TT> to the test's <I>User</I>/<I>Group</I>.  This
function is noop on platforms where <I><A HREF="/man/index.html?2+chown">chown</A></I>(2) is unsupported
(e.g. Win32).
<DT><I>t_is_equal()</I><DD>
<A NAME="ixAAR"></A>


<PRE>
  t_is_equal($a, $b);

</PRE>




<P>


<I>t_is_equal()</I> compares any two datastructures and returns 1 if they are
exactly the same, otherwise 0. The datastructures can be nested
hashes, arrays, scalars, undefs or a combination of any of these.  See
<I>t_cmp()</I> for an example.


<P>


If <TT>$b</TT> is a regex reference, the regex comparison <TT>&quot;$a =~ $b&quot;</TT> is
performed. For example:


<P>




<PRE>
  t_is_equal($server_version, qr{^Apache});

</PRE>




<P>


If comparing non-scalars make sure to pass the references to the
datastructures.


<P>


This function is exported by default.
<DT><I>t_server_log_error_is_expected()</I><DD>
<A NAME="ixAAS"></A>
If the handler's execution results in an error or a warning logged to
the <I>error_log</I> file which is expected, it's a good idea to have a
disclaimer printed before the error itself, so one can tell real
problems with tests from expected errors. For example when testing how
the package behaves under error conditions the <I>error_log</I> file might
be loaded with errors, most of which are expected.


<P>


For example if a handler is about to generate a run-time error, this
function can be used as:


<P>




<PRE>
  use Apache::TestUtil;
  ...
  sub handler {
      my $r = shift;
      ...
      t_server_log_error_is_expected();
      die &quot;failed because ...&quot;;
  }

</PRE>




<P>


After running this handler the <I>error_log</I> file will include:


<P>




<PRE>
  *** The following error entry is expected and harmless ***
  [Tue Apr 01 14:00:21 2003] [error] failed because ...

</PRE>




<P>


When more than one entry is expected, an optional numerical argument,
indicating how many entries to expect, can be passed. For example:


<P>




<PRE>
  <A HREF="/man/index.html?2+t_server_log_error_is_expected">t_server_log_error_is_expected</A>(2);

</PRE>




<P>


will generate:


<P>




<PRE>
  *** The following 2 error entries are expected and harmless ***

</PRE>




<P>


If the error is generated at compile time, the logging must be done in
the <FONT SIZE="-1">BEGIN</FONT> block at the very beginning of the file:


<P>




<PRE>
  BEGIN {
      use Apache::TestUtil;
      t_server_log_error_is_expected();
  }
  use DOES_NOT_exist;

</PRE>




<P>


After attempting to run this handler the <I>error_log</I> file will
include:


<P>




<PRE>
  *** The following error entry is expected and harmless ***
  [Tue Apr 01 14:04:49 2003] [error] Can't locate &quot;DOES_NOT_exist.pm&quot;
  in @INC (@INC contains: ...

</PRE>




<P>


Also see <TT>&quot;t_server_log_warn_is_expected()&quot;</TT> which is similar but used
for warnings.


<P>


This function is exported by default.
<DT><I>t_server_log_warn_is_expected()</I><DD>
<A NAME="ixAAT"></A>
<TT>&quot;t_server_log_warn_is_expected()&quot;</TT> generates a disclaimer for expected
warnings.


<P>


See the explanation for <TT>&quot;t_server_log_error_is_expected()&quot;</TT> for more
details.


<P>


This function is exported by default.
<DT><I>t_client_log_error_is_expected()</I><DD>
<A NAME="ixAAU"></A>
<TT>&quot;t_client_log_error_is_expected()&quot;</TT> generates a disclaimer for
expected errors. But in contrast to
<TT>&quot;t_server_log_error_is_expected()&quot;</TT> called by the client side of the
script.


<P>


See the explanation for <TT>&quot;t_server_log_error_is_expected()&quot;</TT> for more
details.


<P>


For example the following client script fails to find the handler:


<P>




<PRE>
  use Apache::Test;
  use Apache::TestUtil;
  use Apache::TestRequest qw(GET);

  plan tests =&gt; 1;

  t_client_log_error_is_expected();
  my $url = &quot;/error_document/cannot_be_found&quot;;
  my $res = GET($url);
  ok t_cmp(404, $res-&gt;code, &quot;test 404&quot;);

</PRE>




<P>


After running this test the <I>error_log</I> file will include an entry
similar to the following snippet:


<P>




<PRE>
  *** The following error entry is expected and harmless ***
  [Tue Apr 01 14:02:55 2003] [error] [client 127.0.0.1]
  File does not exist: /tmp/test/t/htdocs/error

</PRE>




<P>


When more than one entry is expected, an optional numerical argument,
indicating how many entries to expect, can be passed. For example:


<P>




<PRE>
  <A HREF="/man/index.html?2+t_client_log_error_is_expected">t_client_log_error_is_expected</A>(2);

</PRE>




<P>


will generate:


<P>




<PRE>
  *** The following 2 error entries are expected and harmless ***

</PRE>




<P>


This function is exported by default.
<DT><I>t_client_log_warn_is_expected()</I><DD>
<A NAME="ixAAV"></A>
<TT>&quot;t_client_log_warn_is_expected()&quot;</TT> generates a disclaimer for expected
warnings on the client side.


<P>


See the explanation for <TT>&quot;t_client_log_error_is_expected()&quot;</TT> for more
details.


<P>


This function is exported by default.
<DT>t_catfile('a', 'b', 'c')<DD>
<A NAME="ixAAW"></A>
This function is essentially <TT>&quot;File::Spec-&gt;catfile&quot;</TT>, but
on Win32 will use <TT>&quot;Win32::GetLongpathName()&quot;</TT> to convert the
result to a long path name (if the result is an absolute file).
The function is not exported by default.
<DT>t_catfile_apache('a', 'b', 'c')<DD>
<A NAME="ixAAX"></A>
This function is essentially <TT>&quot;File::Spec::Unix-&gt;catfile&quot;</TT>, but
on Win32 will use <TT>&quot;Win32::GetLongpathName()&quot;</TT> to convert the
result to a long path name (if the result is an absolute file).
It is useful when comparing something to that returned by Apache,
which uses a Unix-style specification with forward slashes for
directory separators. The function is not exported by default.
<DT><I>t_start_error_log_watch()</I>, <I>t_finish_error_log_watch()</I><DD>
<A NAME="ixAAY"></A>
This pair of functions provides an easy interface for checking
the presence or absense of any particular message or messages
in the httpd error_log that were generated by the httpd daemon
as part of a test suite.  It is likely, that you should proceed
this with a call to one of the t_*<I>_is_expected()</I> functions.


<P>




<PRE>
  t_start_error_log_watch();
  do_it;
  ok grep {...} t_finish_error_log_watch()

</PRE>


</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixAAZ"></A>
Stas Bekman &lt;<A HREF="mailto:stas@stason.org">stas@stason.org</A>&gt;
<A NAME="lbAG">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixABA"></A>
<I><A HREF="/man/index.html?1+perl">perl</A></I>(1)
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">FUNCTIONS</A><DD>
<DT><A HREF="#lbAF">AUTHOR</A><DD>
<DT><A HREF="#lbAG">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/man/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:11 GMT, December 24, 2015
</div></body>
</HTML>
