<!DOCTYPE html>

<HTML><head><TITLE>Manpage of docs::api::Apache2::Connection</TITLE>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/main.css" type="text/css">
</head>
<body>
 <header class="site-header">
 <div class="wrap"> <div class="site-title"><a href="/man/index.html">linux man pages</a></div>
 <div class="site-description">{"type":"programming"}</div>
 </div>
 </header>
 <div class="page-content">
<H1>docs::api::Apache2::Connection</H1>
Section: User Contributed Perl Documentation (3)<BR>Updated: 2008-04-17<BR><A HREF="#index">Index</A>
<A HREF="/man/index.html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Apache2::Connection - Perl API for Apache connection object
<A NAME="lbAC">&nbsp;</A>
<H2>Synopsis</H2>

<A NAME="ixAAC"></A>


<PRE>
  use Apache2::Connection ();
  use Apache2::RequestRec ();

  my $c = $r-&gt;connection;

  my $c = $r-&gt;connection;   
  # is connection still open?
  $status = $c-&gt;aborted;
  
  # base server
  $base_server = $c-&gt;base_server();
  
  # needed for creating buckets/brigades
  $ba = $c-&gt;bucket_alloc();
  
  # client's socket
  $socket = $c-&gt;client_socket;
  
  # unique connection id
  $id = $c-&gt;id();
  
  # connection filters stack
  $input_filters = $c-&gt;input_filters();
  $output_filters = $c-&gt;output_filters();
  
  # keep the connection alive?
  $status = $c-&gt;keepalive();
  
  # how many requests served over the current connection
  $served = $c-&gt;keepalives();
  
  # this connection's local and remote socket addresses
  $local_sa  = $c-&gt;local_addr();
  $remote_sa = $c-&gt;remote_addr();
  
  # local and remote hostnames
  $local_host = $c-&gt;local_host();
  $remote_host = $c-&gt;get_remote_host();
  $remote_host = $c-&gt;remote_host();
  
  # server and remote client's IP addresses
  $local_ip = $c-&gt;local_ip();
  $remote_ip = $c-&gt;remote_ip();
  
  # connection level Apache notes
  $notes = $c-&gt;notes();
  
  # this connection's pool
  $p = $c-&gt;pool();

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>Description</H2>

<A NAME="ixAAD"></A>
<TT>&quot;Apache2::RequestRec&quot;</TT> provides the Perl <FONT SIZE="-1">API</FONT> for Apache connection
record object.
<A NAME="lbAE">&nbsp;</A>
<H2>API</H2>

<A NAME="ixAAE"></A>
<TT>&quot;Apache2::Connection&quot;</TT> provides the following functions and/or methods:
<A NAME="lbAF">&nbsp;</A>
<H3>aborted</H3>



<A NAME="ixAAF"></A>
Check whether the connection is still open
<P>



<PRE>
  $status = $c-&gt;aborted();

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixAAG"></A>

<DT>ret: $status ( boolean )<DD>


<A NAME="ixAAH"></A>

true if the connection has been aborted, false if still open
<DT>since: 2.0.00<DD>
<A NAME="ixAAI"></A>
</DL>
<A NAME="lbAG">&nbsp;</A>
<H3>base_server</H3>



<A NAME="ixAAJ"></A>
Physical server this connection came in on (main server or vhost):
<P>



<PRE>
  $base_server = $c-&gt;base_server();

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixAAK"></A>

<DT>ret: $base_server ( Apache2::Server object )<DD>


<A NAME="ixAAL"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixAAM"></A>

</DL>
<A NAME="lbAH">&nbsp;</A>
<H3>bucket_alloc</H3>



<A NAME="ixAAN"></A>
The bucket allocator to use for all bucket/brigade creations
<P>



<PRE>
  $ba = $c-&gt;bucket_alloc();

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixAAO"></A>

<DT>ret: $ba ( APR::BucketAlloc object )<DD>


<A NAME="ixAAP"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixAAQ"></A>

</DL>
<P>

This object is needed by <TT>&quot;APR::Bucket&quot;</TT>
and <TT>&quot;APR::Brigade&quot;</TT> methods/functions.
<A NAME="lbAI">&nbsp;</A>
<H3>client_socket</H3>



<A NAME="ixAAR"></A>
Get/set the client socket
<P>



<PRE>
  $socket      = $c-&gt;client_socket;
  $prev_socket = $c-&gt;client_socket($new_socket);

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixAAS"></A>

<DT>opt arg1: $new_socket ( APR::Socket object object )<DD>


<A NAME="ixAAT"></A>

If passed a new socket will be set.
<DT>ret: $socket ( APR::Socket object object )<DD>


<A NAME="ixAAU"></A>
current client socket


<P>


if the optional argument <TT>$new_socket</TT> was passed the previous socket
object is returned.
<DT>since: 2.0.00<DD>
<A NAME="ixAAV"></A>
</DL>
<A NAME="lbAJ">&nbsp;</A>
<H3>get_remote_host</H3>



<A NAME="ixAAW"></A>
Lookup the client's <FONT SIZE="-1">DNS</FONT> hostname or <FONT SIZE="-1">IP</FONT> address
<P>



<PRE>
  $remote_host = $c-&gt;remote_host();
  $remote_host = $c-&gt;remote_host($type);
  $remote_host = $c-&gt;remote_host($type, $dir_config);

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixAAX"></A>
The current connection
<DT>opt arg1: $type ( :remotehost constant )<DD>


<A NAME="ixAAY"></A>
The type of lookup to perform:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>Apache2::Const::REMOTE_DOUBLE_REV<DD>


<A NAME="ixAAZ"></A>
will always force a <FONT SIZE="-1">DNS</FONT> lookup, and also force a double reverse
lookup, regardless of the <TT>&quot;HostnameLookups&quot;</TT> setting.  The result is
the (double reverse checked) hostname, or undef if any of the lookups
fail.
<DT>Apache2::Const::REMOTE_HOST<DD>


<A NAME="ixABA"></A>
returns the hostname, or <TT>&quot;undef&quot;</TT> if the hostname lookup fails.  It
will force a <FONT SIZE="-1">DNS</FONT> lookup according to the <TT>&quot;HostnameLookups&quot;</TT> setting.
<DT>Apache2::Const::REMOTE_NAME<DD>


<A NAME="ixABB"></A>
returns the hostname, or the dotted quad if the hostname lookup fails.
It will force a <FONT SIZE="-1">DNS</FONT> lookup according to the <TT>&quot;HostnameLookups&quot;</TT>
setting.
<DT>Apache2::Const::REMOTE_NOLOOKUP<DD>


<A NAME="ixABC"></A>
is like <TT>&quot;Apache2::Const::REMOTE_NAME&quot;</TT> except that a <FONT SIZE="-1">DNS</FONT> lookup is never
forced.
</DL>
</DL>

<DL COMPACT><DT><DD>


<P>


Default value is <TT>&quot;Apache2::Const::REMOTE_NAME&quot;</TT>.
</DL>

<DT>opt arg2: $dir_config ( Apache2::ConfVector object )<DD>


<A NAME="ixABD"></A>
The directory config vector from the request. It's needed to find the
container in which the directive <TT>&quot;HostnameLookups&quot;</TT> is set. To get one
for the current request use
<TT>&quot;$r-&gt;per_dir_config&quot;</TT>.


<P>


By default, <TT>&quot;undef&quot;</TT> is passed, in which case it's the same as if
<TT>&quot;HostnameLookups&quot;</TT> was set to <TT>&quot;Off&quot;</TT>.
<DT>ret: $remote_host ( string/undef )<DD>


<A NAME="ixABE"></A>
The remote hostname.  If the configuration directive
<B>HostNameLookups</B> is set to off, this returns the dotted decimal
representation of the client's <FONT SIZE="-1">IP</FONT> address instead. Might return
<TT>&quot;undef&quot;</TT> if the hostname is not known.
<DT>since: 2.0.00<DD>
<A NAME="ixABF"></A>
</DL>
<P>

The result of <TT>&quot;get_remote_host&quot;</TT> call is cached in
<TT>&quot;$c-&gt;remote_host&quot;</TT>. If the latter is set,
<TT>&quot;get_remote_host&quot;</TT> will return that value immediately, w/o doing any
checkups.
<A NAME="lbAK">&nbsp;</A>
<H3>id</H3>



<A NAME="ixABG"></A>
<FONT SIZE="-1">ID</FONT> of this connection; unique at any point in time
<P>



<PRE>
  $id = $c-&gt;id();

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixABH"></A>

<DT>ret: $id (integer)<DD>


<A NAME="ixABI"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixABJ"></A>

</DL>
<A NAME="lbAL">&nbsp;</A>
<H3>input_filters</H3>



<A NAME="ixABK"></A>
Get/set the first filter in a linked list of protocol level input
filters:
<P>



<PRE>
  $input_filters      = $c-&gt;input_filters();
  $prev_input_filters = $c-&gt;input_filters($new_input_filters);

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixABL"></A>

<DT>opt arg1: $new_input_filters<DD>


<A NAME="ixABM"></A>

Set a new value
<DT>ret: $input_filters ( Apache2::Filter object )<DD>


<A NAME="ixABN"></A>
The first filter in the connection input filters chain.


<P>


If <TT>$new_input_filters</TT> was passed, returns the previous value.
<DT>since: 2.0.00<DD>
<A NAME="ixABO"></A>
</DL>
<P>

For an example see: Bucket Brigades-based Protocol
Module
<A NAME="lbAM">&nbsp;</A>
<H3>keepalive</H3>



<A NAME="ixABP"></A>
This method answers the question: Should the the connection be kept
alive for another <FONT SIZE="-1">HTTP</FONT> request after the current request is completed?
<P>



<PRE>
  $status = $c-&gt;keepalive();
  $status = $c-&gt;keepalive($new_status);

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixABQ"></A>

<DT>opt arg1: $new_status ( :conn_keepalive constant )<DD>


<A NAME="ixABR"></A>

Normally you should not mess with setting this option when handling
the <FONT SIZE="-1">HTTP</FONT> protocol. If you do (for example when sending your own
headers set with
<TT>&quot;$r-&gt;assbackwards&quot;</TT>)
--- take a look at the <I>ap_set_keepalive()</I> function in
<I>httpd-2.0/modules/http/http_protocol.c</I>.
<DT>ret: $status ( :conn_keepalive constant )<DD>


<A NAME="ixABS"></A>
The method does <B>not</B> return true or false, but one of the states
which can be compared against (<TT>&quot;:conn_keepalive
constants&quot;</TT>).
<DT>since: 2.0.00<DD>
<A NAME="ixABT"></A>
</DL>
<P>

Unless you set this value yourself when implementing non-HTTP
protocols, it's only relevant for <FONT SIZE="-1">HTTP</FONT> requests.
<P>

For example:
<P>



<PRE>
  use Apache2::RequestRec ();
  use Apache2::Connection ();
  
  use Apache2::Const -compile =&gt; qw(:conn_keepalive);
  ...
  my $c = $r-&gt;connection;
  if ($c-&gt;keepalive == Apache2::Const::CONN_KEEPALIVE) {
      # do something
  }
  elsif ($c-&gt;keepalive == Apache2::Const::CONN_CLOSE) {
      # do something else
  }
  elsif ($c-&gt;keepalive == Apache2::Const::CONN_UNKNOWN) {
      # do yet something else
  }
  else {
      # die &quot;unknown state&quot;;
  }

</PRE>


<P>

Notice that new states could be added later by Apache, so your code
should make no assumptions and do things only if the desired state
matches.
<A NAME="lbAN">&nbsp;</A>
<H3>keepalives</H3>



<A NAME="ixABU"></A>
How many requests were already served over the current connection.
<P>



<PRE>
  $served = $c-&gt;keepalives();
  $served = $c-&gt;keepalives($new_served);

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixABV"></A>

<DT>opt arg1: $new_served (integer)<DD>


<A NAME="ixABW"></A>

Set the number of served requests over the current
connection. Normally you won't do that when handling <FONT SIZE="-1">HTTP</FONT>
requests. (But see below a note regarding
<TT>&quot;$r-&gt;assbackwards&quot;</TT>).
<DT>ret: $served (integer)<DD>


<A NAME="ixABX"></A>
How many requests were already served over the current connection.


<P>


In most handlers, but <FONT SIZE="-1">HTTP</FONT> output filter handlers, that value doesn't
count the current request. For the latter it'll count the current
request.
<DT>since: 2.0.00<DD>
<A NAME="ixABY"></A>
</DL>
<P>

This method is only relevant for keepalive
connections. The core connection output filter
<TT>&quot;ap_http_header_filter&quot;</TT> increments this value when the response
headers are sent and it decides that the connection should not be
closed (see <TT>&quot;ap_set_keepalive()&quot;</TT>).
<P>

If you send your own set of <FONT SIZE="-1">HTTP</FONT> headers with
<TT>&quot;$r-&gt;assbackwards&quot;</TT>,
which includes the <TT>&quot;Keep-Alive&quot;</TT> <FONT SIZE="-1">HTTP</FONT> response header, you must make
sure to increment the <TT>&quot;keepalives&quot;</TT> counter.
<A NAME="lbAO">&nbsp;</A>
<H3>local_addr</H3>



<A NAME="ixABZ"></A>
Get this connection's local socket address
<P>



<PRE>
  $local_sa = $c-&gt;local_addr();

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixACA"></A>

<DT>ret: $local_sa ( APR::SockAddr object )<DD>


<A NAME="ixACB"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixACC"></A>

</DL>
<A NAME="lbAP">&nbsp;</A>
<H3>local_host</H3>



<A NAME="ixACD"></A>
used for ap_get_server_name when UseCanonicalName is set to <FONT SIZE="-1">DNS</FONT>
(ignores setting of HostnameLookups)
<P>



<PRE>
  $local_host = $c-&gt;local_host();

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixACE"></A>

<DT>ret: $local_host (string)<DD>


<A NAME="ixACF"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixACG"></A>

</DL>
<P>

<FONT SIZE="-1">META:</FONT> you probably shouldn't use this method, but (
<TT>&quot;get_server_name&quot;</TT>
) if inside request and <TT>$r</TT> is available.
<A NAME="lbAQ">&nbsp;</A>
<H3>local_ip</H3>



<A NAME="ixACH"></A>
server <FONT SIZE="-1">IP</FONT> address
<P>



<PRE>
  $local_ip = $c-&gt;local_ip();

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixACI"></A>

<DT>ret: $local_ip (string)<DD>


<A NAME="ixACJ"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixACK"></A>

</DL>
<A NAME="lbAR">&nbsp;</A>
<H3>notes</H3>



<A NAME="ixACL"></A>
Get/set text notes for the duration of this connection. These notes can
be passed from one module to another (not only mod_perl, but modules
in any other language):
<P>



<PRE>
  $notes      = $c-&gt;notes();
  $prev_notes = $c-&gt;notes($new_notes);

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixACM"></A>

<DT>opt arg1: $new_notes ( APR::Table object )<DD>


<A NAME="ixACN"></A>
<DT>ret: $notes ( APR::Table object )<DD>


<A NAME="ixACO"></A>

the current notes table.


<P>


if the <TT>$new_notes</TT> argument was passed, returns the previous value.
<DT>since: 2.0.00<DD>
<A NAME="ixACP"></A>
</DL>
<P>

Also see
<TT>&quot;$r-&gt;notes&quot;</TT>
<A NAME="lbAS">&nbsp;</A>
<H3>output_filters</H3>



<A NAME="ixACQ"></A>
Get the first filter in a linked list of protocol level output
filters:
<P>



<PRE>
  $output_filters = $c-&gt;output_filters();
  $prev_output_filters = $r-&gt;output_filters($new_output_filters);

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixACR"></A>

<DT>opt arg1: $new_output_filters<DD>


<A NAME="ixACS"></A>

Set a new value
<DT>ret: $output_filters ( Apache2::Filter object )<DD>


<A NAME="ixACT"></A>
The first filter in the connection output filters chain.


<P>


If <TT>$new_output_filters</TT> was passed, returns the previous value.
<DT>since: 2.0.00<DD>
<A NAME="ixACU"></A>
</DL>
<P>

For an example see: Bucket Brigades-based Protocol
Module
<A NAME="lbAT">&nbsp;</A>
<H3>pool</H3>



<A NAME="ixACV"></A>
Pool associated with this connection
<P>



<PRE>
  $p = $c-&gt;pool();

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixACW"></A>

<DT>ret: $p ( APR::Pool object )<DD>


<A NAME="ixACX"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixACY"></A>

</DL>
<A NAME="lbAU">&nbsp;</A>
<H3>remote_addr</H3>



<A NAME="ixACZ"></A>
Get this connection's remote socket address
<P>



<PRE>
  $remote_sa = $c-&gt;remote_addr();

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixADA"></A>

<DT>ret: $remote_sa ( APR::SockAddr object )<DD>


<A NAME="ixADB"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixADC"></A>

</DL>
<A NAME="lbAV">&nbsp;</A>
<H3>remote_ip</H3>



<A NAME="ixADD"></A>
Client's <FONT SIZE="-1">IP</FONT> address
<P>



<PRE>
  $remote_ip      = $c-&gt;remote_ip();
  $prev_remote_ip = $c-&gt;remote_ip($new_remote_ip);

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixADE"></A>

<DT>opt arg1: $new_remote_ip ( string )<DD>


<A NAME="ixADF"></A>

If passed a new value will be set
<DT>ret: $remote_ip ( string )<DD>


<A NAME="ixADG"></A>
current remote ip address


<P>


if the optional argument <TT>$new_remote_ip</TT> was passed the previous
value is returned.
<DT>since: 2.0.00<DD>
<A NAME="ixADH"></A>
</DL>
<A NAME="lbAW">&nbsp;</A>
<H3>remote_host</H3>



<A NAME="ixADI"></A>
Client's <FONT SIZE="-1">DNS</FONT> name:
<P>



<PRE>
  $remote_host = $c-&gt;remote_host();

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixADJ"></A>

<DT>ret: $remote_host ( string/undef )<DD>


<A NAME="ixADK"></A>

If <TT>&quot;$c-&gt;get_remote_host&quot;</TT> was run it
returns the cached value, which is a client <FONT SIZE="-1">DNS</FONT> name or <TT>&quot;&quot;</TT> if it
wasn't found. If the check wasn't run --- <TT>&quot;undef&quot;</TT> is returned.
<DT>since: 2.0.00<DD>
<A NAME="ixADL"></A>
</DL>
<P>

It's best to to call <TT>&quot;$c-&gt;get_remote_host&quot;</TT>
instead of directly accessing this variable.
<A NAME="lbAX">&nbsp;</A>
<H2>Unsupported API</H2>

<A NAME="ixADM"></A>
<TT>&quot;Apache2::Connection&quot;</TT> also provides auto-generated Perl interface for
a few other methods which aren't tested at the moment and therefore
their <FONT SIZE="-1">API</FONT> is a subject to change. These methods will be finalized
later as a need arises. If you want to rely on any of the following
methods please contact the the mod_perl development mailing
list so we can help each other take the steps necessary
to shift the method to an officially supported <FONT SIZE="-1">API</FONT>.
<A NAME="lbAY">&nbsp;</A>
<H3>conn_config</H3>



<A NAME="ixADN"></A>
Config vector containing pointers to connections per-server config
structures
<P>



<PRE>
  $ret = $c-&gt;conn_config();

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixADO"></A>

<DT>ret: $ret ( Apache2::ConfVector object )<DD>


<A NAME="ixADP"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixADQ"></A>

</DL>
<A NAME="lbAZ">&nbsp;</A>
<H3>sbh</H3>



<A NAME="ixADR"></A>
<FONT SIZE="-1">META:</FONT> Autogenerated - needs to be reviewed/completed
<P>

handle to scoreboard information for this connection
<P>



<PRE>
  $sbh = $c-&gt;sbh();

</PRE>


<DL COMPACT>
<DT>obj: $c ( Apache2::Connection object )<DD>


<A NAME="ixADS"></A>

<DT>ret: $sbh (<FONT SIZE="-1">XXX</FONT>)<DD>


<A NAME="ixADT"></A>
<DT>since: 2.0.00<DD>
<A NAME="ixADU"></A>

</DL>
<P>

<FONT SIZE="-1">META:</FONT> Not sure how this can be used from mod_perl at the
moment. Unless <TT>&quot;Apache2::Scoreboard&quot;</TT> is extended to provide a hook to
read from this variable.
<A NAME="lbBA">&nbsp;</A>
<H2>See Also</H2>

<A NAME="ixADV"></A>
mod_perl 2.0 documentation.
<A NAME="lbBB">&nbsp;</A>
<H2>Copyright</H2>

<A NAME="ixADW"></A>
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
<A NAME="lbBC">&nbsp;</A>
<H2>Authors</H2>

<A NAME="ixADX"></A>
The mod_perl development team and numerous
contributors.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">Synopsis</A><DD>
<DT><A HREF="#lbAD">Description</A><DD>
<DT><A HREF="#lbAE">API</A><DD>
<DL>
<DT><A HREF="#lbAF">aborted</A><DD>
<DT><A HREF="#lbAG">base_server</A><DD>
<DT><A HREF="#lbAH">bucket_alloc</A><DD>
<DT><A HREF="#lbAI">client_socket</A><DD>
<DT><A HREF="#lbAJ">get_remote_host</A><DD>
<DT><A HREF="#lbAK">id</A><DD>
<DT><A HREF="#lbAL">input_filters</A><DD>
<DT><A HREF="#lbAM">keepalive</A><DD>
<DT><A HREF="#lbAN">keepalives</A><DD>
<DT><A HREF="#lbAO">local_addr</A><DD>
<DT><A HREF="#lbAP">local_host</A><DD>
<DT><A HREF="#lbAQ">local_ip</A><DD>
<DT><A HREF="#lbAR">notes</A><DD>
<DT><A HREF="#lbAS">output_filters</A><DD>
<DT><A HREF="#lbAT">pool</A><DD>
<DT><A HREF="#lbAU">remote_addr</A><DD>
<DT><A HREF="#lbAV">remote_ip</A><DD>
<DT><A HREF="#lbAW">remote_host</A><DD>
</DL>
<DT><A HREF="#lbAX">Unsupported API</A><DD>
<DL>
<DT><A HREF="#lbAY">conn_config</A><DD>
<DT><A HREF="#lbAZ">sbh</A><DD>
</DL>
<DT><A HREF="#lbBA">See Also</A><DD>
<DT><A HREF="#lbBB">Copyright</A><DD>
<DT><A HREF="#lbBC">Authors</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/man/index.html">man2html</A>,
using the manual pages.<BR>
Time: 05:33:11 GMT, December 24, 2015
</div></body>
</HTML>
