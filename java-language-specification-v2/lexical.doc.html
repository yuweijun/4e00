<html>
<head>
<title> Lexical Structure</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="grammars.doc.html">Prev</a> | <a href="typesValues.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<hr><br>
 
<a name="48198"></a>
<p><strong>
CHAPTER
 3 </strong></p>
<a name="44591"></a>
<h1>Lexical Structure</h1>
<hr><p>
<a name="230314"></a>
This chapter specifies the lexical structure of the Java programming language.<p>
<a name="230426"></a>
Programs are written in Unicode <a href="lexical.doc.html#95413">(&#167;3.1)</a>, but lexical translations are provided <a href="lexical.doc.html#95504">(&#167;3.2)</a> so that Unicode escapes <a href="lexical.doc.html#100850">(&#167;3.3)</a> can be used to include any Unicode character using only ASCII characters. Line terminators are defined <a href="lexical.doc.html#231571">(&#167;3.4)</a> to support the different conventions of existing host systems while maintaining consistent line numbers.<p>
<a name="229936"></a>
The Unicode characters resulting from the lexical translations are reduced to a sequence of input elements <a href="lexical.doc.html#25687">(&#167;3.5)</a>, which are white space <a href="lexical.doc.html#95710">(&#167;3.6)</a>, comments <a href="lexical.doc.html#48125">(&#167;3.7)</a>, and tokens. The tokens are the identifiers <a href="lexical.doc.html#40625">(&#167;3.8)</a>, keywords <a href="lexical.doc.html#229308">(&#167;3.9)</a>, literals <a href="lexical.doc.html#48272">(&#167;3.10)</a>, separators <a href="lexical.doc.html#230752">(&#167;3.11)</a>, and operators <a href="lexical.doc.html#230663">(&#167;3.12)</a> of the syntactic grammar.<p>
<a name="95413"></a>
<h2>3.1    Unicode</h2>
<a name="230444"></a>
Programs are written using the<em> </em>Unicode character set. Information about this encoding may be found at:<p>
<blockquote><pre>http://www.unicode.org
</pre></blockquote><a name="230450"></a>
Versions of the Java programming language prior to 1.1 used Unicode version 1.1.5 (see <em>The Unicode Standard: Worldwide Character Encoding </em><a href="intro.doc.html#247980">(&#167;1.4)</a> and updates). Later versions prior to JDK version 1.1.7 used Unicode version 2.0. Since JDK version 1.1.7, Unicode 2.1 has been in use. The Java platform will track the Unicode specification as it evolves. The precise version of Unicode used by a given release is specified in the documentation of the class <code>Character</code>.<p>
<a name="99446"></a>
Except for comments <a href="lexical.doc.html#48125">(&#167;3.7)</a>, identifiers, and the contents of character and string literals (<a href="lexical.doc.html#100960">&#167;3.10.4</a>, <a href="lexical.doc.html#101083">&#167;3.10.5</a>), all input elements <a href="lexical.doc.html#25687">(&#167;3.5)</a> in a program are formed only from ASCII characters (or Unicode escapes <a href="lexical.doc.html#100850">(&#167;3.3)</a> which result in ASCII characters). ASCII (ANSI X3.4) is the American Standard Code for Information Interchange. The first 128 characters of the Unicode character encoding are the ASCII characters.<p>
<a name="95504"></a>
<h2>3.2    Lexical Translations</h2>
<a name="48080"></a>
A raw Unicode character stream is translated into a sequence of tokens, using the following three lexical translation steps, which are applied in turn:<p>
<ol>
<a name="48081"></a>
<li>A translation of Unicode escapes <a href="lexical.doc.html#100850">(&#167;3.3)</a> in the raw stream of Unicode characters to the corresponding Unicode character. A Unicode escape of the form <code>\u</code><i>xxxx</i>, where <i>xxxx</i> is a hexadecimal value, represents the Unicode character whose encoding is <i>xxxx</i>. This translation step allows any program to be expressed using only ASCII characters.
<a name="48082"></a>
<li>A translation of the Unicode stream resulting from step 1 into a stream of input characters and line terminators <a href="lexical.doc.html#231571">(&#167;3.4)</a>.
<a name="95812"></a>
<li>A translation of the stream of input characters and line terminators resulting from step 2 into a sequence of input elements <a href="lexical.doc.html#25687">(&#167;3.5)</a> which, after white space <a href="lexical.doc.html#95710">(&#167;3.6)</a> and comments <a href="lexical.doc.html#48125">(&#167;3.7)</a> are discarded, comprise the tokens <a href="lexical.doc.html#25687">(&#167;3.5)</a> that are the terminal symbols of the syntactic grammar <a href="grammars.doc.html#151185">(&#167;2.3)</a>.
</ol>
<a name="100835"></a>
The longest possible translation is used at each step, even if the result does not ultimately make a correct program while another lexical translation would. Thus the input characters <code>a--b</code> are tokenized <a href="lexical.doc.html#25687">(&#167;3.5)</a> as <code>a</code>, <code>--</code>, <code>b</code>, which is not part of any grammatically correct program, even though the tokenization <code>a</code>, <code>-</code>, <code>-</code>,<code>&#32;b</code> could be part of a grammatically correct program.<p>
<a name="100850"></a>
<h2>3.3    Unicode Escapes</h2>
<a name="48089"></a>
Implementations first recognize <em>Unicode escapes</em> in their input, translating the ASCII characters <code>\u</code> followed by four hexadecimal digits to the Unicode character with the indicated hexadecimal value, and passing all other characters unchanged. This translation step results in a sequence of Unicode input characters:<p>
<blockquote><pre><i>
UnicodeInputCharacter:
	UnicodeEscape
	RawInputCharacter

UnicodeEscape:
<code>	\ </code>UnicodeMarker<code> </code>HexDigit<code> </code>HexDigit<code> </code>HexDigit<code> </code>HexDigit

UnicodeMarker:
	</i>u<i>
	UnicodeMarker</i> u<i>

RawInputCharacter:
</i>	any Unicode character

<i>HexDigit: one of</i>
<code>	0&#32;1&#32;2&#32;3&#32;4&#32;5&#32;6&#32;7&#32;8&#32;9&#32;a&#32;b&#32;c&#32;d&#32;e&#32;f&#32;A&#32;B&#32;C&#32;D&#32;E&#32;F
</code></pre></blockquote><a name="229834"></a>
The <code>\</code>, <code>u</code>, and hexadecimal digits here are all ASCII characters.<p>
<a name="231557"></a>
In addition to the processing implied by the grammar, for each raw input character that is a backslash <code>\</code>, input processing must consider how many other <code>\</code> characters contiguously precede it, separating it from a non-<code>\</code> character or the start of the input stream. If this number is even, then the <code>\</code> is eligible to begin a Unicode escape; if the number is odd, then the <code>\</code> is not eligible to begin a Unicode escape. For example, the raw input <code>"\\u2297=\u2297"</code> results in the eleven characters <code>"</code> &#32;<code>\</code> <code>\</code> <code>u</code> <code>2</code> <code>2</code> <code>9</code> <code>7</code> <code>=</code> <img src="chars/circmult.gif"> <code>"</code> (<code>\u2297</code> is the Unicode encoding of the character "<img src="chars/circmult.gif">")<code>.</code><p>
<a name="229835"></a>
If an eligible <code>\</code> is not followed by <code>u</code>, then it is treated as a <em>RawInputCharacter</em> and remains part of the escaped Unicode stream. If an eligible <code>\</code> is followed by <code>u</code>, or more than one <code>u</code>, and the last <code>u</code> is not followed by four hexadecimal digits, then a compile-time error occurs.<p>
<a name="48098"></a>
The character produced by a Unicode escape does not participate in further Unicode escapes. For example, the raw input <code>\u005cu005a</code> results in the six characters <code>\</code> <code>u</code> <code>0</code> <code>0</code> <code>5</code> <code>a</code>, because <code>005c</code> is the Unicode value for <code>\</code>.<code> </code>It does not result in the character <code>Z</code>, which is Unicode character <code>005a</code>, because the <code>\</code> that resulted from the <code>\u005c</code> is not interpreted as the start of a further Unicode escape.<p>
<a name="228824"></a>
The Java programming language specifies a standard way of transforming a program written in Unicode into ASCII that changes a program into a form that can be processed by ASCII-based tools. The transformation involves converting any Unicode escapes in the source text of the program to ASCII by adding an extra <code>u</code>-for example, <code>\u</code><i>xxxx</i> becomes <code>\uu</code><i>xxxx</i>-while simultaneously converting non-ASCII characters in the source text to a <code>\u</code><i>xxxx</i> escape containing a single <code>u</code>. <p>
<a name="248014"></a>
This transformed version is equally acceptable to a compiler for the Java programming language ("Java compiler") and represents the exact same program. The exact Unicode source can later be restored from this ASCII form by converting each escape sequence where multiple <code>u</code>'s are present to a sequence of Unicode characters with one fewer <code>u</code>, while simultaneously converting each escape sequence with a single <code>u</code> to the corresponding single Unicode character.<p>
<a name="231569"></a>
Implementations should use the <code>\u</code><i>xxxx</i> notation as an output format to display Unicode characters when a suitable font is not available. <p>
<a name="231571"></a>
<h2>3.4    Line Terminators</h2>
<a name="22634"></a>
Implementations next divide the sequence of Unicode input characters into lines by recognizing <em>line terminators</em>. This definition of lines determines the line numbers produced by a Java compiler or other system component. It also specifies the termination of the <code>//</code> form of a comment <a href="lexical.doc.html#48125">(&#167;3.7)</a>.<p>
<blockquote><pre>
<i>LineTerminator:</i>
<code>	</code>the ASCII <code>LF</code> character, also known as "newline"
	the ASCII <code>CR</code> character, also known as "return"
<code>	</code>the ASCII <code>CR</code> character followed by the ASCII <code>LF</code> character

<i>InputCharacter:
	UnicodeInputCharacter</i> but not <code>CR</code> or <code>LF
</code></pre></blockquote><a name="48107"></a>
Lines are terminated by the ASCII characters <code>CR</code>, or <code>LF</code>, or <code>CR LF</code>. The two characters <code>CR</code> immediately followed by <code>LF</code> are counted as one line terminator, not two. <p>
<a name="248015"></a>
The result is a sequence of line terminators and input characters, which are the terminal symbols for the third step in the tokenization process.<p>
<a name="25687"></a>
<h2>3.5    Input Elements and Tokens</h2>
<a name="25688"></a>
The input characters and line terminators that result from escape processing <a href="lexical.doc.html#100850">(&#167;3.3)</a> and then input line recognition <a href="lexical.doc.html#231571">(&#167;3.4)</a> are reduced to a sequence of <em>input elements</em>. Those input elements that are not white space <a href="lexical.doc.html#95710">(&#167;3.6)</a> or comments <a href="lexical.doc.html#48125">(&#167;3.7)</a> are <em>tokens</em>. The tokens are the terminal symbols of the syntactic grammar <a href="grammars.doc.html#151185">(&#167;2.3)</a>.<p>
<a name="95675"></a>
This process is specified by the following productions:<p>
<blockquote><pre>
<i>Input:
	InputElements<sub><i>opt</i></sub><code> </code>Sub<sub><i>opt
</i></sub>
InputElements:
	InputElement
	InputElements<code> </code>InputElement

InputElement:
	WhiteSpace
	Comment
	Token

Token:
	Identifier
	Keyword
	Literal
	Separator
	Operator

Sub:</i>
	the ASCII <code>SUB</code> character, also known as "control-Z"
</pre></blockquote><a name="95707"></a>
White space <a href="lexical.doc.html#95710">(&#167;3.6)</a> and comments <a href="lexical.doc.html#48125">(&#167;3.7)</a> can serve to separate tokens that, if adjacent, might be tokenized in another manner. For example, the ASCII characters <code>-</code> and <code>=</code> in the input can form the operator token <code>-=</code> <a href="lexical.doc.html#230663">(&#167;3.12)</a> only if there is no intervening white space or comment.<p>
<a name="25733"></a>
As a special concession for compatibility with certain operating systems, the ASCII SUB character (<code>\u001a</code>, or control-Z) is ignored if it is the last character in the escaped input stream.<p>
<a name="230834"></a>
Consider two tokens <i>x</i> and <i>y</i> in the resulting input stream. If <i>x</i> precedes <i>y</i>, then we say that <i>x</i> is <em>to the left of</em> <i>y</i> and that <i>y</i> is <em>to the right of</em> <i>x</i>.<p>
<a name="244094"></a>
<p>For example, in this simple piece of code:
<blockquote><pre>class Empty {
}
</pre></blockquote><a name="230846"></a>
we say that the <code>}</code> token is to the right of the <code>{</code> token, even though it appears, in this two-dimensional representation on paper, downward and to the left of the <code>{</code> token. This convention about the use of the words left and right allows us to speak, for example, of the right-hand operand of a binary operator or of the left-hand side of an assignment.<p>
<a name="95710"></a>
<h2>3.6    White Space</h2>
<a name="48121"></a>
<em>White space</em> is defined as the ASCII space, horizontal tab, and form feed characters, as well as line terminators <a href="lexical.doc.html#231571">(&#167;3.4)</a>.<p>
<blockquote><pre>
<i>WhiteSpace:</i>
	the ASCII <code>SP</code> character, also known as "space"
<code>	</code>the ASCII <code>HT</code> character, also known as "horizontal tab"
<code>	</code>the ASCII <code>FF</code> character, also known as "form feed"
<i>	LineTerminator</i>
</pre></blockquote><a name="48125"></a>
<h2>3.7    Comments</h2>
<a name="9724"></a>
There are two kinds of <em>comments</em>:<p>
<blockquote><pre>
<code>/* </code><i>text</i><code> */		</code>A traditional comment: all the text from the ASCII 
                        characters <code>/*</code> to the ASCII characters <code>*/</code> is ignored 
                        (as in C and C++).
<code>// </code><i>text</i>			A end-of-line comment: all the text from the ASCII 
                        characters <code>//</code> to the end of the line is ignored (as in 
               		C++).
</pre></blockquote><a name="228969"></a>
<code></code>These comments are formally specified by the following productions:<p>
<ul><pre>
<i>Comment:
	TraditionalComment
	EndOfLineComment

TraditionalComment:
	<code>/ * </code>NotStar<code> </code>CommentTail

EndOfLineComment:
	<code>/ / </code>CharactersInLine<sub><i>opt</i></sub><code> </code>LineTerminator

CommentTail:
	<code>* </code>CommentTailStar
	NotStar<code> </code>CommentTail

CommentTailStar:
	<code>/
	* </code>CommentTailStar
	NotStarNotSlash<code> </code>CommentTail

NotStar:
	InputCharacter</i> but not <code>*
</code>	<i>LineTerminator

NotStarNotSlash:
	InputCharacter</i> but not <code>*</code> or <code>/
</code><i>	LineTerminator

CharactersInLine:
	InputCharacter
	CharactersInLine<code> </code>InputCharacter
</i></pre></ul><a name="230630"></a>
These productions imply all of the following properties:<p>
<ul><a name="48132"></a>
<li>Comments do not nest.
<a name="48134"></a>
<li><code>/*</code> and <code>*/</code> have no special meaning in comments that begin with <code>//</code>.
<a name="48135"></a>
<li><code>//</code> has no special meaning in comments that begin with <code>/*</code> or <code>/**</code>.
</ul><a name="48136"></a>
As a result, the text:<p>
<blockquote><pre>/* this comment /* // /** ends here: */
</pre></blockquote><a name="230885"></a>
is a single complete comment.<p>
<a name="230886"></a>
<p>
The lexical grammar implies that comments do not occur within character literals <a href="lexical.doc.html#100960">(&#167;3.10.4)</a> or string literals <a href="lexical.doc.html#101083">(&#167;3.10.5)</a>.
<a name="40625"></a>
<h2>3.8    Identifiers</h2>
<a name="229286"></a>
An <em>identifier</em> is an unlimited-length sequence of <em>Java letters</em> and <em>Java digits</em>, the first of which must be a Java letter. An identifier cannot have the same spelling (Unicode character sequence) as a keyword <a href="lexical.doc.html#229308">(&#167;3.9)</a>, boolean literal <a href="lexical.doc.html#49652">(&#167;3.10.3)</a>, or the null literal <a href="lexical.doc.html#230717">(&#167;3.10.7)</a>.<p>
<ul><pre>
<i>Identifier:
	IdentifierChars</i> but not a<i> Keyword</i> or <i>BooleanLiteral</i> or <i>NullLiteral

IdentifierChars:
	JavaLetter
	IdentifierChars<code> </code>JavaLetterOrDigit

JavaLetter:
	</i>any Unicode character that is a Java letter (see below)

<i>JavaLetterOrDigit:</i>
	any Unicode character that is a Java letter-or-digit (see below)
</pre></ul><a name="23674"></a>
Letters and digits may be drawn from the entire Unicode character set, which supports most writing scripts in use in the world today, including the large sets for Chinese, Japanese, and Korean. This allows programmers to use identifiers in their programs that are written in their native languages.<p>
<a name="19216"></a>
A "Java letter" is a character for which the method <code>Character.isJavaIdentifierStart</code> returns <code>true</code>. A "Java letter-or-digit" is a character for which the method <code>Character.isJavaIdentifierPart</code> returns <code>true</code>. <p>
<a name="248021"></a>
The Java letters include uppercase and lowercase ASCII Latin letters <code>A</code>-<code>Z</code> (<code>\u0041</code>-<code>\u005a</code>), and <code>a</code>-<code>z</code> <code>(\u0061</code>-<code>\u007a</code>), and, for historical reasons, the ASCII underscore (<code>_</code>, or <code>\u005f</code>) and dollar sign (<code>$</code>, or <code>\u0024</code>). The <code>$</code> character should be used only in mechanically generated source code or, rarely, to access preexisting names on legacy systems.<p>
<a name="230344"></a>
The "Java digits" include the ASCII digits <code>0-9</code> (<code>\u0030</code>-<code>\u0039)</code>.<p>
<a name="230345"></a>
Two identifiers are the same only if they are identical, that is, have the same Unicode character for each letter or digit<em>.</em><p>
<a name="21262"></a>
Identifiers that have the same external appearance may yet be different. For example, the identifiers consisting of the single letters LATIN CAPITAL LETTER A (<code>A</code>, <code>\u0041</code>), LATIN SMALL LETTER A (<code>a</code>, <code>\u0061</code>), GREEK CAPITAL LETTER ALPHA (<code>A</code>, <code>\u0391</code>), and CYRILLIC SMALL LETTER A (<code>a</code>, <code>\u0430</code>) are all different.<p>
<a name="48270"></a>
Unicode composite characters are different from the decomposed characters. For example, a LATIN CAPITAL LETTER A ACUTE (<code>&Aacute;,</code> <code>\u00c1)</code> could be considered to be the same as a LATIN CAPITAL LETTER A (<code>A</code>, <code>\u0041)</code> immediately followed by a NON-SPACING ACUTE (&#180;, <code>\u0301</code>) when sorting, but these are different in identifiers. See <em>The Unicode Standard</em>, Volume 1, pages 412ff for details about decomposition, and see pages 626-627 of that work for details about sorting.<p>
<a name="31160"></a>
Examples of identifiers are:<p>
<blockquote><pre>
String 	    i3	  <img src="chars/alpha.gif"><img src="chars/rho.gif"><img src="chars/epsilon.gif"><img src="chars/tau.gif"><img src="chars/eta.gif">  	MAX_VALUE	isLetterOrDigit
</pre></blockquote><a name="229308"></a>
<h2>3.9    Keywords</h2>
<a name="229309"></a>
The following character sequences, formed from ASCII letters, are reserved for use as <em>keywords</em> and cannot be used as identifiers <a href="lexical.doc.html#40625">(&#167;3.8)</a>:<p>
<ul><pre>
<i>Keyword: one of</i>
	abstract    default    if            private      this
	boolean     do         implements    protected    throw
	break       double     import        public       throws
	byte        else       instanceof    return       transient
	case        extends    int           short        try
	catch       final      interface     static       void
	char        finally    long          strictfp     volatile
	class       float      native        super        while
	const       for        new           switch
	continue    goto       package       synchronized
</pre></ul>
<p>The keywords <code>const</code> and <code>goto</code> are reserved, even though they are not currently used. This may allow a Java compiler to produce better error messages if these C++ keywords incorrectly appear in programs.
<a name="229317"></a>
<p>
While <code>true</code> and <code>false</code> might appear to be keywords, they are technically Boolean literals <a href="lexical.doc.html#49652">(&#167;3.10.3)</a>. Similarly, while <code>null</code> might appear to be a keyword, it is technically the null literal <a href="lexical.doc.html#230717">(&#167;3.10.7)</a>.
<h2>3.10    Literals</h2>
<a name="228794"></a>
A <em>literal</em> is the source code representation of a value of a primitive type <a href="typesValues.doc.html#85587">(&#167;4.2)</a>, the <code>String</code> type (<a href="typesValues.doc.html#26992">&#167;4.3.3</a>), or the null type <a href="typesValues.doc.html#11128">(&#167;4.1)</a>:<p>
<ul><pre>
<i>Literal:
	IntegerLiteral
	FloatingPointLiteral
	BooleanLiteral
	CharacterLiteral
	StringLiteral
	NullLiteral
</i></pre></ul><a name="48282"></a>
<h3>3.10.1    Integer Literals</h3>
<a name="46750"></a>
See <a href="typesValues.doc.html#9151">&#167;4.2.1</a> for a general discussion of the integer types and values.<p>
<a name="7117"></a>
An <em>integer literal</em> may be expressed in decimal (base 10), hexadecimal (base &#32;16), or octal (base 8):<p>
<ul><pre>
<i>IntegerLiteral:
	DecimalIntegerLiteral
	HexIntegerLiteral	
	OctalIntegerLiteral

DecimalIntegerLiteral:
	DecimalNumeral<code> </code>IntegerTypeSuffix<sub><i>opt
</i></sub>
HexIntegerLiteral:
	HexNumeral<code> </code>IntegerTypeSuffix<sub><i>opt
</i></sub>
OctalIntegerLiteral:	
	OctalNumeral<code> </code>IntegerTypeSuffix<sub><i>opt
</i></sub>
IntegerTypeSuffix: one of</i>
	<code>l&#32;L
</code></pre></ul><a name="19247"></a>
An integer literal is of type <code>long</code> if it is suffixed with an ASCII letter <code>L</code> or <code>l</code> (ell); otherwise it is of type <code>int</code> <a href="typesValues.doc.html#9151">(&#167;4.2.1)</a>. The suffix <code>L</code> is preferred, because the letter <code>l</code> (ell) is often hard to distinguish from the digit <code>1</code> (one).<p>
<a name="48345"></a>
A decimal numeral is either the single ASCII character <code>0</code>, representing the integer zero, or consists of an ASCII digit from <code>1</code> to <code>9</code>, optionally followed by one or more ASCII digits from <code>0</code> to <code>9</code>, representing a positive integer:<p>
<ul><pre>
<i>DecimalNumeral:
	</i>0
<i>	NonZeroDigit<code> </code>Digits<sub><i>opt
</i></sub>
Digits:
	Digit
	Digits<code> </code>Digit

Digit:
</i>	0
<i>	NonZeroDigit

NonZeroDigit: one of</i>
<code>	1&#32;2&#32;3&#32;4&#32;5&#32;6&#32;7&#32;8&#32;9
</code></pre></ul><a name="44312"></a>
A hexadecimal numeral consists of the leading ASCII characters <code>0x</code> or <code>0X</code> followed by one or more ASCII hexadecimal digits and can represent a positive, zero, or negative integer. Hexadecimal digits with values 10 through 15 are represented by the ASCII letters <code>a</code> through <code>f</code> or <code>A</code> through <code>F</code>, respectively; each letter used as a hexadecimal digit may be uppercase or lowercase.<p>
<ul><pre>
<i>HexNumeral:
</i>	0 x <i>HexDigits
	</i>0 X <i>HexDigits

HexDigits:
<code>	</code>HexDigit
	HexDigit HexDigits</i>
</pre></ul><a name="229443"></a>
The following production from <a href="lexical.doc.html#100850">&#167;3.3</a> is repeated here for clarity:<p>
<ul><pre>
<i>HexDigit: one of</i>
<code>	0&#32;1&#32;2&#32;3&#32;4&#32;5&#32;6&#32;7&#32;8&#32;9&#32;a&#32;b&#32;c&#32;d&#32;e&#32;f&#32;A&#32;B&#32;C&#32;D&#32;E&#32;F
</code></pre></ul><a name="48298"></a>
An octal numeral consists of an ASCII digit <code>0</code> followed by one or more of the ASCII digits <code>0</code> through <code>7</code> and can represent a positive, zero, or negative integer.<p>
<ul><pre>
<i>OctalNumeral:
</i>	0 <i>OctalDigits

OctalDigits:
<code>	</code>OctalDigit
	OctalDigit<code> </code>OctalDigits

OctalDigit: one of</i>
<code>	0&#32;1&#32;2&#32;3&#32;4&#32;5&#32;6&#32;7
</code></pre></ul><a name="231738"></a>
Note that octal numerals always consist of two or more digits; <code>0</code> is always considered to be a decimal numeral-not that it matters much in practice, for the numerals <code>0</code>, <code>00</code>, and <code>0x0</code> all represent exactly the same integer value.<p>
<a name="231836"></a>
The largest decimal literal of type <code>int</code> is <code>2147483648</code> (2<font size="-1"><sup>31</sup></font>). All decimal literals from <code>0</code> to <code>2147483647</code> may appear anywhere an <code>int</code> literal may appear, but the literal <code>2147483648</code> may appear only as the operand of the unary negation operator <code>-</code>.<p>
<a name="229493"></a>
The largest positive hexadecimal and octal literals of type <code>int</code> are <code>0x7fffffff</code> and <code>017777777777</code>, respectively, which equal <code>2147483647</code> (2<font size="-1"><sup>31</sup></font>-1). The most negative hexadecimal and octal literals of type <code>int</code> are <code>0x80000000</code> and <code>020000000000</code>, respectively, each of which represents the decimal value <code>-2147483648</code> (-2<font size="-1"><sup>31</sup></font>). The hexadecimal and octal literals <code>0xffffffff</code> and <code>037777777777</code>, respectively, represent the decimal value <code>-1</code>.<p>
<a name="48314"></a>
A compile-time error occurs if a decimal literal of type <code>int</code> is larger than <code>2147483648</code> (2<font size="-1"><sup>31</sup></font>), or if the literal <code>2147483648</code> appears anywhere other than as the operand of the unary <code>-</code> operator, or if a hexadecimal or octal <code>int</code> literal does not fit in 32 bits.<p>
<a name="247267"></a>
Examples of <code>int</code> literals:
<blockquote><pre>
0	2	0372	0xDadaCafe	1996	0x00FF00FF
</pre></blockquote><a name="21371"></a>
The largest decimal literal of type <code>long</code> is <code>9223372036854775808L</code> (2<font size="-1"<sup>63</sup></font>). All decimal literals from <code>0L</code> to <code>9223372036854775807L</code> may appear anywhere a <code>long</code> literal may appear, but the literal <code>9223372036854775808L</code> may appear only as the operand of the unary negation operator <code>-</code>.<p>
<a name="21372"></a>
The largest positive hexadecimal and octal literals of type <code>long</code> are <code>0x7fffffffffffffffL</code> and <code>0777777777777777777777L</code>, respectively, which equal <code>9223372036854775807L</code> (2<font size="-1"><sup>63</sup></font>-1). The literals <code>0x8000000000000000L</code> and <code>01000000000000000000000L</code> are the most negative <code>long</code> hexadecimal and octal literals, respectively. Each has the decimal value<code> -9223372036854775808L</code> (-2<font size="-1"><sup>63</sup></font>). The hexadecimal and octal literals <code>0xffffffffffffffffL</code> and <code>01777777777777777777777L</code>, respectively, represent the decimal value <code>-1L</code>.<p>
<a name="76695"></a>
A compile-time error occurs if a decimal literal of type <code>long</code> is larger than <code>9223372036854775808L</code> (2<font size="-1"><sup>63</sup></font>), or if the literal <code>9223372036854775808L</code> appears anywhere other than as the operand of the unary <code>-</code> operator, or if a hexadecimal or octal <code>long</code> literal does not fit in 64 bits.<p>
<a name="46763"></a>
<p>Examples of <code>long</code> literals:
<blockquote><pre>
0l	0777L	0x100000000L	2147483648L	  &#32;0xC0B0L
</pre></blockquote><a name="230798"></a>
<h3>3.10.2    Floating-Point Literals</h3>
<a name="232095"></a>
See <a href="typesValues.doc.html#9208">&#167;4.2.3</a> for a general discussion of the floating-point types and values.<p>
<a name="232096"></a>
A <em>floating-point literal</em> has the following parts: a whole-number part, a decimal point (represented by an ASCII period character), a fractional part, an exponent, and a type suffix. The exponent, if present, is indicated by the ASCII letter <code>e</code> or <code>E</code> followed by an optionally signed integer.<p>
<a name="48344"></a>
At least one digit, in either the whole number or the fraction part, and either a decimal point, an exponent, or a float type suffix are required. All other parts are optional.<p>
<a name="76707"></a>
A floating-point literal is of type <code>float</code> if it is suffixed with an ASCII letter <code>F</code> or <code>f</code>; otherwise its type is <code>double</code> and it can optionally be suffixed with an ASCII letter <code>D</code> or <code>d</code>.<p>
<ul><pre><i>
FloatingPointLiteral:
	Digits<code> . </code>Digits<sub><i>opt</i></sub><code> </code>ExponentPart<sub><i>opt</i></sub><code> </code>FloatTypeSuffix<sub><i>opt
</i></sub>	<code>. </code>Digits<code> </code>ExponentPart<sub><i>opt</i></sub><code> </code>FloatTypeSuffix<sub><i>opt
</i></sub>	Digits<code> </code>ExponentPart<code> </code>FloatTypeSuffix<sub><i>opt
	</i></sub>Digits<code> </code>ExponentPart<sub><i>opt</i></sub><code> </code>FloatTypeSuffix

ExponentPart:
	ExponentIndicator<code> </code>SignedInteger

ExponentIndicator: one of</i>
	e E<i>

SignedInteger:
	Sign<sub><i>opt</i></sub><code> </code>Digits

Sign: one of</i>
	+ -<i>

FloatTypeSuffix: one of</i>
	<code>f F d D
</code></pre></ul><a name="230642"></a>
The elements of the types <code>float</code> and <code>double</code> are those values that can be represented using the IEEE 754 32-bit single-precision and 64-bit double-precision binary floating-point formats, respectively.<p>
<a name="230643"></a>
The details of proper input conversion from a Unicode string representation of a floating-point number to the internal IEEE 754 binary floating-point representation are described for the methods <code>valueOf</code> of class <code>Float</code> and class <code>Double</code> of the package <code>java.lang</code>.<p>
<a name="76740"></a>
The largest positive finite <code>float</code> literal is <code>3.40282347e+38f</code>. The smallest positive finite nonzero literal of type <code>float</code> is <code>1.40239846e-45f</code>. The largest positive finite <code>double</code> literal is <code>1.79769313486231570e+308</code>. The smallest positive finite nonzero literal of type <code>double</code> is <code>4.94065645841246544e-324</code>.<p>
<a name="50569"></a>
A compile-time error occurs if a nonzero floating-point literal is too large, so that on rounded conversion to its internal representation it becomes an IEEE 754 infinity. A program can represent infinities without producing a compile-time error by using constant expressions such as <code>1f/0f</code> or <code>-1d/0d</code> or by using the predefined constants <code>POSITIVE_INFINITY</code> and <code>NEGATIVE_INFINITY</code> of the classes <code>Float</code> and <code>Double</code>.<p>
<a name="229608"></a>
A compile-time error occurs if a nonzero floating-point literal is too small, so that, on rounded conversion to its internal representation, it becomes a zero. A compile-time error does not occur if a nonzero floating-point literal has a small value that, on rounded conversion to its internal representation, becomes a nonzero denormalized number.<p>
<a name="26899"></a>
Predefined constants representing Not-a-Number values are defined in the classes <code>Float</code> and <code>Double</code> as <code>Float.NaN</code> and <code>Double.NaN</code>.<p>
<a name="26906"></a>
Examples of <code>float</code> literals:
<blockquote><pre>	
1e1f    	2.f		.3f		0f		3.14f		6.022137e+23f
</pre></blockquote><a name="48365"></a>
<p>Examples of <code>double</code> literals:
<blockquote><pre>	
1e1		2.		.3		0.0		3.14		1e-9d		1e137
</pre></blockquote><a name="247977"></a>
There is no provision for expressing floating-point literals in other than decimal radix. However, method <code>intBitsToFloat</code> of class <code>Float</code> and method <code>longBitsToDouble</code> of class <code>Double</code> provide a way to express floating-point values in terms of hexadecimal or octal integer literals. <p>
<a name="247981"></a>
For example, the value of:
<blockquote><pre>Double.longBitsToDouble(0x400921FB54442D18L)
</pre></blockquote><a name="231039"></a>
is equal to the value of <code>Math.PI</code>.<p>
<a name="49652"></a>
<h3>3.10.3    Boolean Literals</h3>
<a name="49657"></a>
The <code>boolean</code> type has two values, represented by the literals <code>true</code> and <code>false</code>, formed from ASCII letters.<p>
<a name="229664"></a>
A <em>boolean literal</em> is always of type <code>boolean</code>.<p>
<ul><pre>
<i>BooleanLiteral: one of</i>
<code>	true false
</code></pre></ul><a name="100960"></a>
<h3>3.10.4    Character Literals</h3>
<a name="100964"></a>
A <em>character literal</em> is expressed as a character or an escape sequence, enclosed in ASCII single quotes. (The single-quote, or apostrophe, character is <code>\u0027</code>.)<p>
<a name="229640"></a>
A character literal is always of type <code>char</code>.<p>
<ul><pre>
<i>CharacterLiteral:
	<code>' </code>SingleCharacter<code> '
	' </code>EscapeSequence<code> '
</code>
SingleCharacter:
	InputCharacter</i> but not <code>'</code> or <code>\
</code></pre></ul><a name="100967"></a>
The escape sequences are described in <a href="lexical.doc.html#101089">&#167;3.10.6</a>.<p>
<a name="229112"></a>
As specified in <a href="lexical.doc.html#231571">&#167;3.4</a>, the characters <code>CR</code> and <code>LF</code> are never an <em>InputCharacter</em>; they are recognized as constituting a <em>LineTerminator</em>.<p>
<a name="100968"></a>
It is a compile-time error for the character following the <em>SingleCharacter</em> or <em>EscapeSequence</em> to be other than a <code>'</code>.<p>
<a name="229137"></a>
It is a compile-time error for a line terminator to appear after the opening <code>'</code> and before the closing <code>'</code>.<p>
<a name="229739"></a>
The following are examples of <code>char</code> literals:
<blockquote><pre>'a'
'%'
'\t'
'\\'
'\''
'\u03a9'
'\uFFFF'
'\177'
'<img src="chars/capomega.gif">'
'<img src="chars/circmult.gif">'
<a name="230985"></a>
</pre></blockquote>
Because Unicode escapes are processed very early, it is not correct to write <code>'\u000a'</code> for a character literal whose value is linefeed (LF); the Unicode escape <code>\u000a</code> is transformed into an actual linefeed in translation step 1 <a href="lexical.doc.html#100850">(&#167;3.3)</a> and the linefeed becomes a <em>LineTerminator</em> in step 2 <a href="lexical.doc.html#231571">(&#167;3.4)</a>, and so the character literal is not valid in step 3. Instead, one should use the escape sequence <code>'\n'</code> <a href="lexical.doc.html#101089">(&#167;3.10.6)</a>. Similarly, it is not correct to write <code>'\u000d'</code> for a character literal whose value is carriage return (<code>CR</code>). Instead, use <code>'\r'</code>.
<a name="229744"></a>
<p>In C and C++, a character literal may contain representations of more than one character, but the value of such a character literal is implementation-defined. In the Java programming language, a character literal always represents exactly one character.

<h3>3.10.5    String Literals</h3>
<a name="101084"></a>
A <em>string literal</em> consists of zero or more characters enclosed in double quotes. Each character may be represented by an escape sequence.<p>
<a name="229653"></a>
A string literal is always of type <code>String</code> (<a href="typesValues.doc.html#26992">&#167;4.3.3</a>. A string literal always refers to the same instance <a href="typesValues.doc.html#12028">(&#167;4.3.1)</a> of class <code>String</code>.<p>
<ul><pre>
<i>StringLiteral:
	<code>" </code>StringCharacters<sub><i>opt</i></sub><code> "
</code>
StringCharacters:
	StringCharacter
	StringCharacters<code> </code>StringCharacter

StringCharacter:
<code>	</code>InputCharacter</i> but not <code>"</code> or <code>\
	</code><i>EscapeSequence</i>
</pre></ul><a name="22983"></a>
The escape sequences are described in <a href="lexical.doc.html#101089">&#167;3.10.6</a>.<p>
<a name="19350"></a>
As specified in <a href="lexical.doc.html#231571">&#167;3.4</a>, neither of the characters <code>CR</code> and <code>LF</code> is ever considered to be an <em>InputCharacter</em>; each is recognized as constituting a <em>LineTerminator</em>.<p>
<a name="21405"></a>
It is a compile-time error for a line terminator to appear after the opening <code>"</code> and before the closing matching <code>"</code>. A long string literal can always be broken up into shorter pieces and written as a (possibly parenthesized) expression using the string concatenation operator <code>+</code> <a href="expressions.doc.html#39990">(&#167;15.18.1)</a>.<p>
<a name="229156"></a>
The following are examples of string literals:
<blockquote><pre>
""				// the empty string
"\""				// a string containing " alone
"This is a string"		// a string containing 16 characters
"This is a " +			// actually a string-valued constant expression,
	"two-line string"	//		formed from two string literals
	</pre></blockquote>
<a name="25884"></a>
Because Unicode escapes are processed very early, it is not correct to write <code>"\u000a"</code> for a string literal containing a single linefeed (LF); the Unicode escape <code>\u000a</code> is transformed into an actual linefeed in translation step 1 <a href="lexical.doc.html#100850">(&#167;3.3)</a> and the linefeed becomes a <em>LineTerminator</em> in step 2 <a href="lexical.doc.html#231571">(&#167;3.4)</a>, and so the string literal is not valid in step 3. Instead, one should write <code>"\n"</code> <a href="lexical.doc.html#101089">(&#167;3.10.6)</a>. Similarly, it is not correct to write <code>"\u000d"</code> for a string literal containing a single carriage return (CR). Instead use <code>"\r"</code>.
</pre></blockquote><a name="19369"></a>
Each string literal is a reference <a href="typesValues.doc.html#9317">(&#167;4.3)</a> to an instance (<a href="typesValues.doc.html#12028">&#167;4.3.1</a>, <a href="execution.doc.html#44670">&#167;12.5</a>) of class <code>String</code> (<a href="typesValues.doc.html#26992">&#167;4.3.3</a>). <code>String</code> objects have a constant value. String literals-or, more generally, strings that are the values of constant expressions <a href="expressions.doc.html#5313">(&#167;15.28)</a>-are "interned" so as to share unique instances, using the method <code>String.intern</code>.<p>
<a name="231331"></a>
Thus, the test program consisting of the compilation unit <a href="packages.doc.html#40031">(&#167;7.3)</a>:
<blockquote><pre>package testPackage;
class Test {
	public static void main(String[] args) {
		String hello = "Hello", lo = "lo";
		System.out.print((hello == "Hello") + " ");
		System.out.print((Other.hello == hello) + " ");
		System.out.print((other.Other.hello == hello) + " ");
		System.out.print((hello == ("Hel"+"lo")) + " ");
		System.out.print((hello == ("Hel"+lo)) + " ");
		System.out.println(hello == ("Hel"+lo).intern());
	}
}
class Other { static String hello = "Hello"; }
</pre></blockquote><a name="229778"></a>
and the compilation unit:<p>
<blockquote><pre>package other;
public class Other { static String hello = "Hello"; }
</pre></blockquote><a name="23261"></a>
produces the output:<p>
<blockquote><pre>true true true true false true
</pre></blockquote><a name="241669"></a>
This example illustrates six points:<p>
<ul><a name="241676"></a>
<li>Literal strings within the same class <a href="classes.doc.html#3857">(&#167;8)</a> in the same package <a href="packages.doc.html#34412">(&#167;7)</a> represent references to the same <code>String</code> object <a href="typesValues.doc.html#12028">(&#167;4.3.1)</a>.
<a name="229807"></a>
<li>Literal strings within different classes in the same package represent references to the same <code>String</code> object.
<a name="229797"></a>
<li>Literal strings within different classes in different packages likewise represent references to the same <code>String</code> object.
<a name="23858"></a>
<li>Strings computed by constant expressions <a href="expressions.doc.html#5313">(&#167;15.28)</a> are computed at compile time and then treated as if they were literals.
<a name="23859"></a>
<li>Strings computed at run time are newly created and therefore distinct.
<a name="23865"></a>
<li>The result of explicitly interning a computed string is the same string as any pre-existing literal string with the same contents.
</ul><a name="101089"></a>
<h3>3.10.6    Escape Sequences for Character and String Literals</h3>
<a name="230359"></a>
The character and string <em>escape sequences</em> allow for the representation of some nongraphic characters as well as the single quote, double quote, and backslash characters in character literals <a href="lexical.doc.html#100960">(&#167;3.10.4)</a> and string literals <a href="lexical.doc.html#101083">(&#167;3.10.5)</a>.<p>
<ul><pre>
EscapeSequence:
<code>	\ b			/*&#32;\u0008:&#32;</code>backspace<code>&#32;</code><code>BS</code> <code>*/
	\ t			/*&#32;\u0009:&#32;</code>horizontal tab<code>&#32;</code><code>HT</code> <code>*/
	\ n			/*&#32;\u000a:&#32;</code>linefeed<code>&#32;</code><code>LF</code> <code>*/
	\ f			/*&#32;\u000c:&#32;</code>form feed<code>&#32;</code><code>FF</code> <code>*/
	\ r			/*&#32;\u000d:&#32;</code>carriage return<code>&#32;</code><code>CR</code> <code>*/
	\ "			/*&#32;\u0022:&#32;</code>double quote <code>" */
	\ '			/*&#32;\u0027:&#32;</code>single quote <code>' */
	\ \			/*&#32;\u005c:&#32;</code>backslash <code>\ */
	</code><i>OctalEscape</i><code>		/*&#32;\u0000</code> to <code>\u00ff:&#32;</code>from octal value<code> */
</code>
<i>OctalEscape:
	<code>\ </code>OctalDigit
<code>	\ </code>OctalDigit<code> </code>OctalDigit
<code>	\ </code>ZeroToThree<code> </code>OctalDigit<code> </code>OctalDigit

OctalDigit: one of</i>
	<code>0 1 2 3 4 5 6 7
</code>
<i>ZeroToThree: one of</i>
	<code>0 1 2 3
</code></pre></ul><a name="230722"></a>
It is a compile-time error if the character following a backslash in an escape is not an ASCII <code>b</code>, <code>t</code>, <code>n</code>, <code>f</code>, <code>r</code>, <code>"</code>, <code>'</code>, <code>\</code>, <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, or <code>7</code>. The Unicode escape <code>\u</code> is processed earlier <a href="lexical.doc.html#100850">(&#167;3.3)</a>. (Octal escapes are provided for compatibility with C, but can express only Unicode values <code>\u0000</code> through <code>\u00FF</code>, so Unicode escapes are usually preferred.)<p>
<a name="230717"></a>
<h3>3.10.7    The Null Literal</h3>
<a name="24276"></a>
The null type has one value, the null reference, represented by the literal <code>null</code>, which is formed from ASCII characters. A <em>null literal</em> is always of the null type.<p>
<ul><pre>
<i>NullLiteral:</i>
<code>	null
</code></pre></ul><a name="230752"></a>
<h2>3.11    Separators</h2>
<a name="230757"></a>
The following nine ASCII characters are the <em>separators </em>(punctuators):<p>
<ul><pre>
<i>Separator: one of</i>
	<code>(	)	{	}	[	]	;	,	.
</code></pre></ul><a name="230663"></a>
<h2>3.12    Operators</h2>
<a name="230669"></a>
The following 37 tokens are the <em>operators</em>,<em> </em>formed from ASCII characters:<p>
<ul><pre>
<i>Operator: one of</i>
<code>	=	&gt;	&lt;	!	~	?	:
	==	&lt;=	&gt;=	!=	&amp;&amp;	||	++	--
	+	-	*	/	&amp;	|	^	%	&lt;&lt;	&gt;&gt;	&gt;&gt;&gt;
	+=	-=	*=	/=	&amp;=	|=	^=	%=	&lt;&lt;=	&gt;&gt;=	&gt;&gt;&gt;=
</code></pre></ul><a name="230794"></a>

<hr>
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="grammars.doc.html">Prev</a> | <a href="typesValues.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<i><a href="jcopyright.doc.html">Copyright</a> &#169 2000 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jls@java.sun.com">jls@java.sun.com</a>
</font>
</body></html>
