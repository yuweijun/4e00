<html>
<head>
<title> Classes</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="packages.doc.html">Prev</a> | <a href="interfaces.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<hr><br>
 
<a name="3857"></a>
<p><strong>
CHAPTER
 8 </strong></p>
<a name="44365"></a>
<h1>Classes</h1>
<hr><p>
<a name="228205"></a>
Class declarations define new reference types and describe how they are implemented <a href="classes.doc.html#15372">(&#167;8.1)</a>.<p>
<a name="246201"></a>
A <em>nested class</em> is any class whose declaration occurs within the body of another class or interface. A <em>top level class</em> is a class that is not a nested class.<p>
<a name="246214"></a>
This chapter discusses the common semantics of all classes-top level <a href="packages.doc.html#26783">(&#167;7.6)</a> and nested (including member classes (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>), local classes <a href="statements.doc.html#247766">(&#167;14.3)</a> and anonymous classes <a href="expressions.doc.html#252986">(&#167;15.9.5)</a>). Details that are specific to particular kinds of classes are discussed in the sections dedicated to these constructs. <p>
<a name="228209"></a>
A named class may be declared <code>abstract</code> <a href="classes.doc.html#34944">(&#167;8.1.1.1)</a> and must be declared <code>abstract</code> if it is incompletely implemented; such a class cannot be instantiated, but can be extended by subclasses. A class may be declared <code>final</code> <a href="classes.doc.html#54727">(&#167;8.1.1.2)</a>, in which case it cannot have subclasses. If a class is declared <code>public</code>, then it can be referred to from other packages.<p>
<a name="35674"></a>
Each class except <code>Object</code> is an extension of (that is, a subclass of) a single existing class <a href="classes.doc.html#262560">(&#167;8.1.3)</a> and may implement interfaces <a href="classes.doc.html#34031">(&#167;8.1.4)</a>.
<a name="273974"></a>
<p>
The body of a class declares members (fields and methods and nested classes and interfaces), instance and static initializers, and constructors <a href="classes.doc.html#18988">(&#167;8.1.5)</a>. The scope <a href="names.doc.html#103228">(&#167;6.3)</a> of a member <a href="classes.doc.html#21831">(&#167;8.2)</a> is the entire declaration of the class to which the member belongs. Field, method, member class, member interface, and constructor declarations may include the access modifiers <a href="names.doc.html#104285">(&#167;6.6)</a> <code>public</code>, <code>protected</code>, or <code>private</code>. The members of a class include both declared and inherited members <a href="classes.doc.html#21831">(&#167;8.2)</a>. Newly declared fields can hide fields declared in a superclass or superinterface. Newly declared class members and interface members can hide class or interface members declared in a superclass or superinterface. Newly declared methods can hide, implement, or override methods declared in a superclass or superinterface.<p>
<a name="15807"></a>
Field declarations <a href="classes.doc.html#40898">(&#167;8.3)</a> describe class variables, which are incarnated once, and instance variables, which are freshly incarnated for each instance of the class. A field may be declared <code>final</code> <a href="classes.doc.html#35962">(&#167;8.3.1.2)</a>, in which case it can be assigned to only once. Any field declaration may include an initializer.<p>
<a name="245981"></a>
Member class declarations <a href="classes.doc.html#246026">(&#167;8.5)</a> describe nested classes that are members of the surrounding class. Member classes may be static, in which case they have no access to the instance variables of the surrounding class; or they may be inner classes <a href="classes.doc.html#262890">(&#167;8.1.2)</a>.<p>
<a name="245982"></a>
Member interface declarations <a href="classes.doc.html#246026">(&#167;8.5)</a> describe nested interfaces that are members of the surrounding class.<p>
<a name="35821"></a>
Method declarations <a href="classes.doc.html#40420">(&#167;8.4)</a> describe code that may be invoked by method invocation expressions <a href="expressions.doc.html#20448">(&#167;15.12)</a>. A class method is invoked relative to the class type; an instance method is invoked with respect to some particular object that is an instance of the class type. A method whose declaration does not indicate how it is implemented must be declared <code>abstract</code>. A method may be declared <code>final</code> <a href="classes.doc.html#11246">(&#167;8.4.3.3)</a>, in which case it cannot be hidden or overridden. A method may be implemented by platform-dependent <code>native</code> code <a href="classes.doc.html#31125">(&#167;8.4.3.4)</a>. A <code>synchronized</code> method <a href="classes.doc.html#260369">(&#167;8.4.3.6)</a> automatically locks an object before executing its body and automatically unlocks the object on return, as if by use of a <code>synchronized</code> statement <a href="statements.doc.html#255769">(&#167;14.18)</a>, thus allowing its activities to be synchronized with those of other threads <a href="memory.doc.html#26250">(&#167;17)</a>.<p>
<a name="227762"></a>
Method names may be overloaded <a href="classes.doc.html#227768">(&#167;8.4.7)</a>.<p>
<a name="246235"></a>
Instance initializers <a href="classes.doc.html#246032">(&#167;8.6)</a> are blocks of executable code that may be used to help initialize an instance when it is created <a href="expressions.doc.html#41147">(&#167;15.9)</a>.<p>
<a name="35837"></a>
Static initializers <a href="classes.doc.html#39245">(&#167;8.7)</a> are blocks of executable code that may be used to help initialize a class when it is first loaded <a href="execution.doc.html#44557">(&#167;12.4)</a>.<p>
<a name="259034"></a>
Constructors <a href="classes.doc.html#41652">(&#167;8.8)</a> are similar to methods, but cannot be invoked directly by a method call; they are used to initialize new class instances. Like methods, they may be overloaded <a href="classes.doc.html#229266">(&#167;8.8.6)</a>.<p>
<a name="15372"></a>
<h2>8.1    Class Declaration</h2>
<a name="23643"></a>
A <em>class declaration</em> specifies a new named reference type:<p>
<ul><pre>
<em>ClassDeclaration:
	ClassModifiers<sub><i>opt</i></sub> </em>class<em> Identifier Super<sub><i>opt</i></sub> Interfaces<sub><i>opt</i></sub> ClassBody</em>
</pre></ul><a name="287266"></a>
The <em>Identifier</em> in a class declaration specifies the name of the class. A compile-time error occurs if a class has the same simple name as any of its enclosing classes or interfaces. <p>
<a name="21613"></a>
<h3>8.1.1    Class Modifiers</h3>
<a name="54718"></a>
A class declaration may include <em>class modifiers</em>.<p>
<ul><pre>
<em>ClassModifiers:
	ClassModifier
	ClassModifiers ClassModifier

ClassModifier: one of</em>
	public&#32;protected&#32;private
	abstract&#32;static&#32;final&#32;strictfp
</pre></ul><a name="258803"></a>
Not all modifiers are applicable to all kinds of class declarations. The access modifier public pertains only to top level classes <a href="packages.doc.html#26783">(&#167;7.6)</a> and to member classes (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>), and is discussed in <a href="names.doc.html#104285">&#167;6.6</a>, <a href="classes.doc.html#246026">&#167;8.5</a> and <a href="interfaces.doc.html#252566">&#167;9.5</a>. The access modifiers protected and private pertain only to member classes within a directly enclosing class declaration <a href="classes.doc.html#246026">(&#167;8.5)</a> and are discussed in <a href="classes.doc.html#247581">&#167;8.5.1</a>. The access modifier static pertains only to member classes (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>). A compile-time error occurs if the same modifier appears more than once in a class declaration. <p>
<a name="259039"></a>
If two or more class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>ClassModifier</em>.<p>
<a name="34944"></a>
<h4>8.1.1.1    <code>abstract</code> Classes</h4>
<a name="20269"></a>
An <code>abstract</code> class is a class that is incomplete, or to be considered incomplete. Only <code>abstract</code> classes may have <code>abstract</code> methods (<a href="classes.doc.html#34484">&#167;8.4.3.1</a>, <a href="interfaces.doc.html#78651">&#167;9.4</a>), that is, methods that are declared but not yet implemented. If a class that is not <code>abstract</code> contains an <code>abstract</code> method, then a compile-time error occurs. A class C has <code>abstract</code> methods if any of the following is true:<p>
<ul><a name="36417"></a>
<li>C explicitly contains a declaration of an <code>abstract</code> method <a href="classes.doc.html#78188">(&#167;8.4.3)</a>.
<a name="250484"></a>
<li>Any of C's superclasses declares an <code>abstract</code> method that has not been implemented <a href="classes.doc.html#227927">(&#167;8.4.6.1)</a> in C or any of its superclasses. 
<a name="14247"></a>
<li>A direct superinterface (<a href="classes.doc.html#34031">&#167;8.1.4</a>) of C declares or inherits a method (which is therefore necessarily <code>abstract</code>) and C neither declares nor inherits a method that implements it.
<a name="259043"></a>
<p>
</ul>
In the example:
<blockquote><pre>abstract class Point {
	int x = 1, y = 1;
	void move(int dx, int dy) {
		x += dx;
		y += dy;
		alert();
	}
	abstract void alert();
}
abstract class ColoredPoint extends Point {
	int color;
}
class SimplePoint extends Point {
	void alert() { }
}
</pre></blockquote><a name="259046"></a>
a class <code>Point</code> is declared that must be declared <code>abstract</code>, because it contains a declaration of an <code>abstract</code> method named <code>alert</code>. The subclass of <code>Point</code> named<code> ColoredPoint</code> inherits the <code>abstract</code> method <code>alert</code>, so it must also be declared <code>abstract</code>. On the other hand, the subclass of <code>Point</code> named <code>SimplePoint</code> provides an implementation of <code>alert</code>, so it need not be <code>abstract</code>.<p>
<a name="259051"></a>
A compile-time error occurs if an attempt is made to create an instance of an <code>abstract</code> class using a class instance creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a>. <p>
<a name="259044"></a>
Thus, continuing the example just shown, the statement:
<blockquote><pre>	Point p = new Point();
</pre></blockquote><a name="54883"></a>
would result in a compile-time error; the class <code>Point</code> cannot be instantiated because it is <code>abstract</code>. However, a <code>Point</code> variable could correctly be initialized with a reference to any subclass of <code>Point</code>, and the class <code>SimplePoint</code> is not <code>abstract</code>, so the statement:<p>
<blockquote><pre>	Point p = new SimplePoint();
</pre></blockquote><a name="227782"></a>
would be correct.<p>
<a name="259056"></a>
A subclass of an <code>abstract</code> class that is not itself <code>abstract</code> may be instantiated, resulting in the execution of a constructor for the <code>abstract</code> class and, therefore, the execution of the field initializers for instance variables of that class. Thus, in the example just given, instantiation of a <code>SimplePoint</code> causes the default constructor and field initializers for <code>x</code> and <code>y</code> of <code>Point</code> to be executed.
<a name="292198"></a>
It is a compile-time error to declare an <code>abstract</code> class type such that it is not possible to create a subclass that implements all of its <code>abstract</code> methods. This situation can occur if the class would have as members two <code>abstract</code> methods that have the same method signature <a href="classes.doc.html#38649">(&#167;8.4.2)</a> but different return types. <p>
<a name="292194"></a>
As an example, the declarations:
<blockquote><pre>interface Colorable { void setColor(int color); }
abstract class Colored implements Colorable {
	abstract int setColor(int color);
}
</pre></blockquote><a name="25369"></a>
result in a compile-time error: it would be impossible for any subclass of class <code>Colored</code> to provide an implementation of a method named <code>setColor</code>, taking one argument of type <code>int</code>, that can satisfy both <code>abstract</code> method specifications, because the one in interface <code>Colorable</code> requires the same method to return no value, while the one in class <code>Colored</code> requires the same method to return a value of type <code>int</code> <a href="classes.doc.html#40420">(&#167;8.4)</a>.<p>
<a name="36521"></a>
A class type should be declared <code>abstract</code> only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor <a href="classes.doc.html#16830">(&#167;8.8.8)</a> of no arguments, make it <code>private</code>, never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class <code>Math</code> is an example of a class that cannot be instantiated; its declaration looks like this:
<blockquote><pre>public final class Math {
	private Math() { }		// never instantiate this class
<em>	. . . declarations of class variables and methods . . .
</em><a name="259064"></a>
}
</pre></blockquote><a name="54727"></a>
<h4>8.1.1.2    <code>final</code> Classes</h4>
<a name="54729"></a>
A class can be declared <code>final</code> if its definition is complete and no subclasses are desired or required. A compile-time error occurs if the name of a <code>final</code> class appears in the <code>extends</code> clause <a href="classes.doc.html#262560">(&#167;8.1.3)</a> of another <code>class</code> declaration; this implies that a <code>final</code> class cannot have any subclasses. A compile-time error occurs if a class is declared both <code>final</code> and <code>abstract</code>, because the implementation of such a class could never be completed <a href="classes.doc.html#34944">(&#167;8.1.1.1)</a>.<p>
<a name="259069"></a>
Because a <code>final</code> class never has any subclasses, the methods of a <code>final</code> class are never overridden <a href="classes.doc.html#227927">(&#167;8.4.6.1)</a>.
<a name="251946"></a>
<h4>8.1.1.3    <code>strictfp</code> Classes</h4>
<a name="251947"></a>
The effect of the <code>strictfp</code> modifier is to make all <code>float</code> or <code>double </code>expressions within the class declaration be explicitly FP-strict <a href="expressions.doc.html#249198">(&#167;15.4)</a>. This implies that all methods declared in the class, and all nested types declared in the class, are implicitly <code>strictfp</code>. <p>
<a name="270918"></a>
Note also that all <code>float</code> or <code>double </code>expressions within all variable initializers, instance initializers, static initializers and constructors of the class will also be explicitly FP-strict.
<a name="262890"></a>
<h3>8.1.2    Inner Classes and Enclosing Instances</h3>
<a name="246255"></a>
An inner class is a nested class that is not explicitly or implicitly declared static. Inner classes may not declare static initializers <a href="classes.doc.html#39245">(&#167;8.7)</a> or member interfaces. Inner classes may not declare static members, unless they are compile-time constant fields <a href="expressions.doc.html#5313">(&#167;15.28)</a>.<p>
<a name="263434"></a>
To illustrate these rules, consider the example below:
<blockquote><pre>class HasStatic{
	static int j = 100;
}
class Outer{
	class Inner extends HasStatic{
		static final x = 3;		// ok - compile-time constant
		static int y = 4; 		// compile-time error, an inner class
	}
	static class NestedButNotInner{
		static int z = 5; 		// ok, not an inner class
	}
	interface NeverInner{}		// interfaces are never inner
}
</pre></blockquote><a name="270924"></a>
Inner classes may inherit static members that are not compile-time constants even though they may not declare them. Nested classes that are not inner classes may declare static members freely, in accordance with the usual rules of the Java programming language. Member interfaces <a href="classes.doc.html#246026">(&#167;8.5)</a> are always implicitly static so they are never considered to be inner classes. <p>
<a name="255246"></a>
A statement or expression <em>occurs in a static context</em> if and only if the innermost method, constructor, instance initializer, static initializer, field initializer, or explicit constructor statement enclosing the statement or expression is a static method, a static initializer, the variable initializer of a static variable, or an explicit constructor invocation statement <a href="classes.doc.html#78435">(&#167;8.8.5)</a>.<p>
<a name="247506"></a>
An inner class <i>C</i> is a <em>direct inner class of a class O</em> if <i>O</i> is the immediately lexically enclosing class of <i>C</i> and the declaration of <i>C</i> does not occur in a static context. A class <i>C</i> is an <i>inner class of class O</i> if it is either a direct inner class of <i>O</i> or an inner class of an inner class of <i>O</i>.<p>
<a name="255368"></a>
A class <i>O</i> is the <i>zeroth lexically enclosing class of itself</i>. A class <i>O</i> is the <i>nth lexically enclosing class of a class C</i> if it is the immediately enclosing class of the <i>n</i> - 1st lexically enclosing class of <i>C</i>.<p>
<a name="246965"></a>
An instance <i>i</i> of a direct inner class <i>C</i> of a class <i>O</i> is associated with an instance of <i>O</i>, known as the <i>immediately enclosing instance</i> of <i>i</i>. The immediately enclosing instance of an object, if any, is determined when the object is created <a href="expressions.doc.html#253028">(&#167;15.9.2)</a>.<p>
<a name="255371"></a>
An object <i>o</i> is the <i>zeroth lexically enclosing instance of itself</i>. An object <i>o</i> is the <i>nth lexically enclosing instance of an instance i</i> if it is the immediately enclosing instance of the <i>n</i> - 1st lexically enclosing instance of <i>i</i>.<p>
<a name="247026"></a>
When an inner class refers to an instance variable that is a member of a lexically enclosing class, the variable of the corresponding lexically enclosing instance is used. A blank final <a href="typesValues.doc.html#10931">(&#167;4.5.4)</a> field of a lexically enclosing class may not be assigned within an inner class.<p>
<a name="250538"></a>
An instance of an inner class <i>I</i> whose declaration occurs in a static context has no lexically enclosing instances. However, if <i>I</i> is immediately declared within a static method or static initializer then <i>I</i> does have an <i>enclosing block</i>, which is the innermost block statement lexically enclosing the declaration of <i>I</i>.<p>
<a name="254910"></a>
Furthermore, for every superclass <i>S</i> of <i>C</i> which is itself a direct inner class of a class <i>SO</i>, there is an instance of <i>SO</i> associated with <i>i</i>, known as <em>the immediately enclosing instance of i with respect to S</em>. The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement.<p>
<a name="247496"></a>
Any local variable, formal method parameter or exception handler parameter used but not declared in an inner class must be declared <code>final</code>, and must be definitely assigned <a href="defAssign.doc.html#25979">(&#167;16)</a> before the body of the inner class.<p>
<a name="247494"></a>
Inner classes include local <a href="statements.doc.html#247766">(&#167;14.3)</a>, anonymous <a href="expressions.doc.html#252986">(&#167;15.9.5)</a> and non-static member classes <a href="classes.doc.html#246026">(&#167;8.5)</a>. Here are some examples:
<blockquote><pre>class Outer {
	int i = 100;
	static void classMethod() {
		final int l = 200;
		class LocalInStaticContext{
			int k = i; // compile-time error
			int m = l; // ok
		}
	}
	void foo() {
		class Local { // a local class
			int j = i;
		}
	}
}
</pre></blockquote>
<a name="262528"></a>
The declaration of class <code>LocalInStaticContext</code> occurs in a static context-within the static method <code>classMethod</code>. Instance variables of class <code>Outer</code> are not available within the body of a static method. In particular, instance variables of <code>Outer</code> are not available inside the body of <code>LocalInStaticContext</code>. However, local variables from the surrounding method may be referred to without error (provided they are marked <code>final</code>).
<a name="262541"></a>
<p>Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class, the instance variable must be defined with respect to an enclosing instance of that class. So, for example, the class <code>Local</code> above has an enclosing instance of class <code>Outer</code>. As a further example:
<blockquote><pre>
class WithDeepNesting{
	boolean toBe;
	WithDeepNesting(boolean b) { toBe = b;}
	class Nested {
		boolean theQuestion;
		class DeeplyNested {
			DeeplyNested(){
				theQuestion = toBe || !toBe;
			}
		}
	}
}
</pre></blockquote><a name="270930"></a>
Here, every instance of <code>WithDeepNesting.Nested.DeeplyNested</code> has an enclosing instance of class <code>WithDeepNesting.Nested</code> (its immediately enclosing instance) and an enclosing instance of class <code>WithDeepNesting</code> (its 2nd lexically enclosing instance).<p>
<a name="262560"></a>
<h3>8.1.3    Superclasses and Subclasses</h3>
<a name="262569"></a>
The optional <code>extends</code> clause in a class declaration specifies the <em>direct superclass</em> of the current class. A class is said to be a <em>direct subclass</em> of the class it extends. The direct superclass is the class from whose implementation the implementation of the current class is derived. The <code>extends</code> clause must not appear in the definition of the class <code>Object</code>, because it is the primordial class and has no direct superclass. If the class declaration for any other class has no <code>extends</code> clause, then the class has the class <code>Object</code> as its implicit direct superclass.<p>
<ul><pre>
<i>Super:</i>
	extends <i>ClassType</i>
</pre></ul><a name="229540"></a>
The following is repeated from <a href="typesValues.doc.html#9317">&#167;4.3</a> to make the presentation here clearer:<p>
<ul><pre>
<i>ClassType:
	TypeName</i>
</pre></ul><a name="29813"></a>
The <em>ClassType</em> must name an accessible <a href="names.doc.html#104285">(&#167;6.6)</a> class type, or a compile-time error occurs. If the specified <em>ClassType </em>names a class that is <code>final</code> <a href="classes.doc.html#54727">(&#167;8.1.1.2)</a>, then a compile-time error occurs; <code>final</code> classes are not allowed to have subclasses.<p>
<a name="34088"></a>
In the example:
<blockquote><pre>class Point { int x, y; }
final class ColoredPoint extends Point { int color; }
class Colored3DPoint extends ColoredPoint { int z; } // error
</pre></blockquote><a name="29322"></a>
the relationships are as follows:<p>
<ul><a name="29323"></a>
<li>The class <code>Point</code> is a direct subclass of <code>Object</code>.
<a name="29324"></a>
<li>The class <code>Object</code> is the direct superclass of the class <code>Point</code>.
<a name="35258"></a>
<li>The class <code>ColoredPoint</code> is a direct subclass of class <code>Point</code>.
<a name="35261"></a>
<li>The class <code>Point</code> is the direct superclass of class <code>ColoredPoint</code>.
</ul><a name="270940"></a>
The declaration of class <code>Colored3dPoint</code> causes a compile-time error because it attempts to extend the <code>final</code> class <code>ColoredPoint</code>.<p>
<a name="259080"></a>
The <em>subclass </em>relationship is the transitive closure of the direct subclass relationship. A class <i>A</i> is a subclass of class <i>C</i> if either of the following is true:<p>
<ul><a name="34080"></a>
<li><i>A</i> is the direct subclass of <i>C</i>.
<a name="34081"></a>
<li>There exists a class <i>B</i> such that <i>A</i> is a subclass of <i>B</i>, and <i>B</i> is a subclass of <i>C</i>, applying this definition recursively.
</ul><a name="34082"></a>
Class <i>C</i> is said to be a <em>superclass </em>of class <i>A</i> whenever <i>A</i> is a subclass of <i>C</i>.<p>
<a name="36594"></a>
In the example:
<blockquote><pre>class Point { int x, y; }
class ColoredPoint extends Point { int color; }
final class Colored3dPoint extends ColoredPoint { int z; }
</pre></blockquote><a name="35276"></a>
the relationships are as follows:<p>
<ul><a name="36602"></a>
<li>The class <code>Point</code> is a superclass of class <code>ColoredPoint</code>.
<a name="36604"></a>
<li>The class <code>Point</code> is a superclass of class <code>Colored3dPoint</code>.
<a name="36611"></a>
<li>The class <code>ColoredPoint</code> is a subclass of class <code>Point</code>.
<a name="36613"></a>
<li>The class <code>ColoredPoint</code> is a superclass of class <code>Colored3dPoint</code>.
<a name="271013"></a>
<li>The class <code>Colored3dPoint</code> is a subclass of class <code>ColoredPoint</code>.
<a name="271014"></a>
<li>The class <code>Colored3dPoint</code> is a subclass of class <code>Point</code>.
</ul><a name="271016"></a>
A class C <em>directly depends</em> on a type T if T is mentioned in the <code>extends</code> or <code>implements</code> clause of C either as a superclass or superinterface, or as a qualifier within a superclass or superinterface name. A class C <em>depends</em> on a reference type T if any of the following conditions hold:<p>
<ul><a name="251985"></a>
<li>C directly depends on T.
<a name="251987"></a>
<li>C directly depends on an interface I that depends <a href="interfaces.doc.html#78598">(&#167;9.1.2)</a> on T.
<a name="251993"></a>
<li>C directly depends on a class D that depends on T (using this definition recursively).
</ul><a name="251995"></a>
It is a compile-time error if a class depends on itself.<p>
<a name="250505"></a>
For example:
<blockquote><pre>class Point extends ColoredPoint { int x, y; }
class ColoredPoint extends Point { int color; }
</pre></blockquote><a name="270956"></a>
causes a compile-time error.<p>
<a name="259094"></a>
If circularly declared classes are detected at run time, as classes are loaded <a href="execution.doc.html#44459">(&#167;12.2)</a>, then a <code>ClassCircularityError</code> is thrown.<p>
<a name="34031"></a>
<h3>8.1.4    Superinterfaces</h3>
<a name="18953"></a>
The optional <code>implements</code> clause in a class declaration lists the names of interfaces that are <em>direct superinterfaces</em> of the class being declared:<p>
<ul><pre>
<i>Interfaces:</i>
	implements <i>InterfaceTypeList

InterfaceTypeList:
	InterfaceType
	InterfaceTypeList , InterfaceType</i>
</pre></ul><a name="229546"></a>
The following is repeated from <a href="typesValues.doc.html#9317">&#167;4.3</a> to make the presentation here clearer:<p>
<ul><pre>
<i>InterfaceType:
	TypeName</i>
</pre></ul><a name="34112"></a>
Each <em>InterfaceType</em> must name an accessible <a href="names.doc.html#104285">(&#167;6.6)</a> interface type, or a compile-time error occurs. <p>
<a name="36646"></a>
A compile-time error occurs if the same interface is mentioned two or more times in a single <code>implements</code> clause.<p>
<a name="258838"></a>
This is true even if the interface is named in different ways; for example, the code:
<blockquote><pre>class Redundant implements java.lang.Cloneable, Cloneable {
	int x;
}
</pre></blockquote><a name="259097"></a>
results in a compile-time error because the names java.lang.<code>Cloneable</code> and <code>Cloneable</code> refer to the same interface.<p>
<a name="31147"></a>
An interface type <i>I</i> is a <em>superinterface</em> of class type <i>C</i> if any of the following is true:<p>
<ul><a name="34118"></a>
<li><i>I</i> is a direct superinterface of <i>C</i>.
<a name="29862"></a>
<li><i>C</i> has some direct superinterface <i>J</i> for which <i>I</i> is a superinterface, using the definition of "superinterface of an interface" given in <a href="interfaces.doc.html#78598">&#167;9.1.2</a>.
<a name="34121"></a>
<li><i>I</i> is a superinterface of the direct superclass of <i>C</i>.
</ul><a name="29918"></a>
A class is said to <em>implement</em> all its superinterfaces.<p>
<a name="229105"></a>
In the example:
<blockquote><pre>public interface Colorable {
	void setColor(int color);
	int getColor();
}
public interface Paintable extends Colorable {
	int MATTE = 0, GLOSSY = 1;
	void setFinish(int finish);
	int getFinish();
}
class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {
	int color;
	public void setColor(int color) { this.color = color; }
	public int getColor() { return color; }
}
class PaintedPoint extends ColoredPoint implements Paintable 
{
	int finish;
	public void setFinish(int finish) {
		this.finish = finish;
	}
	public int getFinish() { return finish; }
}
</pre></blockquote><a name="29896"></a>
the relationships are as follows:<p>
<ul><a name="29897"></a>
<li>The interface <code>Paintable</code> is a superinterface of class <code>PaintedPoint</code>.
<a name="29898"></a>
<li>The interface <code>Colorable</code> is a superinterface of class <code>ColoredPoint</code> and of class <code>PaintedPoint</code>.
<a name="29899"></a>
<li>The interface <code>Paintable</code> is a subinterface of the interface <code>Colorable</code>, and <code>Colorable</code> is a superinterface of <code>Paintable</code>, <code>a</code>s defined in <a href="interfaces.doc.html#78598">&#167;9.1.2</a>.
</ul><a name="270974"></a>
A class can have a superinterface in more than one way. In this example, the class <code>PaintedPoint</code> has <code>Colorable</code> as a superinterface both because it is a superinterface of <code>ColoredPoint</code> and because it is a superinterface of <code>Paintable</code>.<p>
<a name="29870"></a>
Unless the class being declared is <code>abstract</code>, the declarations of all the method members of each direct superinterface must be implemented either by a declaration in this class or by an existing method declaration inherited from the direct superclass, because a class that is not <code>abstract</code> is not permitted to have <code>abstract</code> methods <a href="classes.doc.html#34944">(&#167;8.1.1.1)</a>.<p>
<a name="230327"></a>
Thus, the example:
<blockquote><pre>interface Colorable {
	void setColor(int color);
	int getColor();
}
class Point { int x, y; };
class ColoredPoint extends Point implements Colorable {
	int color;
}
</pre></blockquote><a name="36705"></a>
causes a compile-time error, because <code>ColoredPoint</code> is not an <code>abstract</code> class but it fails to provide an implementation of methods <code>setColor</code> and <code>getColor</code> of the interface <code>Colorable</code>.<p>
<a name="228059"></a>
It is permitted for a single method declaration in a class to implement methods of more than one superinterface. For example, in the code:
<blockquote><pre>interface Fish { int getNumberOfScales(); }
interface Piano { int getNumberOfScales(); }
class Tuna implements Fish, Piano {
	// You can tune a piano, but can you tuna fish?
	int getNumberOfScales() { return 91; }
}
</pre></blockquote><a name="228071"></a>
the method <code>getNumberOfScales</code> in class <code>Tuna</code> has a name, signature, and return type that matches the method declared in interface <code>Fish</code> and also matches the method declared in interface <code>Piano</code>; it is considered to implement both.<p>
<a name="228080"></a>
On the other hand, in a situation such as this:
<blockquote><pre>interface Fish { int getNumberOfScales(); }
interface StringBass { double getNumberOfScales(); }
class Bass implements Fish, StringBass {
	// This declaration cannot be correct, no matter what type is used.
	public ??? getNumberOfScales() { return 91; }
}
</pre></blockquote><a name="270984"></a>
It is impossible to declare a method named <code>getNumberOfScales</code> with the same signature and return type as those of both the methods declared in interface <code>Fish</code> and in interface <code>StringBass</code>, because a class can have only one method with a given signature <a href="classes.doc.html#40420">(&#167;8.4)</a>. Therefore, it is impossible for a single class to implement both interface <code>Fish</code> and interface <code>StringBass</code> <a href="classes.doc.html#228745">(&#167;8.4.6)</a>.<p>
<a name="18988"></a>
<h3>8.1.5    Class Body and Member Declarations</h3>
<a name="77979"></a>
A <em>class body</em> may contain declarations of members of the class, that is, fields <a href="classes.doc.html#40898">(&#167;8.3)</a>, classes <a href="classes.doc.html#246026">(&#167;8.5)</a>, interfaces <a href="classes.doc.html#246026">(&#167;8.5)</a> and methods <a href="classes.doc.html#40420">(&#167;8.4)</a>. A class body may also contain instance initializers <a href="classes.doc.html#246032">(&#167;8.6)</a>, static initializers <a href="classes.doc.html#39245">(&#167;8.7)</a>, and declarations of constructors <a href="classes.doc.html#41652">(&#167;8.8)</a> for the class.<p>
<ul><pre>
<em>ClassBody:
	{ ClassBodyDeclarations<sub>opt</sub> }

ClassBodyDeclarations:
	ClassBodyDeclaration
	ClassBodyDeclarations ClassBodyDeclaration

ClassBodyDeclaration:
	ClassMemberDeclaration
	InstanceInitializer
	StaticInitializer
	ConstructorDeclaration

ClassMemberDeclaration:
	FieldDeclaration
	MethodDeclaration
	ClassDeclaration						
	InterfaceDeclaration
	;			</em> 
</pre></ul><a name="294464"></a>
The scope of a declaration of a member m declared in or inherited by a class type C is the entire body of <i>C</i>, including any nested type declarations.<p>
<a name="250255"></a>
If C itself is a nested class, there may be definitions of the same kind (variable, method, or type) for m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared or inherited in C shadows <a href="names.doc.html#34133">(&#167;6.3.1)</a> the other definitions of m. <p>
<a name="21831"></a>
<h2>8.2    Class Members</h2>
<a name="40942"></a>
The members of a class type are all of the following:<p>
<ul><a name="40946"></a>
<li>Members inherited from its direct superclass <a href="classes.doc.html#262560">(&#167;8.1.3)</a>, except in class <code>Object</code>, which has no direct superclass
<a name="45862"></a>
<li>Members inherited from any direct superinterfaces <a href="classes.doc.html#34031">(&#167;8.1.4)</a>
<a name="45866"></a>
<li>Members declared in the body of the class <a href="classes.doc.html#18988">(&#167;8.1.5)</a>
</ul><a name="30394"></a>
Members of a class that are declared <code>private</code> are not inherited by subclasses of that class. Only members of a class that are declared <code>protected</code> or <code>public</code> are inherited by subclasses declared in a package other than the one in which the class is declared.<p>
<a name="230007"></a>
Constructors, static initializers, and instance initializers are not members and therefore are not inherited.<p>
<a name="36731"></a>
The example:
<blockquote><pre>class Point {
	int x, y;
	private Point() { reset(); }
	Point(int x, int y) { this.x = x; this.y = y; }
	private void reset() { this.x = 0; this.y = 0; }
}
class ColoredPoint extends Point {
	int color;
	void clear() { reset(); }		// error
}
class Test {
	public static void main(String[] args) {
		ColoredPoint c = new ColoredPoint(0, 0);	// error
		c.reset();				// error
	}
}
</pre></blockquote><a name="14620"></a>
causes four compile-time errors:<p>
<ul><a name="16328"></a>
<li>An error occurs because <code>ColoredPoint</code> has no constructor declared with two integer parameters, as requested by the use in <code>main</code>. This illustrates the fact that <code>ColoredPoint</code> does not inherit the constructors of its superclass <code>Point</code>.
<a name="16329"></a>
<li>Another error occurs because <code>ColoredPoint</code> declares no constructors, and therefore a default constructor for it is automatically created <a href="classes.doc.html#16823">(&#167;8.8.7)</a>, and this default constructor is equivalent to:
</ul><blockquote><pre>	ColoredPoint() { super(); }
</pre></blockquote>
<a name="14625"></a>
which invokes the constructor, with no arguments, for the direct superclass of the class <code>ColoredPoint</code>. The error is that the constructor for <code>Point</code> that takes no arguments is <code>private</code>, and therefore is not accessible outside the class <code>Point</code>, even through a superclass constructor invocation <a href="classes.doc.html#78435">(&#167;8.8.5)</a>.
<a name="270990"></a>
Two more errors occur because the method <code>reset</code> of class <code>Point</code> is <code>private</code>, and therefore is not inherited by class <code>ColoredPoint</code>. The method invocations in method <code>clear</code> of class <code>ColoredPoint</code> and in method <code>main</code> of class <code>Test</code> are therefore not correct.<p>
<a name="30229"></a>
<h3>8.2.1    Examples of Inheritance</h3>
<a name="36776"></a>
This section illustrates inheritance of class members through several examples.<p>
<a name="40830"></a>
<h4>8.2.1.1    Example: Inheritance with Default Access</h4>
<a name="40831"></a>
Consider the example where the <code>points</code> package declares two compilation units:<p>
<blockquote><pre>package points;
public class Point {
	int x, y;
	public void move(int dx, int dy) { x += dx; y += dy; }
}
</pre></blockquote><a name="40836"></a>
and:<p>
<blockquote><pre>package points;
public class Point3d extends Point {
	int z;
	public void move(int dx, int dy, int dz) {
		x += dx; y += dy; z += dz;
	}
}
</pre></blockquote><a name="40844"></a>
and a third compilation unit, in another package, is:<p>
<blockquote><pre>import points.Point3d;
class Point4d extends Point3d {
	int w;
	public void move(int dx, int dy, int dz, int dw) {
		x += dx; y += dy; z += dz; w += dw; // compile-time errors
	}
}
</pre></blockquote><a name="40852"></a>
Here both classes in the <code>points</code> package compile. The class <code>Point3d</code> inherits the fields <code>x</code> and <code>y</code> of class <code>Point</code>, because it is in the same package as <code>Point</code>. The class <code>Point4d</code>, which is in a different package, does not inherit the fields <code>x</code> and <code>y</code> of class <code>Point</code> or the field <code>z</code> of class <code>Point3d</code>, and so fails to compile.<p>
<a name="40853"></a>
A better way to write the third compilation unit would be:
<blockquote><pre>import points.Point3d;
class Point4d extends Point3d {
	int w;
	public void move(int dx, int dy, int dz, int dw) {
		super.move(dx, dy, dz); w += dw;
	}
}
</pre></blockquote><a name="40861"></a>
using the <code>move</code> method of the superclass <code>Point3d</code> to process <code>dx</code>, <code>dy</code>, and <code>dz</code>. If <code>Point4d</code> is written in this way it will compile without errors.<p>
<a name="40862"></a>
<h4>8.2.1.2    Inheritance with public and protected</h4>
<a name="40863"></a>
Given the class <code>Point</code>:<p>
<blockquote><pre>package points;
public class Point {
	public int x, y;
	protected int useCount = 0;
	static protected int totalUseCount = 0;
	public void move(int dx, int dy) {
		x += dx; y += dy; useCount++; totalUseCount++;
	}
}
</pre></blockquote><a name="40872"></a>
the <code>public</code> and <code>protected</code> fields <code>x</code>, <code>y</code>, <code>useCount</code> and <code>totalUseCount</code> are inherited in all subclasses of <code>Point</code>. <p>
<a name="292212"></a>
Therefore, this test program, in another package, can be compiled successfully:
<blockquote><pre>class Test extends points.Point {
	public void moveBack(int dx, int dy) {
		x -= dx; y -= dy; useCount++; totalUseCount++;
	}
}
</pre></blockquote><a name="40879"></a>
<h4>8.2.1.3    Inheritance with private</h4>
<a name="40880"></a>
In the example:<p>
<blockquote><pre>class Point {
	int x, y;
	void move(int dx, int dy) {
		x += dx; y += dy; totalMoves++;
	}
	private static int totalMoves;
	void printMoves() { System.out.println(totalMoves); }
}
class Point3d extends Point {
	int z;
	void move(int dx, int dy, int dz) {
		super.move(dx, dy); z += dz; totalMoves++;
	}
}
</pre></blockquote><a name="40822"></a>
the class variable <code>totalMoves</code> can be used only within the class <code>Point</code>; it is not inherited by the subclass <code>Point3d</code>. A compile-time error occurs because method <code>move</code> of class <code>Point3d</code> tries to increment <code>totalMoves</code>.<p>
<a name="23530"></a>
<h4>8.2.1.4    Accessing Members of Inaccessible Classes</h4>
<a name="23515"></a>
Even though a class might not be declared <code>public</code>, instances of the class might be available at run time to code outside the package in which it is declared if it has a <code>public</code> superclass or superinterface. An instance of the class can be assigned to a variable of such a <code>public</code> type. An invocation of a <code>public</code> method of the object referred to by such a variable may invoke a method of the class if it implements or overrides a method of the <code>public</code> superclass or superinterface. (In this situation, the method is necessarily declared <code>public</code>, even though it is declared in a class that is not <code>public</code>.)<p>
<a name="23519"></a>
Consider the compilation unit:
<blockquote><pre>package points;
public class Point {
	public int x, y;
	public void move(int dx, int dy) {
		x += dx; y += dy;
	}
}
</pre></blockquote><a name="36865"></a>
and another compilation unit of another package:<p>
<blockquote><pre>package morePoints;
class Point3d extends points.Point {
	public int z;
	public void move(int dx, int dy, int dz) {
		super.move(dx, dy); z += dz;
	}
	public void move(int dx, int dy) {
		move(dx, dy, 0);
	}
}
public class OnePoint {
	public static points.Point getOne() { 
		return new Point3d(); 
	}
}
</pre></blockquote><a name="23527"></a>
An invocation <code>morePoints.OnePoint.getOne()</code> in yet a third package would return a <code>Point3d</code> that can be used as a <code>Point</code>, even though the type <code>Point3d</code> is not available outside the package <code>morePoints</code>. The two argument version of method <code>move</code> could then be invoked for that object, which is permissible because method <code>move</code> of <code>Point3d</code> is <code>public</code> (as it must be, for any method that overrides a <code>public</code> method must itself be <code>public</code>, precisely so that situations such as this will work out correctly). The fields <code>x</code> and <code>y</code> of that object could also be accessed from such a third package.<p>
<a name="36884"></a>
While the field <code>z</code> of class <code>Point3d</code> is <code>public</code>, it is not possible to access this field from code outside the package <code>morePoints</code>, given only a reference to an instance of class <code>Point3d</code> in a variable <code>p</code> of type <code>Point</code>. This is because the expression <code>p.z</code> is not correct, as <code>p</code> has type <code>Point</code> and class <code>Point</code> has no field named <code>z</code>; also, the expression <code>((Point3d)p).z</code> is not correct, because the class type <code>Point3d</code> cannot be referred to outside package <code>morePoints</code>. 
<a name="292218"></a>
<p>The declaration of the field <code>z</code> as <code>public</code> is not useless, however. If there were to be, in package <code>morePoints</code>, a <code>public</code> subclass <code>Point4d</code> of the class <code>Point3d</code>:
<blockquote><pre>package morePoints;
public class Point4d extends Point3d {
	public int w;
	public void move(int dx, int dy, int dz, int dw) {
		super.move(dx, dy, dz); w += dw;
	}
}
</pre></blockquote><a name="270996"></a>
then class <code>Point4d</code> would inherit the field <code>z</code>, which, being <code>public</code>, could then be accessed by code in packages other than <code>morePoints</code>, through variables and expressions of the <code>public</code> type <code>Point4d</code>.<p>
<a name="40898"></a>
<h2>8.3    Field Declarations</h2>
<a name="40823"></a>
The variables of a class type are introduced by <em>field declarations</em>:<p>
<ul><pre>
<em>FieldDeclaration:
	FieldModifiers<sub>opt</sub> Type VariableDeclarators ;

<em></em>VariableDeclarators:
	VariableDeclarator
	VariableDeclarators , VariableDeclarator

VariableDeclarator:
	VariableDeclaratorId
	VariableDeclaratorId = VariableInitializer

VariableDeclaratorId:
	Identifier
	VariableDeclaratorId [ ]

VariableInitializer:
	Expression
	ArrayInitializer
	</em>
</pre></ul><a name="78087"></a>
The <em>FieldModifiers</em> are described in <a href="classes.doc.html#78091">&#167;8.3.1</a>. The <em>Identifier</em> in a <em>FieldDeclarator</em> may be used in a name to refer to the field. Fields are members; the scope <a href="names.doc.html#103228">(&#167;6.3)</a> of a field declaration is specified in <a href="classes.doc.html#18988">&#167;8.1.5</a>. More than one field may be declared in a single field declaration by using more than one declarator; the <em>FieldModifiers</em> and <em>Type</em> apply to all the declarators in the declaration. Variable declarations involving array types are discussed in <a href="arrays.doc.html#25891">&#167;10.2</a>.<p>
<a name="29989"></a>
It is a compile-time error for the body of a class declaration to declare two fields with the same name. Methods, types, and fields may have the same name, since they are used in different contexts and are disambiguated by different lookup procedures <a href="names.doc.html#106941">(&#167;6.5)</a>.<p>
<a name="36999"></a>
If the class declares a field with a certain name, then the declaration of that field is said to <em>hide</em> any and all accessible declarations of fields with the same name in superclasses, and superinterfaces of the class. The field declaration also shadows <a href="names.doc.html#34133">(&#167;6.3.1)</a> declarations of any accessible fields in enclosing classes or interfaces, and any local variables, formal method parameters, and exception handler parameters with the same name in any enclosing blocks.<p>
<a name="38152"></a>
If a field declaration hides the declaration of another field, the two fields need not have the same type.<p>
<a name="38148"></a>
A class inherits from its direct superclass and direct superinterfaces all the non-private fields of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.<p>
<a name="247092"></a>
Note that a private field of a superclass might be accessible to a subclass (for example, if both classes are members of the same class). Nevertheless, a private field is never inherited by a subclass.
<a name="37087"></a>
<p>It is possible for a class to inherit more than one field with the same name <a href="classes.doc.html#40491">(&#167;8.3.3.3)</a>. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the class to refer to any such field by its simple name will result in a compile-time error, because such a reference is ambiguous.
<a name="37038"></a>
<p>There might be several paths by which the same field declaration might be inherited from an interface. In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.
<a name="37037"></a>
<p>A hidden field can be accessed by using a qualified name (if it is <code>static</code>) or by using a field access expression <a href="expressions.doc.html#41267">(&#167;15.11)</a> that contains the keyword <code>super</code> or a cast to a superclass type. See <a href="expressions.doc.html#20860">&#167;15.11.2</a> for discussion and an example.
<a name="259125"></a>
<p>A value stored in a field of type <code>float</code> is always an element of the float value set <a href="typesValues.doc.html#9208">(&#167;4.2.3)</a>; similarly, a value stored in a field of type <code>double</code> is always an element of the double value set. It is not permitted for a field of type <code>float</code> to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a field of type <code>double</code> to contain an element of the double-extended-exponent value set that is not also an element of the double value set.
<a name="78091"></a>
<h3>8.3.1    Field Modifiers</h3>
<ul><pre>
<em>FieldModifiers:
	FieldModifier
	FieldModifiers FieldModifier

FieldModifier: one of
</em>	public&#32;protected&#32;private
	static&#32;final&#32;transient&#32;volatile
</pre></ul><a name="35964"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="names.doc.html#104285">&#167;6.6</a>. A compile-time error occurs if the same modifier appears more than once in a field declaration, or if a field declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code>. <p>
<a name="259130"></a>
If two or more (distinct) field modifiers appear in a field declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>FieldModifier</em>.
<a name="37544"></a>
<h4>8.3.1.1    <code>static</code> Fields</h4>
<a name="230789"></a>
If a field is declared <code>static</code>, there exists exactly one incarnation of the field, no matter how many instances (possibly zero) of the class may eventually be created. A <code>static</code> field, sometimes called a <em>class variable</em>, is incarnated when the class is initialized <a href="execution.doc.html#44557">(&#167;12.4)</a>.<p>
<a name="230793"></a>
A field that is not declared <code>static</code> (sometimes called a non-<code>static</code> field) is called an <em>instance variable</em>. Whenever a new instance of a class is created, a new variable associated with that instance is created for every instance variable declared in that class or any of its superclasses. The example program:<p>
<blockquote><pre>class Point {
	int x, y, useCount;
	Point(int x, int y) { this.x = x; this.y = y; }
	final static Point origin = new Point(0, 0);
}
class Test {
	public static void main(String[] args) {
		Point p = new Point(1,1);
		Point q = new Point(2,2);
		p.x = 3; p.y = 3; p.useCount++; p.origin.useCount++;
		System.out.println("(" + q.x + "," + q.y + ")");
		System.out.println(q.useCount);
		System.out.println(q.origin == Point.origin);
		System.out.println(q.origin.useCount);
	}
}
</pre></blockquote><a name="37584"></a>
prints:<p>
<blockquote><pre>(2,2)
0
true
1
</pre></blockquote><a name="37588"></a>
showing that changing the fields <code>x</code>, <code>y</code>, and <code>useCount</code> of <code>p</code> does not affect the fields of <code>q</code>, because these fields are instance variables in distinct objects. In this example, the class variable <code>origin</code> of the class <code>Point</code> is referenced both using the class name as a qualifier, in <code>Point.origin</code>, and using variables of the class type in field access expressions <a href="expressions.doc.html#41267">(&#167;15.11)</a>, as in <code>p.origin</code> and <code>q.origin</code>. These two ways of accessing the <code>origin</code> class variable access the same object, evidenced by the fact that the value of the reference equality expression <a href="expressions.doc.html#236163">(&#167;15.21.3)</a>:<p>
<blockquote><pre><code>q.origin==Point.origin
</code></pre></blockquote><a name="227825"></a>
is <code>true</code>. Further evidence is that the incrementation:<p>
<blockquote><pre>p.origin.useCount++;
</pre></blockquote><a name="259135"></a>
causes the value of <code>q.origin.useCount</code> to be <code>1</code>; this is so because <code>p.origin</code> and <code>q.origin</code> refer to the same variable.<p>
<a name="35962"></a>
<h4>8.3.1.2    <code>final</code> Fields</h4>
<a name="246472"></a>
A field can be declared <code>final</code> <a href="typesValues.doc.html#10931">(&#167;4.5.4)</a>. Both class and instance variables (<code>static</code> and non-<code>static</code> fields) may be declared <code>final</code>.<p>
<a name="246476"></a>
It is a compile-time error if a blank final <a href="typesValues.doc.html#10931">(&#167;4.5.4)</a> class variable is not definitely assigned <a href="defAssign.doc.html#63310">(&#167;16.7)</a> by a static initializer <a href="classes.doc.html#39245">(&#167;8.7)</a> of the class in which it is declared.<p>
<a name="246496"></a>
A blank final instance variable must be definitely assigned <a href="defAssign.doc.html#56210">(&#167;16.8)</a> at the end of every constructor <a href="classes.doc.html#41652">(&#167;8.8)</a> of the class in which it is declared; otherwise a compile-time error occurs. <p>
<a name="78119"></a>
<h4>8.3.1.3    <code>transient</code> Fields</h4>
<a name="37020"></a>
Variables may be marked <code>transient</code> to indicate that they are not part of the persistent state of an object. <p>
<a name="258868"></a>
If an instance of the class <code>Point</code>:
<blockquote><pre>class Point {
	int x, y;
	transient float rho, theta;
}
</pre></blockquote><a name="259140"></a>
were saved to persistent storage by a system service, then only the fields <code>x</code> and <code>y</code> would be saved. This specification does not specify details of such services; see the specification of java.io.Serializable for an example of such a service.<p>
<a name="36930"></a>
<h4>8.3.1.4    <code>volatile</code> Fields</h4>
<a name="37715"></a>
As described in <a href="memory.doc.html#26250">&#167;17</a>, the Java programming language allows threads that access shared variables to keep private working copies of the variables; this allows a more efficient implementation of multiple threads. These working copies need be reconciled with the master copies in the shared main memory only at prescribed synchronization points, namely when objects are locked or unlocked. As a rule, to ensure that shared variables are consistently and reliably updated, a thread should ensure that it has exclusive use of such variables by obtaining a lock that, conventionally, enforces mutual exclusion for those shared variables.<p>
<a name="259149"></a>
The Java programming language provides a second mechanism, volatile fields, that is more convenient for some purposes.
<a name="259153"></a>
<p>
A field may be declared <code>volatile</code>, in which case a thread must reconcile its working copy of the field with the master copy every time it accesses the variable. Moreover, operations on the master copies of one or more volatile variables on behalf of a thread are performed by the main memory in exactly the order that the thread requested.<p>
<a name="14790"></a>
If, in the following example, one thread repeatedly calls the method <code>one</code> (but no more than <code>Integer.MAX_VALUE</code> times in all), and another thread repeatedly calls the method <code>two</code>:
<blockquote><pre>class Test {
	static int i = 0, j = 0;
	static void one() { i++; j++; }
	static void two() {
		System.out.println("i=" + i + " j=" + j);
	}
}
</pre></blockquote><a name="14803"></a>
then method <code>two</code> could occasionally print a value for <code>j</code> that is greater than the value of <code>i</code>, because the example includes no synchronization and, under the rules explained in <a href="memory.doc.html#26250">&#167;17</a>, the shared values of <code>i</code> and <code>j</code> might be updated out of order.<p>
<a name="37738"></a>
One way to prevent this out-or-order behavior would be to declare methods <code>one</code> and <code>two</code> to be <code>synchronized</code> <a href="classes.doc.html#260369">(&#167;8.4.3.6)</a>:
<blockquote><pre>class Test {
	static int i = 0, j = 0;
	static synchronized void one() { i++; j++; }
	static synchronized void two() {
		System.out.println("i=" + i + " j=" + j);
	}
}
</pre></blockquote><a name="37777"></a>
This prevents method <code>one</code> and method <code>two</code> from being executed concurrently, and furthermore guarantees that the shared values of <code>i</code> and <code>j</code> are both updated before method <code>one</code> returns. Therefore method <code>two</code> never observes a value for <code>j</code> greater than that for <code>i</code>; indeed, it always observes the same value for <code>i</code> and <code>j</code>.<p>
<a name="37789"></a>
Another approach would be to declare <code>i</code> and <code>j</code> to be <code>volatile</code>:
<blockquote><pre>class Test {
	static volatile int i = 0, j = 0;
	static void one() { i++; j++; }
	static void two() {
		System.out.println("i=" + i + " j=" + j);
	}
}
</pre></blockquote>
<a name="259157"></a>
This allows method <code>one</code> and method <code>two</code> to be executed concurrently, but guarantees that accesses to the shared values for <code>i</code> and <code>j</code> occur exactly as many times, and in exactly the same order, as they appear to occur during execution of the program text by each thread. Therefore, the shared value for <code>j</code> is never greater than that for <code>i</code>, because each update to <code>i</code> must be reflected in the shared value for <code>i</code> before the update to <code>j</code> occurs. It is possible, however, that any given invocation of method <code>two</code> might observe a value for <code>j</code> that is much greater than the value observed for <code>i</code>, because method <code>one</code> might be executed many times between the moment when method <code>two</code> fetches the value of <code>i</code> and the moment when method <code>two</code> fetches the value of <code>j</code>.
<a name="14791"></a>
See <a href="memory.doc.html#26250">&#167;17</a> for more discussion and examples.<p>
<a name="24509"></a>
A compile-time error occurs if a <code>final</code> variable is also declared <code>volatile</code>.<p>
<a name="24510"></a>
<h3>8.3.2    Initialization of Fields</h3>
<a name="41082"></a>
If a field declarator contains a <em>variable initializer</em>, then it has the semantics of an assignment <a href="expressions.doc.html#5281">(&#167;15.26)</a> to the declared variable, and:<p>
<ul><a name="37635"></a>
<li>If the declarator is for a class variable (that is, a <code>static</code> field), then the variable initializer is evaluated and the assignment performed exactly once, when the class is initialized <a href="execution.doc.html#44557">(&#167;12.4)</a>.
<a name="37639"></a>
<li>If the declarator is for an instance variable (that is, a field that is not <code>static</code>), then the variable initializer is evaluated and the assignment performed each time an instance of the class is created <a href="execution.doc.html#44670">(&#167;12.5)</a>. 
<a name="38002"></a>
The example:
</ul><blockquote><pre>class Point {
	int x = 1, y = 5;
}
class Test {
	public static void main(String[] args) {
		Point p = new Point();
		System.out.println(p.x + ", " + p.y);
	}
}
</pre></blockquote><a name="30363"></a>
produces the output:<p>
<blockquote><pre>1, 5
</pre></blockquote><a name="30378"></a>
because the assignments to <code>x</code> and <code>y</code> occur whenever a new <code>Point</code> is created.<p>
<a name="259166"></a>
Variable initializers are also used in local variable declaration statements <a href="statements.doc.html#5920">(&#167;14.4)</a>, where the initializer is evaluated and the assignment performed each time the local variable declaration statement is executed.<p>
<a name="38006"></a>
It is a compile-time error if the evaluation of a variable initializer for a <code>static</code> field or for an instance variable of a named class (or of an interface) can complete abruptly with a checked exception <a href="exceptions.doc.html#44121">(&#167;11.2)</a>.<p>
<a name="38010"></a>
<h4>8.3.2.1    Initializers for Class Variables</h4>
<a name="37971"></a>
If a reference by simple name to any instance variable occurs in an initialization expression for a class variable, then a compile-time error occurs.<p>
<a name="37934"></a>
If the keyword <code>this</code> <a href="expressions.doc.html#251519">(&#167;15.8.3)</a> or the keyword <code>super</code> (<a href="expressions.doc.html#20860">&#167;15.11.2</a>, <a href="expressions.doc.html#20448">&#167;15.12</a>) occurs in an initialization expression for a class variable, then a compile-time error occurs.<p>
<a name="259173"></a>
One subtlety here is that, at run time, <code>static</code> variables that are <code>final</code> and that are initialized with compile-time constant values are initialized first. This also applies to such fields in interfaces <a href="interfaces.doc.html#40720">(&#167;9.3.1)</a>. These variables are "constants" that will never be observed to have their default initial values <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a>, even by devious programs. See <a href="execution.doc.html#44630">&#167;12.4.2</a> and <a href="binaryComp.doc.html#45139">&#167;13.4.8</a> for more discussion.
<a name="294375"></a>
<em></em>Use of class variables whose declarations appear textually after the use is sometimes restricted, even though these class variables are in scope. See <a href="classes.doc.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to class variables.<p>
<a name="38013"></a>
<h4>8.3.2.2    Initializers for Instance Variables</h4>
<a name="37982"></a>
Initialization expressions for instance variables may use the simple name of any <code>static</code> variable declared in or inherited by the class, even one whose declaration occurs textually later. <p>
<a name="258899"></a>
Thus the example:
<blockquote><pre>class Test {
	float f = j;
	static int j = 1;
}
</pre></blockquote><a name="259183"></a>
compiles without error; it initializes <code>j</code> to <code>1</code> when class <code>Test</code> is initialized, and initializes <code>f</code> to the current value of <code>j</code> every time an instance of class <code>Test</code> is created.<p>
<a name="40409"></a>
Initialization expressions for instance variables are permitted to refer to the current object <code>this</code> <a href="expressions.doc.html#251519">(&#167;15.8.3)</a> and to use the keyword <code>super</code> (<a href="expressions.doc.html#20860">&#167;15.11.2</a>, <a href="expressions.doc.html#20448">&#167;15.12</a>).<p>
<a name="294509"></a>
<em></em>Use of instance variables whose declarations appear textually after the use is sometimes restricted, even though these instance variables are in scope. See <a href="classes.doc.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to instance variables.<p>
<a name="287406"></a>
<h4>8.3.2.3    Restrictions on the use of Fields during Initialization</h4>
<a name="287409"></a>
The declaration of a member needs to appear before it is used only if the member is an instance (respectively <code>static</code>) field of a class or interface <i>C</i> and all of the following conditions hold:<p>
<ul><a name="287410"></a>
<li>The usage occurs in an instance (respectively <code>static</code>) variable initializer of <i>C</i> or in an instance (respectively <code>static</code>) initializer of <i>C</i>.
<a name="287411"></a>
<li>The usage is not on the left hand side of an assignment.
<a name="287412"></a>
<li><i>C</i> is the innermost class or interface enclosing the usage.
</ul><a name="287413"></a>
A compile-time error occurs if any of the three requirements above are not met.<p>
<a name="287447"></a>
This means that a compile-time error results from the test program:
<blockquote><pre>	class Test {
		int i = j;	// compile-time error: incorrect forward reference
		int j = 1;
	}
</pre></blockquote><a name="287452"></a>
whereas the following example compiles without error:<p>
<blockquote><pre>	class Test {
		Test() { k = 2; }
		int j = 1;
		int i = j;
		int k;
	}
</pre></blockquote><a name="287462"></a>
even though the constructor <a href="classes.doc.html#41652">(&#167;8.8)</a> for <code>Test</code> refers to the field <code>k</code> that is declared three lines later. <p>
<a name="288775"></a>
These restrictions are designed to catch, at compile time, circular or otherwise malformed initializations. Thus, both:
<blockquote><pre>class Z {
	static int i = j + 2; 
	static int j = 4;
}
</pre></blockquote><a name="288780"></a>
and:<p>
<blockquote><pre>class Z {
	static { i = j + 2; }
	static int i, j;
	static { j = 4; }
}
</pre></blockquote><a name="288786"></a>
result in compile-time errors. Accesses by methods are not checked in this way, so:<p>
<blockquote><pre>class Z {
	static int peek() { return j; }
	static int i = peek();
	static int j = 1;
}
class Test {
	public static void main(String[] args) {
		System.out.println(Z.i);
	}
}
</pre></blockquote><a name="288795"></a>
produces the output:<p>
<blockquote><pre>0
</pre></blockquote><a name="288797"></a>
because the variable initializer for <code>i</code> uses the class method <code>peek</code> to access the value of the variable <code>j</code> before <code>j</code> has been initialized by its variable initializer, at which point it still has its default value <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a>.<p>
<a name="288772"></a>
A more elaborate example is:
<blockquote><pre>class UseBeforeDeclaration {
	static {
		x = 100; // ok - assignment
		int y = x + 1; // error - read before declaration
		int v = x = 3; // ok - x at left hand side of assignment
		int z = UseBeforeDeclaration.x * 2;
	// ok - not accessed via simple name
		Object o = new Object(){ 
			void foo(){x++;} // ok - occurs in a different class
			{x++;} // ok - occurs in a different class
    		};
  }
	{
		j = 200; // ok - assignment
		j = j + 1; // error - right hand side reads before declaration
		int k = j = j + 1; 
		int n = j = 300; // ok - j at left hand side of assignment
		int h = j++; // error - read before declaration
		int l = this.j * 3; // ok - not accessed via simple name
		Object o = new Object(){ 
			void foo(){j++;} // ok - occurs in a different class
			{ j = j + 1;} // ok - occurs in a different class
		};
	}
	int w = x= 3; // ok - x at left hand side of assignment
	int p = x; // ok - instance initializers may access static fields
	static int u = (new Object(){int bar(){return x;}}).bar();
	// ok - occurs in a different class
	static int x;
	int m = j = 4; // ok - j at left hand side of assignment
	int o = (new Object(){int bar(){return j;}}).bar(); 
	// ok - occurs in a different class
	int j;
}
</pre></blockquote><a name="40425"></a>
<h3>8.3.3    Examples of Field Declarations</h3>
<a name="259192"></a>
The following examples illustrate some (possibly subtle) points about field declarations.<p>
<a name="40428"></a>
<h4>8.3.3.1    Example: Hiding of Class Variables</h4>
<a name="40429"></a>
The example:<p>
<blockquote><pre>class Point {
	static int x = 2;
}
class Test extends Point {
	static double x = 4.7;
	public static void main(String[] args) {
		new Test().printX();
	}
	void printX() {
		System.out.println(x + " " + super.x);
	}
}
</pre></blockquote><a name="40439"></a>
produces the output:<p>
<blockquote><pre>4.7 2
</pre></blockquote><a name="40441"></a>
because the declaration of <code>x</code> in class <code>Test</code> hides the definition of <code>x</code> in class <code>Point</code>, so class <code>Test</code> does not inherit the field <code>x</code> from its superclass <code>Point</code>. Within the declaration of class <code>Test</code>, the simple name <code>x</code> refers to the field declared within class <code>Test</code>. Code in class <code>Test</code> may refer to the field <code>x</code> of class <code>Point</code> as <code>super.x</code> (or, because <code>x</code> is <code>static</code>, as <code>Point.x</code>). If the declaration of <code>Test.x</code> is deleted:<p>
<blockquote><pre>class Point {
	static int x = 2;
}
class Test extends Point {
	public static void main(String[] args) {
		new Test().printX();
	}
	void printX() {
		System.out.println(x + " " + super.x);
	}
}
</pre></blockquote><a name="40450"></a>
then the field <code>x</code> of class <code>Point</code> is no longer hidden within class <code>Test</code>; instead, the simple name <code>x</code> now refers to the field <code>Point.x</code>. Code in class <code>Test</code> may still refer to that same field as <code>super.x</code>. Therefore, the output from this variant program is:<p>
<blockquote><pre>2 2
</pre></blockquote><a name="229119"></a>
<h4>8.3.3.2    Example: Hiding of Instance Variables</h4>
<a name="40453"></a>
This example is similar to that in the previous section, but uses instance variables rather than static variables. The code:<p>
<blockquote><pre>class Point {
	int x = 2;
}
class Test extends Point {
	double x = 4.7;
	void printBoth() {
		System.out.println(x + " " + super.x);
	}
	public static void main(String[] args) {
		Test sample = new Test();
		sample.printBoth();
		System.out.println(sample.x + " " + 
								((Point)sample).x);
	}
}
</pre></blockquote><a name="40468"></a>
produces the output:<p>
<blockquote><pre>4.7 2
4.7 2
</pre></blockquote><a name="40471"></a>
because the declaration of <code>x</code> in class <code>Test</code> hides the definition of <code>x</code> in class <code>Point</code>, so class <code>Test</code> does not inherit the field <code>x</code> from its superclass <code>Point</code>. It must be noted, however, that while the field <code>x</code> of class <code>Point</code> is not <em>inherited</em> by class <code>Test</code>, it is nevertheless <em>implemented</em> by instances of class <code>Test</code>. In other words, every instance of class <code>Test</code> contains two fields, one of type <code>int</code> and one of type <code>float</code>. Both fields bear the name <code>x</code>, but within the declaration of class <code>Test</code>, the simple name <code>x</code> always refers to the field declared within class <code>Test</code>. Code in instance methods of class <code>Test</code> may refer to the instance variable <code>x</code> of class <code>Point</code> as <code>super.x</code>.<p>
<a name="40472"></a>
Code that uses a field access expression to access field <code>x</code> will access the field named <code>x</code> in the class indicated by the type of reference expression. Thus, the expression <code>sample.x</code> accesses a <code>float</code> value, the instance variable declared in class <code>Test</code>, because the type of the variable sample is <code>Test</code>, but the expression <code>((Point)sample).x</code> accesses an <code>int</code> value, the instance variable declared in class <code>Point</code>, because of the cast to type <code>Point</code>.
<a name="40473"></a>
<p>If the declaration of <code>x</code> is deleted from class <code>Test</code>, as in the program:
<blockquote><pre>class Point {
	static int x = 2;
}
class Test extends Point {
	void printBoth() {
		System.out.println(x + " " + super.x);
	}
	public static void main(String[] args) {
		Test sample = new Test();
		sample.printBoth();
		System.out.println(sample.x + " " +
												((Point)sample).x);
	}
}
</pre></blockquote><a name="40487"></a>
then the field <code>x</code> of class <code>Point</code> is no longer hidden within class <code>Test</code>. Within instance methods in the declaration of class <code>Test</code>, the simple name <code>x</code> now refers to the field declared within class <code>Point</code>. Code in class <code>Test</code> may still refer to that same field as <code>super.x</code>. The expression <code>sample.x</code> still refers to the field <code>x</code> within type <code>Test</code>, but that field is now an inherited field, and so refers to the field <code>x</code> declared in class <code>Point</code>. The output from this variant program is:<p>
<blockquote><pre>2 2
2 2
</pre></blockquote><a name="40491"></a>
<h4>8.3.3.3    Example: Multiply Inherited Fields</h4>
<a name="40492"></a>
A class may inherit two or more fields with the same name, either from two interfaces or from its superclass and an interface. A compile-time error occurs on any attempt to refer to any ambiguously inherited field by its simple name. A qualified name or a field access expression that contains the keyword <code>super</code> <a href="expressions.doc.html#20860">(&#167;15.11.2)</a> may be used to access such fields unambiguously. In the example:<p>
<blockquote><pre>interface Frob { float v = 2.0f; }
class SuperTest { int v = 3; }
class Test extends SuperTest implements Frob {
	public static void main(String[] args) {
		new Test().printV();
	}
	void printV() { System.out.println(v); }
}
</pre></blockquote><a name="40504"></a>
the class <code>Test</code> inherits two fields named <code>v</code>, one from its superclass <code>SuperTest</code> and one from its superinterface <code>Frob</code>. This in itself is permitted, but a compile-time error occurs because of the use of the simple name <code>v</code> in method <code>printV</code>: it cannot be determined which <code>v</code> is intended.<p>
<a name="41191"></a>
The following variation uses the field access expression <code>super.v</code> to refer to the field named <code>v</code> declared in class <code>SuperTest</code> and uses the qualified name <code>Frob.v</code> to refer to the field named <code>v</code> declared in interface <code>Frob</code>:
<blockquote><pre>interface Frob { float v = 2.0f; }
class SuperTest { int v = 3; }
class Test extends SuperTest implements Frob {
	public static void main(String[] args) {
		new Test().printV();
	}
	void printV() {
		System.out.println((super.v + Frob.v)/2);
	}
}
</pre></blockquote><a name="40515"></a>
It compiles and prints:<p>
<blockquote><pre>2.5
</pre></blockquote>
<a name="40518"></a>
Even if two distinct inherited fields have the same type, the same value, and are both <code>final</code>, any reference to either field by simple name is considered ambiguous and results in a compile-time error. In the example:
<blockquote><pre>
interface Color { int RED=0, GREEN=1, BLUE=2; }
interface TrafficLight { int RED=0, YELLOW=1, GREEN=2; }
class Test implements Color, TrafficLight {
	public static void main(String[] args) {
		System.out.println(GREEN);			// compile-time error
		System.out.println(RED);		// compile-time error
	}
}
</pre></blockquote><a name="40527"></a>
it is not astonishing that the reference to <code>GREEN</code> should be considered ambiguous, because class <code>Test</code> inherits two different declarations for <code>GREEN</code> with different values. The point of this example is that the reference to <code>RED</code> is also considered ambiguous, because two distinct declarations are inherited. The fact that the two fields named <code>RED</code> happen to have the same type and the same unchanging value does not affect this judgment.<p>
<a name="40528"></a>
<h4>8.3.3.4    Example: Re-inheritance of Fields</h4>
<a name="40529"></a>
If the same field declaration is inherited from an interface by multiple paths, the field is considered to be inherited only once. It may be referred to by its simple name without ambiguity. For example, in the code:<p>
<blockquote><pre>public interface Colorable {
	int RED = 0xff0000, GREEN = 0x00ff00, BLUE = 0x0000ff;
}
public interface Paintable extends Colorable {
	int MATTE = 0, GLOSSY = 1;
}
class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {
	. . .
}
class PaintedPoint extends ColoredPoint implements Paintable 
{
	. . .  &#32; &#32; &#32;<code>RED</code> &#32; &#32; &#32; . . .
}
</pre></blockquote><a name="259196"></a>
the fields <code>RED</code>, <code>GREEN</code>, and <code>BLUE</code> are inherited by the class <code>PaintedPoint</code> both through its direct superclass <code>ColoredPoint</code> and through its direct superinterface <code>Paintable</code>. The simple names <code>RED</code>, <code>GREEN</code>, and <code>BLUE</code> may nevertheless be used without ambiguity within the class <code>PaintedPoint</code> to refer to the fields declared in interface <code>Colorable</code>.<p>
<a name="40420"></a>
<h2>8.4    Method Declarations</h2>
<a name="40422"></a>
A <em>method</em> declares executable code that can be invoked, passing a fixed number of values as arguments.<p>
<ul><pre>
<em>MethodDeclaration:
	MethodHeader MethodBody

MethodHeader:
	MethodModifiers<sub>opt</sub> ResultType MethodDeclarator Throws<sub><i>opt
</i></sub>
ResultType:
	Type
</em>	void

<em>MethodDeclarator:
	Identifer ( FormalParameterList<sub><i>opt</i></sub> )
</em></pre></ul><a name="37508"></a>
The <em>MethodModifiers</em> are described in <a href="classes.doc.html#78188">&#167;8.4.3</a>, the <em>Throws</em> clause in <a href="classes.doc.html#78323">&#167;8.4.4</a>, and the <em>MethodBody</em> in <a href="classes.doc.html#37316">&#167;8.4.5</a>. A method declaration either specifies the type of value that the method returns or uses the keyword <code>void</code> to indicate that the method does not return a value.<p>
<a name="30386"></a>
The <em>Identifier</em> in a <em>MethodDeclarator</em> may be used in a name to refer to the method. A class can declare a method with the same name as the class or a field, member class or member interface of the class.<p>
<a name="38703"></a>
For compatibility with older versions of the Java platform, a declaration form for a method that returns an array is allowed to place (some or all of) the empty bracket pairs that form the declaration of the array type after the parameter list. This is supported by the obsolescent production:<p>
<ul><pre>
<em>MethodDeclarator:
	MethodDeclarator</em> [ ]
</pre></ul><a name="38705"></a>
but should not be used in new code.<p>
<a name="38056"></a>
It is a compile-time error for the body of a class to have as members two methods with the same signature <a href="classes.doc.html#38649">(&#167;8.4.2)</a> (name, number of parameters, and types of any parameters). Methods and fields may have the same name, since they are used in different contexts and are disambiguated by the different lookup procedures <a href="names.doc.html#106941">(&#167;6.5)</a>.<p>
<a name="38698"></a>
<h3>8.4.1    Formal Parameters</h3>
<a name="37472"></a>
The <em>formal parameters</em> of a method or constructor, if any, are specified by a list of comma-separated parameter specifiers. Each parameter specifier consists of a type (optionally preceded by the final modifier) and an identifier (optionally followed by brackets) that specifies the name of the parameter:<p>
<ul><pre>
<em>FormalParameterList:
	FormalParameter
	FormalParameterList , FormalParameter

FormalParameter:
</em>	final<em><sub>opt</sub> Type VariableDeclaratorId
</em></pre></ul><a name="291867"></a>
The following is repeated from <a href="classes.doc.html#40898">&#167;8.3</a> to make the presentation here clearer:<p>
<ul><pre>
<em>VariableDeclaratorId:
	Identifier
	VariableDeclaratorId</em> [ ]
</pre></ul><a name="55499"></a>
If a method or constructor has no parameters, only an empty pair of parentheses appears in the declaration of the method or constructor.<p>
<a name="246504"></a>
If two formal parameters of the same method or constructor are declared to have the same name (that is, their declarations mention the same <em>Identifier</em>), then a compile-time error occurs.<p>
<a name="246509"></a>
It is a compile-time error if a method or constructor parameter that is declared final is assigned to within the body of the method or constructor.<p>
<a name="37477"></a>
When the method or constructor is invoked <a href="expressions.doc.html#20448">(&#167;15.12)</a>, the values of the actual argument expressions initialize newly created parameter variables, each of the declared <em>Type,</em> before execution of the body of the method or constructor. The <em>Identifier</em> that appears<em> </em>in the <em>DeclaratorId</em> may be used as a simple name in the body of the method or constructor to refer to the formal parameter.<p>
<a name="294443"></a>
The scope of a parameter of a method <a href="classes.doc.html#38698">(&#167;8.4.1)</a> or constructor <a href="classes.doc.html#29488">(&#167;8.8.1)</a> is the entire body of the method or constructor.<p>
<a name="38643"></a>
These parameter names may not be redeclared as local variables of the method, or as exception parameters of catch clauses in a try statement of the method or constructor. However, a parameter of a method or constructor may be shadowed anywhere inside a class declaration nested within that method or constructor. Such a nested class declaration could declare either a local class <a href="statements.doc.html#247766">(&#167;14.3)</a> or an anonymous class <a href="expressions.doc.html#41147">(&#167;15.9)</a>. <p>
<a name="38647"></a>
Formal parameters are referred to only using simple names, never by using qualified names <a href="names.doc.html#104285">(&#167;6.6)</a>.<p>
<a name="246529"></a>
A method or constructor parameter of type <code>float</code> always contains an element of the float value set <a href="typesValues.doc.html#9208">(&#167;4.2.3)</a>; similarly, a method or constructor parameter of type <code>double</code> always contains an element of the double value set. It is not permitted for a method or constructor parameter of type <code>float</code> to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a method parameter of type <code>double</code> to contain an element of the double-extended-exponent value set that is not also an element of the double value set. <p>
<a name="246530"></a>
Where an actual argument expression corresponding to a parameter variable is not FP-strict <a href="expressions.doc.html#249198">(&#167;15.4)</a>, evaluation of that actual argument expression is permitted to use intermediate values drawn from the appropriate extended-exponent value sets. Prior to being stored in the parameter variable the result of such an expression is mapped to the nearest value in the corresponding standard value set by method invocation conversion <a href="conversions.doc.html#12687">(&#167;5.3)</a>.<p>
<a name="38649"></a>
<h3>8.4.2    Method Signature</h3>
<a name="37479"></a>
The <em>signature</em> of a method consists of the name of the method and the number and types of formal parameters to the method. A class may not declare two methods with the same signature, or a compile-time error occurs. <p>
<a name="258904"></a>
The example:
<blockquote><pre>class Point implements Move {
	int x, y;
	abstract void move(int dx, int dy);
	void move(int dx, int dy) { x += dx; y += dy; }
}
</pre></blockquote><a name="259201"></a>
causes a compile-time error because it declares two <code>move</code> methods with the same signature. This is an error even though one of the declarations is <code>abstract</code>.<p>
<a name="78188"></a>
<h3>8.4.3    Method Modifiers</h3>
<ul><pre>
<em>MethodModifiers:
	MethodModifier
	MethodModifiers MethodModifier

MethodModifier: one of
</em>	public&#32;protected&#32;private&#32;abstract&#32;static
	final&#32;synchronized&#32;native&#32;strictfp
</pre></ul><a name="244675"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="names.doc.html#104285">&#167;6.6</a>. A &#32;compile-time error occurs if the same modifier appears more than once in a method declaration, or if a method declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code>. A compile-time error occurs if a method declaration that contains the keyword <code>abstract</code> also contains any one of the keywords <code>private</code>, <code>static</code>, <code>final</code>, <code>native</code>, <code>strictfp</code>, or <code>synchronized</code>. A compile-time error occurs if a method declaration that contains the keyword <code>native</code> also contains <code>strictfp</code>.<p>
<a name="259206"></a>
If two or more method modifiers appear in a method declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>MethodModifier</em>.
<a name="34484"></a>
<h4>8.4.3.1    <code>abstract</code> Methods</h4>
<a name="227750"></a>
An <code>abstract</code> method declaration introduces the method as a member, providing its signature (name and number and type of parameters), return type, and <code>throws</code> clause (if any), but does not provide an implementation. The declaration of an <code>abstract</code> method <i>m</i> must appear directly within an <code>abstract</code> class (call it <i>A</i>); otherwise a compile-time error results. Every subclass of <i>A</i> that is not <code>abstract</code> must provide an implementation for <i>m</i>, or a compile-time error occurs as specified in <a href="classes.doc.html#34944">&#167;8.1.1.1</a>. <p>
<a name="230064"></a>
It is a compile-time error for a <code>private</code> method to be declared <code>abstract</code>.<p>
<a name="259211"></a>
It would be impossible for a subclass to implement a <code>private</code> <code>abstract</code> method, because <code>private</code> methods are not inherited by subclasses; therefore such a method could never be used.
<a name="230065"></a>
<p>
It is a compile-time error for a <code>static</code> method to be declared <code>abstract</code>.<p>
<a name="230073"></a>
It is a compile-time error for a <code>final</code> method to be declared <code>abstract</code>.<p>
<a name="36710"></a>
An <code>abstract</code> class can override an <code>abstract</code> method by providing another <code>abstract</code> method declaration. <p>
<a name="258918"></a>
This can provide a place to put a documentation comment, or to declare that the set of checked exceptions <a href="exceptions.doc.html#44121">(&#167;11.2)</a> that can be thrown by that method, when it is implemented by its subclasses, is to be more limited. For example, consider this code:
<blockquote><pre>class BufferEmpty extends Exception {
	BufferEmpty() { super(); }
	BufferEmpty(String s) { super(s); }
}
class BufferError extends Exception {
	BufferError() { super(); }
	BufferError(String s) { super(s); }
}
public interface Buffer {
	char get() throws BufferEmpty, BufferError;
}
public abstract class InfiniteBuffer implements Buffer {
	abstract char get() throws BufferError;
}
</pre></blockquote>
<a name="259216"></a>
The overriding declaration of method <code>get</code> in class <code>InfiniteBuffer</code> states that method <code>get</code> in any subclass of <code>InfiniteBuffer</code> never throws a <code>BufferEmpty</code> exception, putatively because it generates the data in the buffer, and thus can never run out of data.
<a name="14765"></a>
An instance method that is not <code>abstract</code> can be overridden by an <code>abstract</code> method. <p>
<a name="258923"></a>
For example, we can declare an <code>abstract</code> class <code>Point</code> that requires its subclasses to implement <code>toString</code> if they are to be complete, instantiable classes:
<blockquote><pre>abstract class Point {
	int x, y;
	public abstract String toString();
}
</pre></blockquote><a name="14912"></a>
This <code>abstract</code> declaration of <code>toString</code> overrides the non-<code>abstract</code> <code>toString</code> method of class <code>Object</code>. (Class <code>Object</code> is the implicit direct superclass of class <code>Point</code>.) Adding the code:<p>
<blockquote><pre>class ColoredPoint extends Point {
	int color;
	public String toString() {
		return super.toString() + ": color " + color; // error
	}
}
</pre></blockquote><a name="38923"></a>
results in a compile-time error because the invocation <code>super.toString()</code> refers to method <code>toString</code> in class <code>Point</code>, which is <code>abstract</code> and therefore cannot be invoked. Method <code>toString</code> of class <code>Object</code> can be made available to class <code>ColoredPoint</code> &#32;only if class <code>Point</code> explicitly makes it available through some other method, as in:<p>
<blockquote><pre>abstract class Point {
	int x, y;
	public abstract String toString();
	protected String objString() { return super.toString(); }
}
class ColoredPoint extends Point {
	int color;
	public String toString() {
		return objString() + ": color " + color;	// correct
	}
}
</pre></blockquote><a name="229128"></a>
<h4>8.4.3.2    <code>static</code> Methods</h4>
<a name="39431"></a>
A method that is declared <code>static</code> is called a <em>class method</em>. A class method is always invoked without reference to a particular object. An attempt to reference the current object using the keyword <code>this</code> or the keyword <code>super</code> in the body of a class method results in a compile-time error. It is a compile-time error for a <code>static</code> method to be declared <code>abstract</code>.<p>
<a name="39033"></a>
A method that is not declared <code>static</code> is called an <em>instance method,</em> and sometimes called a non-<code>static</code> method. An instance method is always invoked with respect to an object, which becomes the current object to which the keywords <code>this</code> and <code>super</code> refer during execution of the method body.<p>
<a name="11246"></a>
<h4>8.4.3.3    <code>final</code> Methods</h4>
<a name="30456"></a>
A method can be declared <code>final</code> to prevent subclasses from overriding or hiding it. It is a compile-time error to attempt to override or hide a <code>final</code> method.<p>
<a name="38958"></a>
A <code>private</code> method and all methods declared in a <code>final</code> class <a href="classes.doc.html#54727">(&#167;8.1.1.2)</a> are implicitly <code>final</code>, because it is impossible to override them. It is permitted but not required for the declarations of such methods to redundantly include the <code>final</code> keyword. <p>
<a name="38950"></a>
It is a compile-time error for a <code>final</code> method to be declared <code>abstract</code>.<p>
<a name="14844"></a>
At run time, a machine-code generator or optimizer can "inline" the body of a <code>final</code> method, replacing an invocation of the method with the code in its body. The inlining process must preserve the semantics of the method invocation. In particular, if the target of an instance method invocation is <code>null</code>, then a <code>NullPointerException</code> must be thrown even if the method is inlined. The compiler must ensure that the exception will be thrown at the correct point, so that the actual arguments to the method will be seen to have been evaluated in the correct order prior to the method invocation.<p>
<a name="258931"></a>
Consider the example:
<blockquote><pre>final class Point {
	int x, y;
	void move(int dx, int dy) { x += dx; y += dy; }
}
class Test {
	public static void main(String[] args) {
		Point[] p = new Point[100];
		for (int i = 0; i &lt; p.length; i++) {
			p[i] = new Point();
			p[i].move(i, p.length-1-i);
		}
	}
}
</pre></blockquote><a name="36666"></a>
Here, inlining the method <code>move</code> of class <code>Point</code> in method <code>main</code> would transform the <code>for</code> loop to the form:<p>
<blockquote><pre>		for (int i = 0; i &lt; p.length; i++) {
			p[i] = new Point();
			Point pi = p[i];
			int j = p.length-1-i;
			pi.x += i;
			pi.y += j;
		}
</pre></blockquote><a name="31122"></a>
The loop might then be subject to further optimizations.<p>
<a name="259226"></a>
Such inlining cannot be done at compile time unless it can be guaranteed that <code>Test</code> and <code>Point</code> will always be recompiled together, so that whenever <code>Point</code>-and specifically its <code>move</code> method-changes, the code for <code>Test.main</code> will also be updated.
<a name="31125"></a>
<h4>8.4.3.4    <code>native</code> Methods</h4>
<a name="30468"></a>
A method that is <code>native</code> is implemented in platform-dependent code, typically written in another programming language such as C, C++, FORTRAN, or assembly language. The body of a <code>native</code> method is given as a semicolon only, indicating that the implementation is omitted, instead of a block.<p>
<a name="38981"></a>
A compile-time error occurs if a <code>native</code> method is declared <code>abstract</code>.<p>
<a name="38035"></a>
For example, the class <code>RandomAccessFile</code> of the package <code>java.io</code> might declare the following <code>native</code> methods:
<blockquote><pre>package java.io;
public class RandomAccessFile
	implements DataOutput, DataInput
{	. . .
	public native void open(String name, boolean writeable)
		throws IOException;
	public native int readBytes(byte[] b, int off, int len)
		throws IOException;
	public native void writeBytes(byte[] b, int off, int len)
		throws IOException;
	public native long getFilePointer() throws IOException;
	public native void seek(long pos) throws IOException;
	public native long length() throws IOException;
	public native void close() throws IOException;
}
</pre></blockquote><a name="55408"></a>
<h4>8.4.3.5    <code>strictfp </code>Methods</h4>
<a name="260393"></a>
The effect of the <code>strictfp</code> modifier is to make all <code>float</code> or <code>double </code>expressions within the method body be explicitly FP-strict <a href="expressions.doc.html#249198">(&#167;15.4)</a>.<p>
<a name="260369"></a>
<h4>8.4.3.6    <code>synchronized</code> Methods</h4>
<a name="30531"></a>
A <code>synchronized</code> method acquires a lock <a href="memory.doc.html#28287">(&#167;17.1)</a> before it executes. For a class (<code>static)</code> method, the lock associated with the <code>Class</code> object for the method's class is used. For an instance method, the lock associated with <code>this</code> (the object for which the method was invoked) is used. <p>
<a name="258940"></a>
These are the same locks that can be used by the <code>synchronized</code> statement <a href="statements.doc.html#255769">(&#167;14.18)</a>; thus, the code:
<blockquote><pre>class Test {
	int count;
	synchronized void bump() { count++; }
	static int classCount;
	static synchronized void classBump() {
		classCount++;
	}
}
</pre></blockquote><a name="39096"></a>
has exactly the same effect as:<p>
<blockquote><pre>class BumpTest {
	int count;
	void bump() {
		synchronized (this) {
			count++;
		}
	}
	static int classCount;
	static void classBump() {
		try {
			synchronized (Class.forName("BumpTest")) {
				classCount++;
			}
		} catch (ClassNotFoundException e) {
				...
		}
	}
}
</pre></blockquote><a name="39078"></a>
The more elaborate example:<p>
<blockquote><pre>public class Box {
	private Object boxContents;
	public synchronized Object get() {
		Object contents = boxContents;
		boxContents = null;
		return contents;
	}
	public synchronized boolean put(Object contents) {
		if (boxContents != null)
			return false;
		boxContents = contents;
		return true;
	}
}
</pre></blockquote><a name="30546"></a>
defines a class which is designed for concurrent use. Each instance of the class <code>Box</code> has an instance variable <code>contents</code> that can hold a reference to any object. You can put an object in a <code>Box</code> by invoking <code>put</code>, which returns <code>false</code> if the box is already full. You can get something out of a <code>Box</code> by invoking <code>get</code>, which returns a null reference if the <code>box</code> is empty.<p>
<a name="39151"></a>
If <code>put</code> and <code>get</code> were not <code>synchronized</code>, and two threads were executing methods for the same instance of <code>Box</code> at the same time, then the code could misbehave. It might, for example, lose track of an object because two invocations to <code>put</code> occurred at the same time.
<p>
<a name="259236"></a>
See <a href="memory.doc.html#26250">&#167;17</a> for more discussion of threads and locks.
<a name="78323"></a>
<h3>8.4.4    Method Throws</h3>
<a name="41401"></a>
A <em>throws clause</em> is used to declare any checked exceptions <a href="exceptions.doc.html#44121">(&#167;11.2)</a> that can result from the execution of a method or constructor:<p>
<ul><pre>
<em>Throws:
</em>	throws<em> ClassTypeList

ClassTypeList:
	ClassType
	ClassTypeList , ClassType
</em></pre></ul><a name="39173"></a>
A compile-time error occurs if any <em>ClassType</em> mentioned in a <code>throws</code> clause is not the class <code>Throwable</code> or a subclass of <code>Throwable</code>. It is permitted but not required to mention other (unchecked) exceptions in a <code>throws</code> clause.<p>
<a name="39177"></a>
For each checked exception that can result from execution of the body of a method or constructor, a compile-time error occurs unless that exception type or a superclass of that exception type is mentioned in a <code>throws</code> clause in the declaration of the method or constructor.<p>
<a name="259241"></a>
The requirement to declare checked exceptions allows the compiler to ensure that code for handling such error conditions has been included. Methods or constructors that fail to handle exceptional conditions thrown as checked exceptions will normally result in a compile-time error because of the lack of a proper exception type in a <code>throws</code> clause. The Java programming language thus encourages a programming style where rare and otherwise truly exceptional conditions are documented in this way.
<a name="55271"></a>
<p>
The predefined exceptions that are not checked in this way are those for which declaring every possible occurrence would be unimaginably inconvenient:<p>
<ul><a name="41434"></a>
<li>Exceptions that are represented by the subclasses of class <code>Error</code>, for example <code>OutOfMemoryError</code>, are thrown due to a failure in or of the virtual machine. Many of these are the result of linkage failures and can occur at unpredictable points in the execution of a program. Sophisticated programs may yet wish to catch and attempt to recover from some of these conditions.
<a name="41435"></a>
<li>The exceptions that are represented by the subclasses of the class <code>RuntimeException</code>, &#32;for example <code>NullPointerException</code>, result from run-time &#32;integrity checks and are thrown either directly from the program or in library routines. It is beyond the scope of the Java programming language, and perhaps beyond the state of the art, to include sufficient information in the program to reduce to a manageable number the places where these can be proven not to occur.
</ul><a name="230101"></a>
A method that overrides or hides another method <a href="classes.doc.html#228745">(&#167;8.4.6)</a>, including methods that implement <code>abstract</code> methods defined in interfaces, may not be declared to throw more checked exceptions than the overridden or hidden method.<p>
<a name="230102"></a>
More precisely, suppose that <i>B</i> is a class or interface, and <i>A</i> is a superclass or superinterface of <i>B</i>, and a method declaration <i>n</i> in <i>B</i> overrides or hides a method declaration <i>m</i> in <i>A</i>. If <i>n</i> has a <code>throws</code> clause that mentions any checked exception types, then <i>m</i> must have a <code>throws</code> clause, and for every checked exception type listed in the <code>throws</code> clause of <i>n</i>, that same exception class or one of its superclasses must occur in the <code>throws</code> clause of <i>m</i>; otherwise, a compile-time error occurs.<p>
<a name="24563"></a>
See <a href="exceptions.doc.html#44043">&#167;11</a> for more information about exceptions and a large example.<p>
<a name="37316"></a>
<h3>8.4.5    Method Body</h3>
<a name="32175"></a>
A <em>method body</em> is either a block of code that implements the method or simply a semicolon, indicating the lack of an implementation. The body of a method must be a semicolon if and only if the method is either <code>abstract</code> <a href="classes.doc.html#34484">(&#167;8.4.3.1)</a> or <code>native</code> <a href="classes.doc.html#31125">(&#167;8.4.3.4)</a>.<p>
<ul><pre>
<em>MethodBody</em>:
<em>	Block</em> 
	;
</pre></ul><a name="38770"></a>
A compile-time error occurs if a method declaration is either <code>abstract</code> or <code>native</code> and has a block for its body. A compile-time error occurs if a method declaration is neither <code>abstract</code> nor <code>native</code> and has a semicolon for its body.<p>
<a name="39311"></a>
If an implementation is to be provided for a method but the implementation requires no executable code, the method body should be written as a block that contains no statements: "<code>{ }</code>".
<a name="228178"></a>
<p>
If a method is declared <code>void</code>, then its body must not contain any <code>return</code> statement <a href="statements.doc.html#6767">(&#167;14.16)</a> that has an <em>Expression</em>.<p>
<a name="244552"></a>
If a method is declared to have a return type, then every <code>return</code> statement <a href="statements.doc.html#6767">(&#167;14.16)</a> in its body must have an <em>Expression</em>. A compile-time error occurs if the body of the method can complete normally <a href="statements.doc.html#5894">(&#167;14.1)</a>. <p>
<a name="258957"></a>
In other words, a method with a return type must return only by using a return statement that provides a value return; it is not allowed to "drop off the end of its body."
<p>
<a name="228370"></a>
Note that it is possible for a method to have a declared return type and yet contain no return statements. Here is one example:
<blockquote><pre>class DizzyDean {
	int pitch() { throw new RuntimeException("90 mph?!"); }
}
</pre></blockquote><a name="228745"></a>
<h3>8.4.6    Inheritance, Overriding, and Hiding</h3>
<a name="227926"></a>
A class <em>inherits</em> from its direct superclass and direct superinterfaces all the non-private methods (whether <code>abstract</code> or not) of the superclass and superinterfaces that are accessible to code in the class and are neither overridden <a href="classes.doc.html#227927">(&#167;8.4.6.1)</a> nor hidden <a href="classes.doc.html#227928">(&#167;8.4.6.2)</a> by a declaration in the class.<p>
<a name="227927"></a>
<h4>8.4.6.1    Overriding (by Instance Methods)</h4>
<a name="39521"></a>
An instance method <i>m1</i> declared in a class <i>C</i> <em>overrides</em> another method with the same signature, <i>m2</i>, declared in class <i>A</i> if both
<ol>
<a name="247097"></a>
<li>C is a subclass of <i>A</i>.
<a name="247099"></a>
<li>Either
<ul>
<a name="247100"></a>
<li><i>m</i>2 is non-private and accessible from <i>C</i>, or
<a name="247101"></a>
<li><i>m1</i> overrides a method <i>m3</i>, <i>m3</i> distinct from <i>m1</i>, <i>m3</i> distinct from <i>m2</i>, such that <i>m3</i> overrides <i>m2</i>.
</ul>
</ol>
<a name="247108"></a>
Moreover, if <i>m1</i> is not <code>abstract</code>, then <i>m1</i> is said to <em>implement</em> any and all declarations of <code>abstract</code> methods that it overrides.<p>
<a name="227929"></a>
A compile-time error occurs if an instance method overrides a <code>static</code> method. <p>
<a name="258962"></a>
In this respect, overriding of methods differs from hiding of fields <a href="classes.doc.html#40898">(&#167;8.3)</a>, for it is permissible for an instance variable to hide a <code>static</code> variable.
<a name="259251"></a>
<p>
An overridden method can be accessed by using a method invocation expression <a href="expressions.doc.html#20448">(&#167;15.12)</a> that contains the keyword <code>super</code>. Note that a qualified name or a cast to a superclass type is not effective in attempting to access an overridden method; in this respect, overriding of methods differs from hiding of fields. See <a href="expressions.doc.html#239751">&#167;15.12.4.9</a> for discussion and examples of this point.
<a name="246534"></a>
<p>
The presence or absence of the <code>strictfp</code> modifier has absolutely no effect on the rules for overriding methods and implementing abstract methods. For example, it is permitted for a method that is not FP-strict to override an FP-strict method and it is permitted for an FP-strict method to override a method that is not FP-strict.<p>
<a name="227928"></a>
<h4>8.4.6.2    Hiding (by Class Methods)</h4>
<a name="227961"></a>
If a class declares a <code>static</code> method, then the declaration of that method is said to <em>hide</em> any and all methods with the same signature in the superclasses and superinterfaces of the class that would otherwise be accessible to code in the class. A compile-time error occurs if a <code>static</code> method hides an instance method. <p>
<a name="258967"></a>
In this respect, hiding of methods differs from hiding of fields <a href="classes.doc.html#40898">(&#167;8.3)</a>, for it is permissible for a <code>static</code> variable to hide an instance variable. Hiding is also distinct from shadowing <a href="names.doc.html#34133">(&#167;6.3.1)</a> and obscuring <a href="names.doc.html#104058">(&#167;6.3.2)</a>.
<a name="259256"></a>
<p>
A hidden method can be accessed by using a qualified name or by using a method invocation expression <a href="expressions.doc.html#20448">(&#167;15.12)</a> that contains the keyword <code>super</code> or a cast to a superclass type. In this respect, hiding of methods is similar to hiding of fields.
<a name="227965"></a>
<h4>8.4.6.3    Requirements in Overriding and Hiding</h4>
<a name="227966"></a>
If a method declaration overrides or hides the declaration of another method, then a compile-time error occurs if they have different return types or if one has a return type and the other is <code>void</code>. Moreover, a method declaration must not have a <code>throws</code> clause that conflicts <a href="classes.doc.html#78323">(&#167;8.4.4)</a> with that of any method that it overrides or hides; otherwise, &#32;a compile-time error occurs. <p>
<a name="259261"></a>
In these respects, overriding of methods differs from hiding of fields <a href="classes.doc.html#40898">(&#167;8.3)</a>, for it is permissible for a field to hide a field of another type.
<a name="39548"></a>
<p>
The access modifier <a href="names.doc.html#104285">(&#167;6.6)</a> of an overriding or hiding method must provide at least as much access as the overridden or hidden method, or a compile-time error occurs. In more detail:<p>
<ul><a name="39549"></a>
<li>If the overridden or hidden method is <code>public</code>, then the overriding or hiding method must be <code>public</code>; otherwise, a compile-time error occurs.
<a name="39550"></a>
<li>If the overridden or hidden method is <code>protected</code>, then the overriding or hiding method must be <code>protected</code> or <code>public</code>; otherwise, a compile-time error occurs.
<a name="39551"></a>
<li>If the overridden or hidden method has default (package) access, then the overriding or hiding method must not be <code>private</code>; otherwise, a compile-time error occurs.
<a name="259266"></a>
</ul>
Note that a <code>private</code> method cannot be hidden or overridden in the technical sense of those terms. This means that a subclass can declare a method with the same signature as a <code>private</code> method in one of its superclasses, and there is no requirement that the return type or <code>throws</code> clause of such a method bear any relationship to those of the <code>private</code> method in the superclass.
<a name="227941"></a>
<h4>8.4.6.4    Inheriting Methods with the Same Signature</h4>
<a name="39557"></a>
It is possible for a class to inherit more than one method with the same signature. Such a situation does not in itself cause a compile-time error. There are then two possible cases:<p>
<ul><a name="39561"></a>
<li>If one of the inherited methods is not <code>abstract</code>, then there are two subcases:
<ul>
<a name="39562"></a>
<li>If the method that is not <code>abstract</code> is <code>static</code>, a compile-time error occurs.
<a name="39563"></a>
<li>Otherwise, the method that is not <code>abstract</code> is considered to override, and therefore to implement, all the other methods on behalf of the class that inherits it. A compile-time error occurs if, comparing the method that is not <code>abstract</code> with each of the other of the inherited methods, for any such pair, either they have different return types or one has a return type and the other is <code>void</code>. Moreover, a compile-time error occurs if the inherited method that is not <code>abstract</code> has a <code>throws</code> clause that conflicts <a href="classes.doc.html#78323">(&#167;8.4.4)</a> with that of any other of the inherited methods.
</ul>
<a name="39567"></a>
<li>If all the inherited methods are <code>abstract</code>, then the class is necessarily an <code>abstract</code> class and is considered to inherit all the <code>abstract</code> methods. A compile-time error occurs if, for any two such inherited methods, either they have different return types or one has a return type and the other is <code>void</code>.  (The <code>throws</code> clauses do not cause errors in this case.)
</ul><a name="39568"></a>
It is not possible for two or more inherited methods with the same signature not to be <code>abstract</code>, because methods that are not <code>abstract</code> are inherited only from the direct superclass, not from superinterfaces.<p>
<a name="39569"></a>
There might be several paths by which the same method declaration might be inherited from an interface. This fact causes no difficulty and never, of itself, results in a compile-time error.<p>
<a name="227768"></a>
<h3>8.4.7    Overloading</h3>
<a name="39587"></a>
If two methods of a class (whether both declared in the same class, or both inherited by a class, or one declared and one inherited) have the same name but different signatures, then the method name is said to be <em>overloaded</em>. This fact causes no difficulty and never of itself results in a compile-time error. There is no required relationship between the return types or between the <code>throws</code> clauses of two methods with the same name but different signatures.<p>
<a name="39909"></a>
Methods are overridden on a signature-by-signature basis. <p>
<a name="258985"></a>
If, for example, a class declares two <code>public</code> methods with the same name, and a subclass overrides one of them, the subclass still inherits the other method. In this respect, the Java programming language differs from C++.
<a name="39591"></a>
<p>
When a method is invoked <a href="expressions.doc.html#20448">(&#167;15.12)</a>, the number of actual arguments and the compile-time types of the arguments are used, at compile time, to determine the signature of the method that will be invoked <a href="expressions.doc.html#289905">(&#167;15.12.2)</a>. If the method that is to be invoked is an instance method, the actual method to be invoked will be determined at run time, using dynamic method lookup <a href="expressions.doc.html#45677">(&#167;15.12.4)</a>.
<a name="39598"></a>
<h3>8.4.8    Examples of Method Declarations</h3>
<a name="39599"></a>
The following examples illustrate some (possibly subtle) points about method declarations.<p>
<a name="39600"></a>
<h4>8.4.8.1    Example: Overriding</h4>
<a name="39601"></a>
In the example:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0;
	void move(int dx, int dy) { x += dx; y += dy; }
}
class SlowPoint extends Point {
	int xLimit, yLimit;
	void move(int dx, int dy) {
		super.move(limit(dx, xLimit), limit(dy, yLimit));
	}
	static int limit(int d, int limit) {
		return d &gt; limit ? limit : d &lt; -limit ? -limit : d;
	}
}
</pre></blockquote><a name="39615"></a>
the class <code>SlowPoint</code> overrides the declarations of method <code>move</code> of class <code>Point</code> with its own <code>move</code> method, which limits the distance that the point can move on each invocation of the method. When the <code>move</code> method is invoked for an instance of class <code>SlowPoint</code>, the overriding definition in class <code>SlowPoint</code> will always be called, even if the reference to the <code>SlowPoint</code> object is taken from a variable whose type is <code>Point</code>.<p>
<a name="39617"></a>
<h4>8.4.8.2    Example: Overloading, Overriding, and Hiding</h4>
<a name="39618"></a>
In the example:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0;
	void move(int dx, int dy) { x += dx; y += dy; }
	int color;
}
class RealPoint extends Point {
	float x = 0.0f, y = 0.0f;
	void move(int dx, int dy) { move((float)dx, (float)dy); }
	void move(float dx, float dy) { x += dx; y += dy; }
}
</pre></blockquote><a name="39629"></a>
the class <code>RealPoint</code> hides the declarations of the <code>int</code> instance variables <code>x</code> and <code>y</code> of class <code>Point</code> with its own <code>float</code> instance variables <code>x</code> and <code>y</code>, and overrides the method <code>move</code> of class <code>Point</code> with its own <code>move</code> method. It also overloads the name <code>move</code> with another method with a different signature <a href="classes.doc.html#38649">(&#167;8.4.2)</a>.<p>
<a name="39633"></a>
In this example, the members of the class <code>RealPoint</code> include the instance variable <code>color</code> inherited from the class <code>Point</code>, the <code>float</code> instance variables <code>x</code> and <code>y</code> declared in <code>RealPoint</code>, and the two <code>move</code> methods declared in <code>RealPoint</code>.
<a name="39634"></a>
<p>
Which of these overloaded <code>move</code> methods of class <code>RealPoint</code> will be chosen for any particular method invocation will be determined at compile time by the overloading resolution procedure described in <a href="expressions.doc.html#20448">&#167;15.12</a>.
<a name="39638"></a>
<h4>8.4.8.3    Example: Incorrect Overriding</h4>
<a name="39639"></a>
This example is an extended variation of that in the preceding section:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0, color;
	void move(int dx, int dy) { x += dx; y += dy; }
	int getX() { return x; }
	int getY() { return y; }
}
class RealPoint extends Point {
	float x = 0.0f, y = 0.0f;
	void move(int dx, int dy) { move((float)dx, (float)dy); }
	void move(float dx, float dy) { x += dx; y += dy; }
	float getX() { return x; }
	float getY() { return y; }
}
</pre></blockquote><a name="39654"></a>
Here the class <code>Point</code> provides methods <code>getX</code> and <code>getY</code> that return the values of its fields <code>x</code> and <code>y</code>; the class <code>RealPoint</code> then overrides these methods by declaring methods with the same signature. The result is two errors at compile time, one for each method, because the return types do not match; the methods in class <code>Point</code> return values of type <code>int</code>, but the wanna-be overriding methods in class <code>RealPoint</code> return values of type <code>float</code>.<p>
<a name="39655"></a>
<h4>8.4.8.4    Example: Overriding versus Hiding</h4>
<a name="39656"></a>
This example corrects the errors of the example in the preceding section:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0;
	void move(int dx, int dy) { x += dx; y += dy; }
	int getX() { return x; }
	int getY() { return y; }
	int color;
}
class RealPoint extends Point {
	float x = 0.0f, y = 0.0f;
	void move(int dx, int dy) { move((float)dx, (float)dy); }
	void move(float dx, float dy) { x += dx; y += dy; }
	int getX() { return (int)Math.floor(x); }
	int getY() { return (int)Math.floor(y); }
}
</pre></blockquote><a name="39671"></a>
Here the overriding methods <code>getX</code> and <code>getY</code> in class <code>RealPoint</code> have the same return types as the methods of class <code>Point</code> that they override, so this code can be successfully compiled.<p>
<a name="39672"></a>
Consider, then, this test program:
<blockquote><pre>class Test {
	public static void main(String[] args) {
		RealPoint rp = new RealPoint();
		Point p = rp;
		rp.move(1.71828f, 4.14159f);
		p.move(1, -1);
		show(p.x, p.y);
		show(rp.x, rp.y);
		show(p.getX(), p.getY());
		show(rp.getX(), rp.getY());
	}
	static void show(int x, int y) {
		System.out.println("(" + x + ", " + y + ")");
	}
	static void show(float x, float y) {
		System.out.println("(" + x + ", " + y + ")");
	}
}
</pre></blockquote><a name="39691"></a>
The output from this program is:<p>
<blockquote><pre>(0, 0)
(2.7182798, 3.14159)
(2, 3)
(2, 3)
</pre></blockquote>
<a name="39696"></a>
The first line of output illustrates the fact that an instance of <code>RealPoint</code> actually contains the two integer fields declared in class <code>Point</code>; it is just that their names are hidden from code that occurs within the declaration of class <code>RealPoint</code> (and those of any subclasses it might have). When a reference to an instance of class <code>RealPoint</code> in a variable of type <code>Point</code> is used to access the field <code>x</code>, the integer field <code>x</code> declared in class <code>Point</code> is accessed. The fact that its value is zero indicates that the method invocation <code>p.move(1,</code> <code>-1)</code> did not invoke the method <code>move</code> of class <code>Point</code>; instead, it invoked the overriding method <code>move</code> of class <code>RealPoint</code>.
<a name="39697"></a>
<p>The second line of output shows that the field access <code>rp.x</code> refers to the field <code>x</code> declared in class <code>RealPoint</code>. This field is of type <code>float</code>, and this second line of output accordingly displays floating-point values. Incidentally, this also illustrates the fact that the method name <code>show</code> is overloaded; the types of the arguments in the method invocation dictate which of the two definitions will be invoked.
<a name="230120"></a>
<p>The last two lines of output show that the method invocations <code>p.getX()</code> and <code>rp.getX()</code> each invoke the <code>getX</code> method declared in class <code>RealPoint</code>. Indeed, there is no way to invoke the <code>getX</code> method of class <code>Point</code> for an instance of class <code>RealPoint</code> from outside the body of <code>RealPoint</code>, no matter what the type of the variable we may use to hold the reference to the object. Thus, we see that fields and methods behave differently: hiding is different from overriding.
</pre></blockquote><a name="229207"></a>
<h4>8.4.8.5    Example: Invocation of Hidden Class Methods</h4>
<a name="229208"></a>
A hidden class (<code>static</code>) method can be invoked by using a reference whose type is the class that actually contains the declaration of the method. In this respect, hiding of static methods is different from overriding of instance methods. The example:<p>
<blockquote><pre>class Super {
	static String greeting() { return "Goodnight"; }
	String name() { return "Richard"; }
}
class Sub extends Super {
	static String greeting() { return "Hello"; }
	String name() { return "Dick"; }
}
class Test {
	public static void main(String[] args) {
		Super s = new Sub();
		System.out.println(s.greeting() + ", " + s.name());
	}
}
</pre></blockquote><a name="229223"></a>
produces the output:<p>
<blockquote><pre>Goodnight, Dick
</pre></blockquote><a name="229225"></a>
because the invocation of <code>greeting</code> uses the type of <code>s</code>, namely <code>Super</code>, to figure out, at compile time, which class method to invoke, whereas the invocation of <code>name</code> uses the class of <code>s</code>, namely <code>Sub</code>, to figure out, at run time, which instance method to invoke.<p>
<a name="229149"></a>
<h4>8.4.8.6    Large Example of Overriding</h4>
<a name="229150"></a>
Overriding makes it easy for subclasses to extend the behavior of an existing class, as shown in this example:<p>
<blockquote><pre>import java.io.OutputStream;
import java.io.IOException;
class BufferOutput {
	private OutputStream o;
	BufferOutput(OutputStream o) { this.o = o; }
	protected byte[] buf = new byte[512];
	protected int pos = 0;
	public void putchar(char c) throws IOException {
		if (pos == buf.length)
			flush();
		buf[pos++] = (byte)c;
	}
	public void putstr(String s) throws IOException {
		for (int i = 0; i &lt; s.length(); i++)
			putchar(s.charAt(i));
	}
	public void flush() throws IOException {
		o.write(buf, 0, pos);
		pos = 0;
	}
}
class LineBufferOutput extends BufferOutput {
	LineBufferOutput(OutputStream o) { super(o); }
	public void putchar(char c) throws IOException {
		super.putchar(c);
		if (c == '\n')
			flush();
	}
}
class Test {
	public static void main(String[] args)
		throws IOException
	{
		LineBufferOutput lbo =
			new LineBufferOutput(System.out);
		lbo.putstr("lbo\nlbo");
		System.out.print("print\n");
		lbo.putstr("\n");
	}
}
</pre></blockquote><a name="229188"></a>
This example produces the output:<p>
<blockquote><pre>lbo
print
lbo
</pre></blockquote>
<a name="229192"></a>
The class <code>BufferOutput</code> implements a very simple buffered version of an <code>OutputStream</code>, flushing the output when the buffer is full or <code>flush</code> is invoked. The subclass <code>LineBufferOutput</code> declares only a constructor and a single method <code>putchar</code>, which overrides the method <code>putchar</code> of <code>BufferOutput</code>. It inherits the methods <code>putstr</code> and <code>flush</code> from class <code>BufferOutput</code>.
<p>
<a name="229193"></a>
In the <code>putchar</code> method of a <code>LineBufferOutput</code> object, if the character argument is a newline, then it invokes the <code>flush</code> method. The critical point about overriding in this example is that the method <code>putstr</code>, which is declared in class <code>BufferOutput</code>, invokes the <code>putchar</code> method defined by the current object <code>this</code>, which is not necessarily the <code>putchar</code> method declared in class <code>BufferOutput</code>.
<a name="229194"></a>
<p>
Thus, when <code>putstr</code> is invoked in <code>main</code> using the <code>LineBufferOutput</code> object <code>lbo</code>, the invocation of <code>putchar</code> in the body of the <code>putstr</code> method is an invocation of the <code>putchar</code> of the object <code>lbo</code>, the overriding declaration of <code>putchar</code> that checks for a newline. This allows a subclass of <code>BufferOutput</code> to change the behavior of the <code>putstr</code> method without redefining it.
<a name="229195"></a>
<p>
Documentation for a class such as <code>BufferOutput</code>, which is designed to be extended, should clearly indicate what is the contract between the class and its subclasses, and should clearly indicate that subclasses may override the <code>putchar</code> method in this way. The implementor of the <code>BufferOutput</code> class would not, therefore, want to change the implementation of <code>putstr</code> in a future implementation of <code>BufferOutput</code> not to use the method <code>putchar</code>, because this would break the preexisting contract with subclasses. See the further discussion of binary compatibility in <a href="binaryComp.doc.html#44871">&#167;13</a>, especially <a href="binaryComp.doc.html#44952">&#167;13.2</a>.
<a name="229203"></a>
<h4>8.4.8.7    Example: Incorrect Overriding because of Throws</h4>
<a name="39701"></a>
This example uses the usual and conventional form for declaring a new exception type, in its declaration of the class <code>BadPointException</code>:<p>
<blockquote><pre>class BadPointException extends Exception {
	BadPointException() { super(); }
	BadPointException(String s) { super(s); }
}
class Point {
	int x, y;
	void move(int dx, int dy) { x += dx; y += dy; }
}
class CheckedPoint extends Point {
	void move(int dx, int dy) throws BadPointException {
		if ((x + dx) &lt; 0 || (y + dy) &lt; 0)
			throw new BadPointException();
		x += dx; y += dy;
	}
}
</pre></blockquote><a name="39718"></a>
This example results in a compile-time error, because the override of method <code>move</code> in class <code>CheckedPoint</code> declares that it will throw a checked exception that the <code>move</code> in class <code>Point</code> has not declared. If this were not considered an error, an invoker of the method <code>move</code> on a reference of type <code>Point</code> could find the contract between it and <code>Point</code> broken if this exception were thrown.<p>
<a name="39725"></a>
Removing the <code>throws</code> clause does not help:
<blockquote><pre>class CheckedPoint extends Point {
	void move(int dx, int dy) {
		if ((x + dx) &lt; 0 || (y + dy) &lt; 0)
			throw new BadPointException();
		x += dx; y += dy;
	}
}
</pre></blockquote>
<a name="259271"></a>
<p>
A different compile-time error now occurs, because the body of the method <code>move</code> cannot throw a checked exception, namely <code>BadPointException</code>, that does not appear in the <code>throws</code> clause for <code>move</code>.
<a name="246026"></a>
<h2>8.5    Member Type Declarations</h2>
<a name="247539"></a>
A <em>member class </em>is a class whose declaration is directly enclosed in another class or interface declaration. Similarly, a <em>member interface </em>is an interface whose declaration is directly enclosed in another class or interface declaration. The scope <a href="names.doc.html#103228">(&#167;6.3)</a> of a member class or interface is specified in <a href="classes.doc.html#18988">&#167;8.1.5</a>. <p>
<a name="289016"></a>
If the class declares a member type with a certain name, then the declaration of that type is said to <em>hide</em> any and all accessible declarations of member types with the same name in superclasses and superinterfaces of the class. <p>
<a name="260651"></a>
Within a class <i>C</i>, a declaration <i>d</i> of a member type named <i>n</i> shadows the declarations of any other types named <i>n</i> that are in scope at the point where <i>d</i> occurs.<p>
<a name="247579"></a>
If a member class or interface declared with simple name C is directly enclosed within the declaration of a class with fully qualified name N, then the member class or interface has the fully qualified name N.C. <p>
<a name="247722"></a>
A class may inherit two or more type declarations with the same name, either from two interfaces or from its superclass and an interface. A compile-time error occurs on any attempt to refer to any ambiguously inherited class or interface by its simple name.<p>
<a name="247732"></a>
If the same type declaration is inherited from an interface by multiple paths, the class or interface is considered to be inherited only once. It may be referred to by its simple name without ambiguity.<p>
<a name="247581"></a>
<h3>8.5.1    Access Modifiers</h3>
<a name="246857"></a>
The access modifiers public, protected, and private are discussed in <a href="names.doc.html#104285">&#167;6.6</a>. A &#32;compile-time error occurs if a member type declaration has more than one of the access modifiers public, protected, and private. <p>
<a name="246853"></a>
<h3>8.5.2    Static Member Type Declarations</h3>
<a name="246645"></a>
The static keyword may modify the declaration of a member type C within the body of a non-inner class T. Its effect is to declare that C is not an inner class. Just as a static method of T has no current instance of T in its body, C also has no current instance of T, nor does it have any lexically enclosing instances.<p>
<a name="250215"></a>
It is a compile-time error if a static class contains a usage of a non-static member of an enclosing class.<p>
<a name="247136"></a>
Member interfaces are always implicitly static. It is permitted but not required for the declaration of a member interface to explicitly list the static modifier.<p>
<a name="246032"></a>
<h2>8.6    Instance Initializers</h2>
<a name="246072"></a>
An <em>instance initializer</em> declared in a class is executed when an instance of the class is created <a href="expressions.doc.html#41147">(&#167;15.9)</a>, as specified in <a href="classes.doc.html#229267">&#167;8.8.5.1</a>. <p>
<ul><pre>
<em>InstanceInitializer:
	Block
</em></pre></ul><a name="262742"></a>
An instance initializer of a named class may not throw a checked exception unless that exception or one of its superclasses is explicitly declared in the throws clause of each constructor of its class and the class has at least one explicitly declared constructor. An instance initializer in an anonymous class <a href="expressions.doc.html#252986">(&#167;15.9.5)</a> can throw any exceptions. <p>
<a name="273818"></a>
The rules above distinguish between instance initializers in named and anonymous classes. This distinction is deliberate. A given anonymous class is only instantiated at a single point in a program. It is therefore possible to directly propagate information about what exceptions might be raised by an anonymous class' instance initializer to the surrounding expression. Named classes, on the other hand, can be instantiated in many places. Therefore the only way to propagate information about what exceptions might be raised by an instance initializer of a named class is through the throws clauses of its constructors. It follows that a more liberal rule can be used in the case of anonymous classes. Similar comments apply to instance variable initializers.
<a name="273817"></a>
<p>
It is a compile-time error if an instance initializer cannot complete normally <a href="statements.doc.html#236365">(&#167;14.20)</a>. If a return statement <a href="statements.doc.html#6767">(&#167;14.16)</a> appears anywhere within an instance initializer, then a compile-time error occurs.<p>
<a name="294486"></a>
Use of instance variables whose declarations appear textually after the use is sometimes restricted, even though these instance variables are in scope. See <a href="classes.doc.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to instance variables.<p>
<a name="247361"></a>
Instance initializers are permitted to refer to the current object this <a href="expressions.doc.html#251519">(&#167;15.8.3)</a> and to use the keyword super (<a href="expressions.doc.html#20860">&#167;15.11.2</a>, <a href="expressions.doc.html#20448">&#167;15.12</a>).<p>
<a name="39245"></a>
<h2>8.7    Static Initializers</h2>
<a name="39251"></a>
Any <em>static initializers </em>declared in a class are executed when the class is initialized and, together with any field initializers <a href="classes.doc.html#24510">(&#167;8.3.2)</a> for class variables, may be used to initialize the class variables of the class <a href="execution.doc.html#44557">(&#167;12.4)</a>.<p>
<ul><pre>
<em>StaticInitializer</em>:
	<em>static Block</em>
</pre></ul><a name="41620"></a>
It is a compile-time error for a static initializer to be able to complete abruptly (<a href="statements.doc.html#5894">&#167;14.1</a>, <a href="expressions.doc.html#79448">&#167;15.6</a>) with a checked exception <a href="exceptions.doc.html#44121">(&#167;11.2)</a>. It is a compile-time error if a static initializer cannot complete normally <a href="statements.doc.html#236365">(&#167;14.20)</a>.<p>
<a name="260750"></a>
The static initializers and class variable initializers are executed in textual order. <p>
<a name="294412"></a>
Use of class variables whose declarations appear textually after the use is sometimes restricted, even though these class variables are in scope. See <a href="classes.doc.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to class variables.<p>
<a name="41700"></a>
If a <code>return</code> statement <a href="statements.doc.html#6767">(&#167;14.16)</a> appears anywhere within a static initializer, then a compile-time error occurs.<p>
<a name="39966"></a>
If the keyword <code>this</code> <a href="expressions.doc.html#251519">(&#167;15.8.3)</a> or the keyword <code>super</code> (<a href="expressions.doc.html#41267">&#167;15.11</a>, <a href="expressions.doc.html#20448">&#167;15.12</a>) appears anywhere within a static initializer, then a compile-time error occurs.<p>
<a name="41652"></a>
<h2>8.8    Constructor Declarations</h2>
<a name="78391"></a>
A <em>constructor</em> is used in the creation of an object that is an instance of a class:<p>
<ul><pre>
<em>ConstructorDeclaration</em>:
<em>	ConstructorModifiers</em><sub><i>opt</i></sub>&#32;<em>ConstructorDeclarator
		Throws<sub><i>opt</i></sub>&#32;ConstructorBody

ConstructorDeclarator:
	SimpleTypeName ( FormalParameterList<sub><i>opt</i></sub> )
</em></pre></ul><a name="30689"></a>
The <em>SimpleTypeName </em>in the <em>ConstructorDeclarator</em> must be the simple name of the class that contains the constructor declaration; otherwise a compile-time error occurs. In all other respects, the constructor declaration looks just like a method declaration that has no result type.<p>
<a name="229252"></a>
<p>
<a name="229249"></a>
Here is a simple example:
<blockquote><pre>class Point {
	int x, y;
	Point(int x, int y) { this.x = x; this.y = y; }
}
</pre></blockquote><a name="41721"></a>
Constructors are invoked by class instance creation expressions <a href="expressions.doc.html#41147">(&#167;15.9)</a>, by the conversions and concatenations caused by the string concatenation operator + <a href="expressions.doc.html#39990">(&#167;15.18.1)</a>, and by explicit constructor invocations from other constructors <a href="classes.doc.html#78435">(&#167;8.8.5)</a>. Constructors are never invoked by method invocation expressions <a href="expressions.doc.html#20448">(&#167;15.12)</a>.<p>
<a name="29483"></a>
Access to constructors is governed by access modifiers <a href="names.doc.html#104285">(&#167;6.6)</a>. <p>
<a name="258999"></a>
This is useful, for example, in preventing instantiation by declaring an inaccessible constructor <a href="classes.doc.html#16830">(&#167;8.8.8)</a>.
<a name="39897"></a>
Constructor declarations are not members. They are never inherited and therefore are not subject to hiding or overriding.<p>
<a name="29488"></a>
<h3>8.8.1    Formal Parameters</h3>
<a name="41970"></a>
The formal parameters of a constructor are identical in structure and behavior to the formal parameters of a method <a href="classes.doc.html#38698">(&#167;8.4.1)</a>.<p>
<a name="41990"></a>
<h3>8.8.2    Constructor Signature</h3>
<a name="263235"></a>
The <em>signature</em> of a constructor consists of the number and types of formal parameters to the constructor. A class may not declare two constructors with the same signature, or a compile-time error occurs. <p>
<a name="42018"></a>
<h3>8.8.3    Constructor Modifiers</h3>
<ul><pre>
<em>ConstructorModifiers:
	ConstructorModifier
	ConstructorModifiers ConstructorModifier

ConstructorModifier: one of
</em>	public&#32;protected&#32;private
</pre></ul><a name="36010"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="names.doc.html#104285">&#167;6.6</a>. A &#32;compile-time error occurs if the same modifier appears more than once in a constructor declaration, or if a constructor declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code>.<p>
<a name="259286"></a>
Unlike methods, a constructor cannot be <code>abstract</code>, <code>static</code>, <code>final</code>, <code>native</code>, <code>strictfp</code>, or <code>synchronized</code>. A constructor is not inherited, so there is no need to declare it <code>final</code> and an <code>abstract</code> constructor could never be implemented. A constructor is always invoked with respect to an object, so it makes no sense for a constructor to be <code>static</code>. There is no practical need for a constructor to be <code>synchronized</code>, because it would lock the object under construction, which is normally not made available to other threads until all constructors for the object have completed their work. The lack of <code>native</code> constructors is an arbitrary language design choice that makes it easy for an implementation of the Java virtual machine to verify that superclass constructors are always properly invoked during object creation.
<a name="246538"></a>
<p>Note that a <em>ConstructorModifier</em> cannot be declared <code>strictfp</code>. This difference in the definitions for <em>ConstructorModifier</em> and <em>MethodModifier</em> <a href="classes.doc.html#78188">(&#167;8.4.3)</a> is an intentional language design choice; it effectively ensures that a constructor is FP-strict <a href="expressions.doc.html#249198">(&#167;15.4)</a> if and only if its class is FP-strict.

<a name="244611"></a>
<h3>8.8.4    Constructor Throws</h3>
<a name="244612"></a>
The <code>throws</code> clause for a constructor is identical in structure and behavior to the <code>throws</code> clause for a method <a href="classes.doc.html#78323">(&#167;8.4.4)</a>.<p>
<a name="78435"></a>
<h3>8.8.5    Constructor Body</h3>
<a name="42051"></a>
The first statement of a constructor body may be an explicit invocation of another constructor of the same class or of the direct superclass <a href="classes.doc.html#229267">(&#167;8.8.5.1)</a>.<p>
<ul><pre>
<em>ConstructorBody:
	{ ExplicitConstructorInvocation<sub>opt</sub> BlockStatements<sub><i>opt</i></sub> }
</em></pre></ul><a name="230283"></a>
<em></em>It is a compile-time error for a constructor to directly or indirectly invoke itself through a series of one or more explicit constructor invocations involving <code>this</code>. <p>
<a name="229836"></a>
If a constructor body does not begin with an explicit constructor invocation and the constructor being declared is not part of the primordial class <code>Object</code>, then the constructor body is implicitly assumed by the compiler to begin with a superclass constructor invocation "<code>super();</code>", an invocation of the constructor of its direct superclass that takes no arguments.<p>
<a name="30734"></a>
Except for the possibility of explicit constructor invocations, the body of a constructor is like the body of a method <a href="classes.doc.html#37316">(&#167;8.4.5)</a>. A <code>return</code> statement <a href="statements.doc.html#6767">(&#167;14.16)</a> may be used in the body of a constructor if it does not include an expression.<p>
<a name="42056"></a>
In the example:
<blockquote><pre>class Point {
	int x, y;
	Point(int x, int y) { this.x = x; this.y = y; }
}
class ColoredPoint extends Point {
	static final int WHITE = 0, BLACK = 1;
	int color;
	ColoredPoint(int x, int y) {
		this(x, y, WHITE);
	}
	ColoredPoint(int x, int y, int color) {
		super(x, y);
		this.color = color;
	}
}
</pre></blockquote><a name="271283"></a>
the first constructor of <code>ColoredPoint</code> invokes the second, providing an additional argument; the second constructor of <code>ColoredPoint</code> invokes the constructor of its superclass <code>Point</code>, passing along the coordinates.<p>
<a name="229264"></a>
<a href="execution.doc.html#44670">&#167;12.5</a> and <a href="expressions.doc.html#41147">&#167;15.9</a> describe the creation and initialization of new class instances.<p>
<a name="229267"></a>
<h4>8.8.5.1    Explicit Constructor Invocations</h4>
<ul><pre>
<em>ExplicitConstructorInvocation:
	</em>this<em> ( ArgumentList<sub><i>opt</i></sub> ) ;
</em>	super<em> ( ArgumentList<sub><i>opt</i></sub> ) ;
	Primary.super ( ArgumentList<sub><i>opt</i></sub> ) ; 
</em></pre></ul><a name="255778"></a>
<p>
<a name="255762"></a>
Explicit constructor invocation statements can be divided into two kinds:<p>
<ul><a name="255763"></a>
<li><em>Alternate constructor invocations</em> begin with the keyword this. They are used to invoke an alternate constructor of the same class.
<a name="255764"></a>
<li><em>Superclass constructor invocation</em>s begin with either the keyword super or a <em>Primary</em> expression. They are used to invoke a constructor of the direct superclass. Superclass constructor invocations may be further subdivided:
<ul>
<a name="255765"></a>
<li><em>Unqualified superclass constructor invocations</em> begin with the keyword super. 
<a name="255766"></a>
<li><em>Qualified superclass constructor invocations</em> begin with a <em>Primary</em> expression. They allow a subclass constructor to explicitly specify the newly created object's immediately enclosing instance with respect to the direct superclass <a href="classes.doc.html#262890">(&#167;8.1.2)</a>. This may be necessary when the superclass is an inner class.
<a name="255697"></a>
Here is an example of a qualified superclass constructor invocation:
</ul>
</ul><blockquote><pre>class Outer {
	class Inner{}
}
class ChildOfInner extends Outer.Inner {
	ChildOfInner(){(new Outer()).super();}
}
</pre></blockquote><a name="287141"></a>
</ul></ul>
An explicit constructor invocation statement in a constructor body may not refer to any instance variables or instance methods declared in this class or any superclass, or use <code>this</code> or <code>super</code> in any expression; otherwise, a compile-time error occurs. <p>
<a name="291517"></a>
For example, if the first constructor of <code>ColoredPoint</code> in the example above were changed to:
<blockquote><pre>ColoredPoint(int x, int y) {
	this(x, y, color);
}
</pre></blockquote><a name="259296"></a>
then a compile-time error would occur, because an instance variable cannot be used within a superclass constructor invocation.<p>
<a name="255702"></a>
If an anonymous class instance creation expression appears within an explicit constructor invocation statement, then the anonymous class may not refer to any of the enclosing instances of the class whose constructor is being invoked.<p>
<a name="255703"></a>
For example:
<blockquote><pre>class Top {
	int x;
	class Dummy {
		Dummy(Object o) {}
	}
	class Inside extends Dummy {
		Inside() {
			super(new Object() { int r = x; }); // error
		}
		Inside(final int y) {
			super(new Object() { int r = y; }); // correct
		}
	}
}
</pre></blockquote><a name="255722"></a>
Let <i>C</i> be the class being instantiated, let <i>S</i> be the direct superclass of <i>C</i>, and let <i>i</i> be the instance being created. The evaluation of an explicit constructor invocation proceeds as follows:<p>
<ul><a name="255921"></a>
<li>First, if the constructor invocation statement is a superclass constructor invocation, then the immediately enclosing instance of <i>i</i> with respect to <i>S</i> (if any) must be determined. Whether or not <i>i</i> has an immediately enclosing instance with respect to <i>S</i> is determined by the superclass constructor invocation as follows:
<ul>
<a name="255723"></a>
<li>If <i>S</i> is not an inner class, or if the declaration of <i>S</i> occurs in a static context, no immediately enclosing instance of <i>i</i> with respect to <i>S</i> exists. A compile-time error occurs if the superclass constructor invocation is a qualified superclass constructor invocation.
<a name="255724"></a>
<li>Otherwise:
<ul>
<a name="255725"></a>
<li>If the superclass constructor invocation is qualified, then the <em>Primary</em> expression <i>p</i> immediately preceding ".<code>super</code>" is evaluated. If the primary expression evaluates to <code>null</code>, a <code>NullPointerException</code> is raised, and the superclass constructor invocation completes abruptly. Otherwise, the result of this evaluation is the immediately enclosing instance of <i>i</i> with respect to <i>S</i>. Let <i>O</i> be the immediately lexically enclosing class of <i>S</i>; it is a compile-time error if the type of <i>p</i> is not <i>O</i> or a subclass of <i>O</i>.
<a name="255726"></a>
<li>Otherwise:
<ul>
<a name="255730"></a>
<li>If <i>S</i> is a local class <a href="statements.doc.html#247766">(&#167;14.3)</a>, then <i>S</i> must be declared in a method declared in a lexically enclosing class <i>O</i>. Let <em>n</em> be an integer such that <i>O</i> is the <em>n</em>th lexically enclosing class of <i>C</i>. The immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the <em>n</em>th lexically enclosing instance of this.
<a name="255734"></a>
<li>Otherwise, <i>S</i> is an inner member class <a href="classes.doc.html#246026">(&#167;8.5)</a>. It is a compile-time error if <i>S</i> is not a member of a lexically enclosing class. Let <i>O</i> be the innermost lexically enclosing class of which <i>S</i> is a member, and let <em>n</em> be an integer such that <i>O</i> is the <em>n</em>th lexically enclosing class of <i>C</i>. The immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the <em>n</em>th lexically enclosing instance of this.
</ul>
</ul>
</ul>
<a name="255735"></a>
<li>Second, the arguments to the constructor are evaluated, left-to-right, as in an ordinary method invocation.
<a name="255924"></a>
<li>Next, the constructor is invoked.
<a name="255859"></a>
<li>Finally, if the constructor invocation statement is a superclass constructor invocation and the constructor invocation statement completes normally, then all instance variable initializers of <i>C</i> and all instance initializers of <i>C</i> are executed. If an instance initializer or instance variable initializer <i>I</i> textually precedes another instance initializer or instance variable initializer <i>J</i>, then <i>I</i> is executed before <i>J</i>. This action is performed regardless of whether the superclass constructor invocation actually appears as an explicit constructor invocation statement or is provided automatically. An alternate constructor invocation does not perform this additional implicit action.
</ul><a name="229266"></a>
<h3>8.8.6    Constructor Overloading</h3>
<a name
<a name="16815"></a>
Overloading of constructors is identical in behavior to overloading of methods. The overloading is resolved at compile time by each class instance creation expression <a href="15.doc.html#41147">(&#167;15.9)</a>.<p>
<a name="16823"></a>
<h3>8.8.7    Default Constructor</h3>
<a name="229830"></a>
If a class contains no constructor declarations, then a <em>default constructor</em> that takes no parameters is automatically provided:<p>
<ul><a name="229831"></a>
<li>If the class being declared is the primordial class <code>Object</code>, then the default constructor has an empty body.
<a name="229832"></a>
<li>Otherwise, the default constructor takes no parameters and simply invokes the superclass constructor with no arguments.
</ul><a name="16772"></a>
A compile-time error occurs if a default constructor is provided by the compiler but the superclass does not have an accessible constructor that takes no arguments.<p>
<a name="257593"></a>
<p>A default constructor has no <code>throws</code> clause.<p>
It follows that is the nullary constructor of the superclass has a
<code>throws</code> clause, then a compile-time error will occur.
<p>
<a name="16773"></a>
If the class is declared public, then the default constructor is implicitly given the access modifier public <a href="6.doc.html#104285">(&#167;6.6)</a>; if the class is declared protected, then the default constructor is implicitly given the access modifier protected <a href="6.doc.html#104285">(&#167;6.6)</a>; if the class is declared private, then the default constructor is implicitly given the access modifier private <a href="6.doc.html#104285">(&#167;6.6)</a>; otherwise, the default constructor has the default access implied by no access modifier. <p>
<a name="259026"></a>
Thus, the example:
<blockquote><pre>public class Point {
	int x, y;
}
</pre></blockquote><a name="16781"></a>
is equivalent to the declaration:<p>
<blockquote><pre>public class Point {
	int x, y;
	public Point() { super(); }
}
</pre></blockquote><a name="16786"></a>
where the default constructor is <code>public</code> because the class <code>Point</code> is <code>public</code>.<p>

The rule that the default constructor of a class has the same access modifier as the class itself is simple and intuitive. Note, however, that this does not imply that the constructor is accessible whenever the class is accessible. Consider
<blockquote><pre>package p1;
public class Outer {
 	protected class Inner{}
}
package p2;
class SonOfOuter extends p1.Outer {
	void foo() {
 		new Inner(); // compile-time access error
	}
}

</pre></blockquote><a name="259796"></a>
The constructor for <code>Inner</code> is protected. However, the constructor is protected relative to <code>Inner</code>, while <code>Inner</code> is protected relative to <code>Outer</code>. So, <code>Inner</code> is accessible in <code>SonOfOuter</code>, since it is a subclass of <code>Outer</code>. <code>Inner</code>'s constructor is not accessible in <code>SonOfOuter</code>, because the class <code>SonOfOuter</code> is not a subclass of <code>Inner</code>! Hence, even though <code>Inner </code>is accessible, its default constructor is not.<p>
<a name="16830"></a>
<h3>8.8.8    Preventing Instantiation of a Class</h3>
<a name="16831"></a>
A class can be designed to prevent code outside the class declaration from creating instances of the class by declaring at least one constructor, to prevent the creation of an implicit constructor, and declaring all constructors to be <code>private</code>. A <code>public</code> class can likewise prevent the creation of instances outside its package by declaring at least one constructor, to prevent creation of a default constructor with <code>public</code> access, and declaring no constructor that is <code>public</code>.<p>
<a name="16833"></a>
Thus, in the example:
<blockquote><pre>class ClassOnly {
	private ClassOnly() { }
	static String just = "only the lonely";
}
</pre></blockquote><a name="16838"></a>
the class <code>ClassOnly</code> cannot be instantiated, while in the example:<p>
<blockquote><pre>package just;
public class PackageOnly {
	PackageOnly() { }
	String[] justDesserts = { "cheesecake", "ice cream" };
}
</pre></blockquote><a name="259306"></a>
the class <code>PackageOnly</code> can be instantiated only within the package <code>just</code>, in which it is declared.
<p>


<hr>
<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="7.doc.html">Prev</a> | <a href="interfaces.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<p>
<font size=-1>Java Language Specification (HTML generated by Suzette Pelouch on May 19, 2000)<br>
<i><a href="jcopyright.doc.html">Copyright &#169 2000 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jls@java.sun.com">jls@java.sun.com</a>
</font>
</body></html>
