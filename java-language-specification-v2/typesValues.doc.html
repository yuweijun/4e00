<html>
<head>
<title> Types, Values, and Variables</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="lexical.doc.html">Prev</a> | <a href="conversions.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<hr><br>
 
<a name="44329"></a>
<p><strong>
CHAPTER
 4 </strong></p>
<a name="48440"></a>
<h1>Types, Values, and Variables</h1>
<hr><p>
<a name="97679"></a>
The Java programming language is a <em>strongly typed</em> language, which means that every variable and every expression has a type that is known at compile time. Types limit the values that a variable <a href="typesValues.doc.html#18470">(&#167;4.5)</a> can hold or that an expression can produce, limit the operations supported on those values, and determine the meaning of the operations. Strong typing helps detect errors at compile time.<p>
<a name="50743"></a>
The types of the Java programming language are divided into two categories: primitive types and reference types. The primitive types <a href="typesValues.doc.html#85587">(&#167;4.2)</a> are the <code>boolean</code> type and the numeric types. The numeric types are the integral types <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, and <code>char</code>, and the floating-point types <code>float</code> and <code>double</code>. The reference types <a href="typesValues.doc.html#9317">(&#167;4.3)</a> are class types, interface types, and array types. There is also a special null type. An object <a href="typesValues.doc.html#12028">(&#167;4.3.1)</a> is a dynamically created instance of a class type or a dynamically created array. The values of a reference type are references to objects. All objects, including arrays, support the methods of class <code>Object</code> <a href="typesValues.doc.html#11055">(&#167;4.3.2)</a>. String literals are represented by <code>String</code> objects <a href="typesValues.doc.html#26992">(&#167;4.3.3)</a>.<p>
<a name="50838"></a>
Names of types are used <a href="typesValues.doc.html#25948">(&#167;4.4)</a> in declarations, casts, class instance creation expressions, array creation expressions, class literals, and <code>instanceof</code> operator expressions. <p>
<a name="50800"></a>
A variable <a href="typesValues.doc.html#18470">(&#167;4.5)</a> is a storage location. A variable of a primitive type always holds a value of that exact type. A variable of a class type <i>T</i> can hold a null reference or a reference to an instance of class <i>T</i> or of any class that is a subclass of <i>T</i>. A variable of an interface type can hold a null reference or a reference to any instance of any class that implements the interface. If <i>T</i> is a primitive type, then a variable of type "array of <i>T</i>" can hold a null reference or a reference to any array of type "array of <i>T</i>"; if <i>T</i> is a reference type, then a variable of type "array of <i>T</i>" can hold a null reference or a reference to any array of type "array of <i>S</i>" such that type <i>S</i> is assignable <a href="conversions.doc.html#184206">(&#167;5.2)</a> to type <i>T</i>. A variable of type <code>Object</code> can hold a null reference or a reference to any object, whether class instance or array.<p>
<a name="11128"></a>
<h2>4.1    The Kinds of Types and Values</h2>
<a name="10737"></a>
There are two kinds of <em>types</em> in the Java programming language: primitive types <a href="typesValues.doc.html#85587">(&#167;4.2)</a> and reference types <a href="typesValues.doc.html#9317">(&#167;4.3)</a>. There are, correspondingly, two kinds of data values that can be stored in variables, passed as arguments, returned by methods, and operated on: primitive values <a href="typesValues.doc.html#85587">(&#167;4.2)</a> and reference values <a href="typesValues.doc.html#9317">(&#167;4.3)</a>.<p>
<ul><pre>
<i>Type:
<code>	</code>PrimitiveType
	ReferenceType
</i></pre></ul><a name="23953"></a>
There is also a special <em>null type</em>, the type of the expression <code>null</code>, which has no name. Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type. The null reference is the only possible value of an expression of null type. The null reference can always be cast to any reference type. In practice, the programmer can ignore the null type and just pretend that <code>null</code> is merely a special literal that can be of any reference type.<p>
<a name="85587"></a>
<h2>4.2    Primitive Types and Values</h2>
<a name="9122"></a>
A <em>primitive type</em> is predefined by the Java programming language and named by its reserved keyword <a href="lexical.doc.html#229308">(&#167;3.9)</a>:<p>
<ul><pre>
<i>PrimitiveType:
	NumericType
</i>	<code>boolean
</code>
<i>NumericType:
	IntegralType
	FloatingPointType

IntegralType: one of</i>
	<code>byte short int long char
</code>
<i>FloatingPointType: one of</i>
<code>	float double
</code></pre></ul><a name="50919"></a>
Primitive values do not share state with other primitive values. A variable whose type is a primitive type always holds a primitive value of that same type. The value of a variable of primitive type can be changed only by assignment operations on that variable.<p>
<a name="9137"></a>
The <em>numeric types</em> are the integral types and the floating-point types. <p>
<a name="88061"></a>
The <em>integral types</em> are <code>byte</code>, <code>short</code>, <code>int</code>, and <code>long</code>, whose values are 8-bit, 16-bit, 32-bit and 64-bit signed two's-complement integers, respectively, and <code>char</code>, whose values are 16-bit unsigned integers representing Unicode characters.<p>
<a name="88062"></a>
The <em>floating-point types</em> are <code>float</code>, whose values include the 32-bit IEEE 754 floating-point numbers, and <code>double</code>, whose values include the 64-bit IEEE 754 floating-point numbers.<p>
<a name="50913"></a>
The <code>boolean</code> type has exactly two values: <code>true</code> and <code>false.</code><p>
<a name="9151"></a>
<h3>4.2.1    Integral Types and Values</h3>
<a name="50950"></a>
The values of the integral types are integers in the following ranges:<p>
<ul><a name="9163"></a>
<li>For <code>byte</code>, from -128 to 127, inclusive
<a name="9164"></a>
<li>For <code>short</code>, from -32768 to 32767, inclusive
<a name="9165"></a>
<li>For <code>int</code>, from -2147483648 to 2147483647, inclusive
<a name="9166"></a>
<li>For <code>long</code>, from -9223372036854775808 to 9223372036854775807, inclusive
<a name="51034"></a>
<li>For <code>char</code>, from <code>'\u0000'</code> to <code>'\uffff'</code> inclusive, that is, from 0 to 65535
</ul><a name="51035"></a>
<h3>4.2.2    Integer Operations</h3>
<a name="29775"></a>
The Java programming language provides a number of operators that act on integral values:<p>
<ul><a name="10358"></a>
<li>The comparison operators, which result in a value of type <code>boolean</code>:
<ul>
<a name="9181"></a>
<li>The numerical comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> <a href="expressions.doc.html#153654">(&#167;15.20.1)</a>
<a name="17601"></a>
<li>The numerical equality operators <code>==</code> and <code>!=</code> <a href="expressions.doc.html#5198">(&#167;15.21.1)</a>
</ul>
<a name="10365"></a>
<li>The numerical operators, which result in a value of type <code>int</code> or <code>long</code>:
<ul>
<a name="18334"></a>
<li>The unary plus and minus operators <code>+</code> and <code>-</code> (<a href="expressions.doc.html#24924">&#167;15.15.3</a>, <a href="expressions.doc.html#236345">&#167;15.15.4</a>)
<a name="17539"></a>
<li>The multiplicative operators <code>*</code>, <code>/</code>, and <code>%</code> <a href="expressions.doc.html#239829">(&#167;15.17)</a>
<a name="19482"></a>
<li>The additive operators <code>+</code> and <code>-</code> <a href="expressions.doc.html#13510">(&#167;15.18.2)</a>
<a name="24026"></a>
<li>The increment operator <code>++</code>, both prefix <a href="expressions.doc.html#39547">(&#167;15.15.1)</a> and postfix <a href="expressions.doc.html#39438">(&#167;15.14.1)</a>
<a name="24036"></a>
<li>The decrement operator <code>--</code>, both prefix <a href="expressions.doc.html#239136">(&#167;15.15.2)</a> and postfix <a href="expressions.doc.html#4987">(&#167;15.14.2)</a>
<a name="19496"></a>
<li>The signed and unsigned shift operators <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code> <a href="expressions.doc.html#5121">(&#167;15.19)</a>
<a name="51061"></a>
<li>The bitwise complement operator <code>~</code> <a href="expressions.doc.html#5017">(&#167;15.15.5)</a>
<a name="17770"></a>
<li>The integer bitwise operators <code>&amp;</code>, <code>|</code>, and <code>^</code> <a href="expressions.doc.html#5233">(&#167;15.22.1)</a>
</ul>
<a name="19469"></a>
<li>The conditional operator <code>? :</code> <a href="expressions.doc.html#290293">(&#167;15.25)</a>
<a name="18373"></a>
<li>The cast operator, which can convert from an integral value to a value of any specified numeric type (<a href="conversions.doc.html#20232">&#167;5.5</a>, <a href="expressions.doc.html#238146">&#167;15.16</a>)
<a name="17774"></a>
<li>The string concatenation operator <code>+</code> <a href="expressions.doc.html#39990">(&#167;15.18.1)</a>, which, when given a <code>String</code> operand and an integral operand, will convert the integral operand to a <code>String</code> representing its value in decimal form, and then produce a newly created <code>String</code> that is the concatenation of the two strings
</ul><a name="51025"></a>
Other useful constructors, methods, and constants are predefined in the classes <code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, and <code>Character</code>.<p>
<a name="28057"></a>
If an integer operator other than a shift operator has at least one operand of type <code>long</code>, then the operation is carried out using 64-bit precision, and the result of the numerical operator is of type <code>long</code>. If the other operand is not <code>long</code>, it is first widened <a href="conversions.doc.html#25215">(&#167;5.1.4)</a> to type <code>long</code> by numeric promotion <a href="conversions.doc.html#26917">(&#167;5.6)</a>. Otherwise, the operation is carried out using 32-bit precision, and the result of the numerical operator is of type <code>int</code>. If either operand is not an <code>int</code>, it is first widened to type <code>int</code> by numeric promotion.<p>
<a name="9194"></a>
The built-in integer operators do not indicate overflow or underflow in any way. The only numeric operators that can throw an exception <a href="exceptions.doc.html#44043">(&#167;11)</a> are the integer divide operator <code>/</code> <a href="expressions.doc.html#5047">(&#167;15.17.2)</a> and the integer remainder operator <code>%</code> <a href="expressions.doc.html#24956">(&#167;15.17.3)</a>, which throw an <code>ArithmeticException</code> if the right-hand operand is zero. <p>
<a name="86654"></a>
The example:
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int i = 1000000;
		System.out.println(i * i);
		long l = i;
		System.out.println(l * l);
		System.out.println(20296 / (l - i));
	}
}
</pre></blockquote><a name="51131"></a>
produces the output:<p>
<blockquote><pre>-727379968
1000000000000
</pre></blockquote><a name="51199"></a>
and then encounters an <code>ArithmeticException</code> in the division by <code>l</code> <code>-</code> <code>i</code>, because <code>l</code> <code>-</code> <code>i</code> is zero. The first multiplication is performed in 32-bit precision, whereas the second multiplication is a <code>long</code> multiplication. The value <code>-727379968</code> is the decimal value of the low 32 bits of the mathematical result, <code>1000000000000</code>, which is a value too large for type <code>int</code>.<p>
<a name="51203"></a>
Any value of any integral type may be cast to or from any numeric type. There are no casts between integral types and the type <code>boolean</code>.<p>
<a name="9208"></a>
<h3>4.2.3    Floating-Point Types, Formats, and Values</h3>
<a name="87606"></a>
The floating-point types are <code>float</code> and <code>double</code>, which are conceptually associated with the single-precision 32-bit and double-precision 64-bit format IEEE 754 values and operations as specified in <em>IEEE Standard for Binary Floating-Point Arithmetic</em>, ANSI/IEEE Standard 754-1985 (IEEE, New York).<p>
<a name="88071"></a>
The IEEE 754 standard includes not only positive and negative numbers that consist of a sign and magnitude, but also positive and negative zeros, positive and negative <em>infinities</em>, and special <em>Not-a-Number </em>values (hereafter abbreviated NaN). A NaN value is used to represent the result of certain invalid operations such as dividing zero by zero. NaN constants of both <code>float</code> and <code>double</code> type are predefined as <code>Float.NaN</code> and <code>Double.NaN</code>.<p>
<a name="96776"></a>
Every implementation of the Java programming language is required to support two standard sets of floating-point values, called the <em>float value set</em> and the <em>double value set</em>. In addition, an implementation of the Java programming language may support either or both of two extended-exponent floating-point value sets, called the<em> float-extended-exponent value set</em> and the<em> double-extended-exponent value set</em>. These extended-exponent value sets may, under certain circumstances, be used instead of the standard value sets to represent the values of expressions of type <code>float</code> or <code>double</code> (<a href="conversions.doc.html#184225">&#167;5.1.8</a>, <a href="expressions.doc.html#249198">&#167;15.4</a>).<p>
<a name="96777"></a>
The finite nonzero values of any floating-point value set can all be expressed in the form <img src="typesValues.doc.anc.gif">, where <em>s</em> is +1 or -1, <em>m</em> is a positive integer less than <img src="typesValues.doc.anc1.gif">, and <em>e</em> is an integer between <img src="typesValues.doc.anc2.gif"> and <img src="typesValues.doc.anc3.gif">, inclusive, and where <em>N</em> and <em>K</em> are parameters that depend on the value set. Some values can be represented in this form in more than one way; for example, supposing that a value <em>v</em> in a value set might be represented in this form using certain values for <em>s</em>, <em>m</em>, and <em>e</em>, then if it happened that <em>m</em> were even and <em>e</em> were less than <img src="typesValues.doc.anc4.gif">, one could halve <em>m</em> and increase <em>e</em> by 1 to produce a second representation for the same value <em>v</em>. A representation in this form is called <em>normalized</em> if <img src="typesValues.doc.anc5.gif">; otherwise the representation is said to be <em>denormalized</em>. If a value in a value set cannot be represented in such a way that <img src="typesValues.doc.anc7.gif">, then the value is said to be a <em>denormalized value</em>, because it has no normalized representation.<p>
<a name="96680"></a>
The constraints on the parameters <em>N</em> and <em>K</em> (and on the derived parameters <em>E</em><sub><i>min</i></sub> and <em>E</em><sub><i>max</i></sub>) for the two required and two optional floating-point value sets are summarized in <a href="typesValues.doc.html#96802">Table 4.1</a>. 
<p>
<Table Border="3">
<caption><a name="96802"></a>
<i>Floating-point value set parameters</i>
</caption>
<tr><th><a name="96683"></a>
<b> Parameter</b>
<th><a name="96685"></a>
<strong>float</strong>
<th><a name="96687"></a>
<strong>float-extended-exponent</strong>
<th><a name="96689"></a>
<b> double</b>
<th><a name="96691"></a>
<b> double-extended-exponent<b>

<tr><td><a name="96693"></a>
 N<p>
<td><a name="96695"></a>
 24<p>
<td><a name="96697"></a>
 24<p>
<td><a name="96699"></a>
 53<p>
<td><a name="96701"></a>
 53<p>

<tr><td><a name="96703"></a>
 K<p>
<td><a name="96705"></a>
 8<p>
<td><a name="96707"></a>
 <img src="chars/gtequal.gif"> 11<p>
<td><a name="96709"></a>
 11<p>
<td><a name="96711"></a>
 <img src="chars/gtequal.gif"> 15<p>

<tr><td><a name="96713"></a>
 E<sub><i>max</i></sub><p>
<td><a name="96715"></a>
 +127<p>
<td><a name="96717"></a>
 <img src="chars/gtequal.gif"> +1023<p>
<td><a name="96719"></a>
 +1023<p>
<td><a name="96721"></a>
 <img src="chars/gtequal.gif"> +16383<p>

<tr><td><a name="96723"></a>
 E<sub><i>min</i></sub><p>
<td><a name="96725"></a>
 -126<p>
<td><a name="96727"></a>
 <img src="chars/lt_equal.gif"> -1022<p>
<td><a name="96729"></a>
 -1022<p>
<td><a name="96731"></a>
<img src="chars/lt_equal.gif"> -16382<p>


</Table>

<Table>
<tr><td>
</Table>
<p>
<a name="106189"></a>
Where one or both extended-exponent value sets are supported by an implementation, then for each supported extended-exponent value set there is a specific implementation-dependent constant <em>K</em>, whose value is constrained by <a href="typesValues.doc.html#96802">Table 4.1</a>; this value <em>K</em> in turn dictates the values for <em>E</em><sub><i>min</i></sub> and <em>E</em><sub><i>max</i></sub>.<p>
<a name="96735"></a>
Each of the four value sets includes not only the finite nonzero values that are ascribed to it above, but also NaN values and the four values positive zero, negative zero, positive infinity, and negative infinity.<p>
<a name="96736"></a>
Note that the constraints in <a href="typesValues.doc.html#96802">Table 4.1</a> are designed so that every element of the float value set is necessarily also an element of the float-extended-exponent value set, the double value set, and the double-extended-exponent value set. Likewise, each element of the double value set is necessarily also an element of the double-extended-exponent value set. Each extended-exponent value set has a larger range of exponent values than the corresponding standard value set, but does not have more precision.<p>
<a name="96737"></a>
The elements of the float value set are exactly the values that can be represented using the single floating-point format defined in the IEEE 754 standard. The elements of the double value set are exactly the values that can be represented using the double floating-point format defined in the IEEE 754 standard. Note, however, that the elements of the float-extended-exponent and double-extended-exponent value sets defined here do <em>not</em> correspond to the values that can be represented using IEEE 754 single extended and double extended formats, respectively.<p>
<a name="96744"></a>
The float, float-extended-exponent, double, and double-extended-exponent value sets are not types. It is always correct for an implementation of the Java programming language to use an element of the float value set to represent a value of type <code>float</code>; however, it may be permissible in certain regions of code for an implementation to use an element of the float-extended-exponent value set instead. Similarly, it is always correct for an implementation to use an element of the double value set to represent a value of type <code>double</code>; however, it may be permissible in certain regions of code for an implementation to use an element of the double-extended-exponent value set instead.<p>
<a name="106159"></a>
Except for NaN, floating-point values are <em>ordered</em>; arranged from smallest to largest, they are negative infinity, negative finite nonzero values, positive and negative zero, positive finite nonzero values, and positive infinity.<p>
<a name="106160"></a>
IEEE 754 allows multiple distinct NaN values for each of its single and double floating-point formats. While each hardware architecture returns a particular bit pattern for NaN when a new NaN is generated, a programmer can also create NaNs with different bit patterns to encode, for example, retrospective diagnostic information. <p>
<a name="106258"></a>
For the most part, the Java platform treats NaN values of a given type as though collapsed into a single canonical value (and hence this specification normally refers to an arbitrary NaN as though to a canonical value). However, version 1.3 the Java platform introduced methods enabling the programmer to distinguish between NaN values: the <code>Float.floatToRawIntBits</code> and <code>Double.doubleToRawLongBits</code> methods. The interested reader is referred to the specifications for the <code>Float</code> and <code>Double</code> classes for more information.<p>
<a name="86666"></a>
Positive zero and negative zero compare equal; thus the result of the expression <code>0.0==-0.0</code> is <code>true</code> and the result of <code>0.0&gt;-0.0</code> is <code>false</code>. But other operations can distinguish positive and negative zero; for example, <code>1.0/0.0</code> has the value positive infinity, while the value of <code>1.0/-0.0</code> is negative infinity.<p>
<a name="16083"></a>
NaN is <em>unordered</em>, so the numerical comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> return <code>false</code> if either or both operands are NaN <a href="expressions.doc.html#153654">(&#167;15.20.1)</a>. The equality operator <code>==</code> returns <code>false</code> if either operand is NaN, and the inequality operator <code>!=</code> returns <code>true</code> if either operand is NaN <a href="expressions.doc.html#5198">(&#167;15.21.1)</a>. In particular, <code>x!=x</code> is <code>true</code> if and only if <code>x</code> is NaN, and <code>(x&lt;y)</code> <code>==</code> <code>!(x&gt;=y)</code> will be <code>false</code> if <code>x</code> or <code>y</code> is NaN.<p>
<a name="16093"></a>
Any value of a floating-point type may be cast to or from any numeric type. There are no casts between floating-point types and the type <code>boolean</code>.<p>
<a name="9249"></a>
<h3>4.2.4    Floating-Point Operations</h3>
<a name="9981"></a>
The Java programming language provides a number of operators that act on floating-point values:<p>
<ul><a name="52058"></a>
<li>The comparison operators, which result in a value of type <code>boolean</code>:
<ul>
<a name="52062"></a>
<li>The numerical comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> <a href="expressions.doc.html#153654">(&#167;15.20.1)</a>
<a name="52066"></a>
<li>The numerical equality operators <code>==</code> and <code>!=</code> <a href="expressions.doc.html#5198">(&#167;15.21.1)</a>
</ul>
<a name="52069"></a>
<li>The numerical operators, which result in a value of type <code>float</code> or <code>double</code>:
<ul>
<a name="52076"></a>
<li>The unary plus and minus operators <code>+</code> and <code>-</code> (<a href="expressions.doc.html#24924">&#167;15.15.3</a>, <a href="expressions.doc.html#236345">&#167;15.15.4</a>)
<a name="24115"></a>
<li>The multiplicative operators <code>*</code>, <code>/</code>, and <code>%</code> <a href="expressions.doc.html#239829">(&#167;15.17)</a>
<a name="24119"></a>
<li>The additive operators <code>+</code> and <code>-</code> <a href="expressions.doc.html#13510">(&#167;15.18.2)</a>
<a name="24126"></a>
<li>The increment operator <code>++</code>, both prefix <a href="expressions.doc.html#39547">(&#167;15.15.1)</a> and postfix <a href="expressions.doc.html#39438">(&#167;15.14.1)</a>
<a name="24107"></a>
<li>The decrement operator <code>--</code>, both prefix <a href="expressions.doc.html#239136">(&#167;15.15.2)</a> and postfix <a href="expressions.doc.html#4987">(&#167;15.14.2)</a>
</ul>
<a name="19446"></a>
<li>The conditional operator <code>? :</code> <a href="expressions.doc.html#290293">(&#167;15.25)</a>
<a name="11998"></a>
<li>The cast operator, which can convert from a floating-point value to a value of any specified numeric type (<a href="conversions.doc.html#20232">&#167;5.5</a>, <a href="expressions.doc.html#238146">&#167;15.16</a>)
<a name="21842"></a>
<li>The string concatenation operator <code>+</code> <a href="expressions.doc.html#39990">(&#167;15.18.1)</a>, which, when given a <code>String</code> operand and a floating-point operand, will convert the floating-point operand to a <code>String</code> representing its value in decimal form (without information loss), and then produce a newly created <code>String</code> by concatenating the two strings
</ul><a name="12009"></a>
Other useful constructors, methods, and constants are predefined in the classes <code>Float</code>, <code>Double</code>, and <code>Math</code>.<p>
<a name="12005"></a>
If at least one of the operands to a binary operator is of floating-point type, then the operation is a floating-point operation, even if the other is integral.<p>
<a name="51262"></a>
If at least one of the operands to a numerical operator is of type <code>double</code>, then the operation is carried out using 64-bit floating-point arithmetic, and the result of the numerical operator is a value of type <code>double</code>. (If the other operand is not a <code>double</code>, it is first widened to type <code>double</code> by numeric promotion <a href="conversions.doc.html#26917">(&#167;5.6)</a>.) Otherwise, the operation is carried out using 32-bit floating-point arithmetic, and the result of the numerical operator is a value of type <code>float. </code>If the other operand is not a <code>float</code>, it is first widened to type <code>float</code> by numeric promotion.<p>
<a name="9265"></a>
Operators on floating-point numbers behave as specified by IEEE 754 (with the exception of the remainder operator <a href="expressions.doc.html#24956">(&#167;15.17.3)</a>). In particular, the Java programming language requires support of IEEE 754 <em>denormalized</em> floating-point numbers and <em>gradual underflow</em>, which make it easier to prove desirable properties of particular numerical algorithms. Floating-point operations do not "flush to zero" if the calculated result is a denormalized number.<p>
<a name="9274"></a>
The Java programming language requires that floating-point arithmetic behave as if every floating-point operator rounded its floating-point result to the result precision. <em>Inexact</em> results must be rounded to the representable value nearest to the infinitely precise result; if the two nearest representable values are equally near, the one with its least significant bit zero is chosen. This is the IEEE 754 standard's default rounding mode known as <em>round to nearest</em>.<p>
<a name="10346"></a>
The language uses <em>round toward zero</em> when converting a floating value to an integer <a href="conversions.doc.html#25363">(&#167;5.1.3)</a>, which acts, in this case, as though the number were truncated, discarding the mantissa bits. Rounding toward zero chooses at its result the format's value closest to and no greater in magnitude than the infinitely precise result.<p>
<a name="9290"></a>
Floating-point operators produce no exceptions <a href="exceptions.doc.html#44043">(&#167;11)</a>. An operation that overflows produces a signed infinity, an operation that underflows produces a denormalized value or a signed zero, and an operation that has no mathematically definite result produces NaN. All numeric operations with NaN as an operand produce NaN as a result. As has already been described, NaN is unordered, so a numeric comparison operation involving one or two NaNs returns <code>false</code> and any <code>!=</code> comparison involving NaN returns <code>true</code>, including <code>x!=x</code> when <code>x</code> is NaN.<p>
<a name="9291"></a>
The example program:
<blockquote><pre>class Test {
	public static void main(String[] args) {
		// An example of overflow:
		double d = 1e308;
		System.out.print("overflow produces infinity: ");
		System.out.println(d + "*10==" + d*10);
		// An example of gradual underflow:
		d = 1e-305 * Math.PI;
		System.out.print("gradual underflow: " + d + "\n &#32; &#32; &#32;");
		for (int i = 0; i &lt; 4; i++)
			System.out.print(" " + (d /= 100000));
		System.out.println();
		// An example of NaN:
		System.out.print("0.0/0.0 is Not-a-Number: ");
		d = 0.0/0.0;
		System.out.println(d);
		// An example of inexact results and rounding:
		System.out.print("inexact results with float:");
		for (int i = 0; i &lt; 100; i++) {
			float z = 1.0f / i;
			if (z * i != 1.0f)
				System.out.print(" " + i);
		}
		System.out.println();
		// Another example of inexact results and rounding:
		System.out.print("inexact results with double:");
		for (int i = 0; i &lt; 100; i++) {
			double z = 1.0 / i;
			if (z * i != 1.0)
				System.out.print(" " + i);
		}
		System.out.println();
		// An example of cast to integer rounding:
		System.out.print("cast to int rounds toward 0: ");
		d = 12345.6;
		System.out.println((int)d + " " + (int)(-d));
	}
}
</pre></blockquote><a name="23297"></a>
produces the output:<p>
<blockquote><pre>overflow produces infinity: 1.0e+308*10==Infinity
gradual underflow: 3.141592653589793E-305
	3.1415926535898E-310 3.141592653E-315 3.142E-320 0.0
0.0/0.0 is Not-a-Number: NaN
inexact results with float: 0 41 47 55 61 82 83 94 97
inexact results with double: 0 49 98
cast to int rounds toward 0: 12345 -12345
</pre></blockquote>
<a name="22309"></a>
This example demonstrates, among other things, that gradual underflow can result in a gradual loss of precision.
<a name="11717"></a>
The results when <code>i</code> is <code>0</code> involve division by zero, so that <code>z</code> becomes positive infinity, and <code>z</code> <code>*</code> <code>0</code> is NaN, which is not equal to <code>1.0</code>.
</pre></blockquote><a name="11527"></a>
<h3>4.2.5    The <code>boolean</code> Type and <code>boolean</code> Values</h3>
<a name="9295"></a>
The <code>boolean</code> type represents a logical quantity with two possible values, indicated by the literals <code>true</code> and <code>false</code> <a href="lexical.doc.html#49652">(&#167;3.10.3)</a>. The boolean operators are:<p>
<ul><a name="17733"></a>
<li>The relational operators <code>==</code> and <code>!=</code> <a href="expressions.doc.html#54508">(&#167;15.21.2)</a>
<a name="17734"></a>
<li>The logical-complement operator <code>!</code> <a href="expressions.doc.html#13350">(&#167;15.15.6)</a>
<a name="17736"></a>
<li>The logical operators <code>&amp;</code>, <code>^</code>, and <code>|</code> <a href="expressions.doc.html#5242">(&#167;15.22.2)</a>
<a name="17737"></a>
<li>The conditional-and and conditional-or operators <code>&amp;&amp;</code> <a href="expressions.doc.html#5247">(&#167;15.23)</a> and <code>||</code> <a href="expressions.doc.html#54532">(&#167;15.24)</a>
<a name="19467"></a>
<li>The conditional operator <code>? :</code> <a href="expressions.doc.html#290293">(&#167;15.25)</a>
<a name="21871"></a>
<li>The string concatenation operator <code>+</code> <a href="expressions.doc.html#39990">(&#167;15.18.1)</a>, which, when given a <code>String</code> operand and a boolean operand, will convert the boolean operand to a <code>String</code> (either <code>"true"</code> or <code>"false"</code>), and then produce a newly created <code>String</code> that is the concatenation of the two strings
</ul><a name="17738"></a>
Boolean expressions determine the control flow in several kinds of statements:<p>
<ul><a name="17742"></a>
<li>The <code>if</code> statement <a href="statements.doc.html#5991">(&#167;14.9)</a>
<a name="17743"></a>
<li>The <code>while</code> statement <a href="statements.doc.html#237277">(&#167;14.11)</a>
<a name="17745"></a>
<li>The <code>do</code> statement <a href="statements.doc.html#6045">(&#167;14.12)</a>
<a name="17747"></a>
<li>The <code>for</code> statement <a href="statements.doc.html#24588">(&#167;14.13)</a>
</ul><a name="48454"></a>
A <code>boolean</code> expression also determines which subexpression is evaluated in the conditional <code>?&#32;:</code> operator <a href="expressions.doc.html#290293">(&#167;15.25)</a>.<p>
<a name="48458"></a>
Only <code>boolean</code> expressions can be used in control flow statements and as the first operand of the conditional operator <code>?&#32;:</code>. An integer <code>x</code> can be converted to a <code>boolean</code>, following the C language convention that any nonzero value is <code>true</code>, by the expression <code>x!=0</code>. An object reference <code>obj</code> can be converted to a <code>boolean</code>, following &#32;the C language convention that any reference other than <code>null</code> is <code>true</code>, by the expression <code>obj!=null</code>.<p>
<a name="9299"></a>
A cast of a <code>boolean</code> value to type <code>boolean</code> is allowed <a href="conversions.doc.html#25209">(&#167;5.1.1)</a>; no other casts on type <code>boolean</code> are allowed. A <code>boolean</code> can be converted to a string by string conversion <a href="conversions.doc.html#186035">(&#167;5.4)</a>.<p>
<a name="9317"></a>
<h2>4.3    Reference Types and Values</h2>
<a name="9664"></a>
There are three kinds of <em>reference types</em>: class types <a href="classes.doc.html#3857">(&#167;8)</a>, interface types <a href="interfaces.doc.html#238678">(&#167;9)</a>, and array types <a href="arrays.doc.html#27803">(&#167;10)</a>.<p>
<ul><pre>
<i>ReferenceType:
	ClassOrInterfaceType
	ArrayType

ClassOrInterfaceType:
	ClassType
	InterfaceType

ClassType:
	TypeName

InterfaceType:
	TypeName

ArrayType:
	Type<code> [ ]
	</i>
</code></pre></ul><a name="9678"></a>
Names are described in <a href="names.doc.html#48086">&#167;6</a>; type names in <a href="names.doc.html#106941">&#167;6.5</a> and, specifically, <a href="names.doc.html#73064">&#167;6.5.5</a>.<p>
<a name="87599"></a>
The sample code:
<blockquote><pre>class Point { int[] metrics; }
interface Move { void move(int deltax, int deltay); }
</pre></blockquote><a name="11032"></a>
declares a class type <code>Point</code>, an interface type <code>Move</code>, and uses an array type <code>int[]</code> (an array of <code>int</code>) to declare the field <code>metrics</code> of the class <code>Point</code>.<p>
<a name="12028"></a>
<h3>4.3.1    Objects</h3>
<a name="86707"></a>
An <em>object</em> is a <em>class</em> <em>instance</em> or an array.<p>
<a name="106237"></a>
The reference values (often just <em>references</em>) are <em>pointers </em>to these objects, and a special null reference, which refers to no object.<p>
<a name="49853"></a>
A class instance is explicitly created by a class instance creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a>. An array is explicitly created by an array creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a>.<p>
<a name="49899"></a>
A new class instance is implicitly created when the string concatenation operator + <a href="expressions.doc.html#39990">(&#167;15.18.1)</a> is used in an expression, resulting in a new object of type <code>String</code> (<a href="typesValues.doc.html#26992">&#167;4.3.3</a>). A new array object is implicitly created when an array initializer expression <a href="arrays.doc.html#11358">(&#167;10.6)</a> is evaluated; this can occur when a class or interface is initialized <a href="execution.doc.html#44557">(&#167;12.4)</a>, when a new instance of a class is created <a href="expressions.doc.html#41147">(&#167;15.9)</a>, or when a local variable declaration statement is executed <a href="statements.doc.html#5920">(&#167;14.4)</a>.<p>
<a name="49960"></a>
Many of these cases are illustrated in the following example:
<blockquote><pre>class Point {
	int x, y;
	Point() { System.out.println("default"); }
	Point(int x, int y) { this.x = x; this.y = y; }
	// A Point instance is explicitly created at class initialization time:
	static Point origin = new Point(0,0);
	// A String can be implicitly created by a + operator:
	public String toString() {
		return "(" + x + "," + y + ")";
	}
}
class Test {
	public static void main(String[] args) {
		// A Point is explicitly created using newInstance:
		Point p = null;
		try {
			p = (Point)Class.forName("Point").newInstance();
		} catch (Exception e) {
			System.out.println(e);
		}
		// An array is implicitly created by an array constructor:
		Point a[] = { new Point(0,0), new Point(1,1) };
		// Strings are implicitly created by + operators:
		System.out.println("p: " + p);
		System.out.println("a: { " + a[0] + ", "
										  &#32;+ a[1] + " }");
		// An array is explicitly created by an array creation expression:
		String sa[] = new String[2];
		sa[0] = "he"; sa[1] = "llo";
		System.out.println(sa[0] + sa[1]);
	}
}
</pre></blockquote><a name="87328"></a>
which produces the output:<p>
<blockquote><pre>default
p: (0,0)
a: { (0,0), (1,1) }
hello
</pre></blockquote><a name="49965"></a>
The operators on references to objects are:<p>
<ul><a name="31321"></a>
<li>Field access, using either a qualified name <a href="names.doc.html#104285">(&#167;6.6)</a> or a field access expression <a href="expressions.doc.html#41267">(&#167;15.11)</a>
<a name="31328"></a>
<li>Method invocation <a href="expressions.doc.html#20448">(&#167;15.12)</a>
<a name="31378"></a>
<li>The cast operator (<a href="conversions.doc.html#20232">&#167;5.5</a>, <a href="expressions.doc.html#238146">&#167;15.16</a>)
<a name="31345"></a>
<li>The string concatenation operator <code>+</code> <a href="expressions.doc.html#39990">(&#167;15.18.1)</a>, which, when given a <code>String</code> operand and a reference, will convert the reference to a <code>String</code> by invoking the <code>toString</code> method of the referenced object (using <code>"null"</code> if either the reference or the result of <code>toString</code> is a null reference), and then will produce a newly created <code>String</code> that is the concatenation of the two strings
<a name="31399"></a>
<li>The <code>instanceof</code> operator <a href="expressions.doc.html#80289">(&#167;15.20.2)</a>
<a name="31306"></a>
<li>The reference equality operators <code>==</code> and <code>!=</code> <a href="expressions.doc.html#236163">(&#167;15.21.3)</a>
<a name="19595"></a>
<li>The conditional operator <code>?&#32;:</code> <a href="expressions.doc.html#290293">(&#167;15.25)</a>.
</ul><a name="28239"></a>
There may be many references to the same object. Most objects have state, stored in the fields of objects that are instances of classes or in the variables that are the components of an array object. If two variables contain references to the same object, the state of the object can be modified using one variable's reference to the object, and then the altered state can be observed through the reference in the other variable.<p>
<a name="87600"></a>
The example program:
<blockquote><pre>class Value { int val; }
class Test {
	public static void main(String[] args) {
		int i1 = 3;
		int i2 = i1;
		i2 = 4;
		System.out.print("i1==" + i1);
		System.out.println(" but i2==" + i2);
		Value v1 = new Value();
		v1.val = 5;
		Value v2 = v1;
		v2.val = 6;
		System.out.print("v1.val==" + v1.val);
		System.out.println(" and v2.val==" + v2.val);
	}
}
</pre></blockquote><a name="11050"></a>
produces the output:<p>
<blockquote><pre>i1==3 but i2==4
v1.val==6 and v2.val==6
</pre></blockquote><a name="11053"></a>
because <code>v1.val</code> and <code>v2.val</code> reference the same instance variable <a href="typesValues.doc.html#28536">(&#167;4.5.3)</a> in the one <code>Value</code> object created by the only <code>new</code> expression, while <code>i1</code> and <code>i2</code> are different variables.<p>
<a name="17783"></a>
See <a href="arrays.doc.html#27803">&#167;10</a> and <a href="expressions.doc.html#46168">&#167;15.10</a> for examples of the creation and use of arrays.
<a name="17053"></a>
Each object has an associated lock <a href="memory.doc.html#28460">(&#167;17.13)</a>, which is used by <code>synchronized</code> methods <a href="classes.doc.html#78188">(&#167;8.4.3)</a> and the <code>synchronized</code> statement <a href="statements.doc.html#255769">(&#167;14.18)</a> to provide control over concurrent access to state by multiple threads (<a href="memory.doc.html#28457">&#167;17.12</a>).<p>
<a name="11055"></a>
<h3>4.3.2    The Class Object</h3>
<a name="26999"></a>
The class <code>Object</code> is a superclass <a href="classes.doc.html#15372">(&#167;8.1)</a> of all other classes. A variable of type <code>Object</code> can hold a reference to any object, whether it is an instance of a class or an array <a href="arrays.doc.html#27803">(&#167;10)</a>. All class and array types inherit the methods of class <code>Object</code>, which are summarized here:<p>
<blockquote><pre>package java.lang;
<a name="45609"></a>
public class Object {
<a name="51634"></a>	public final Class getClass() { . . . }
<a name="51635"></a>	public String toString() { . . . }
<a name="51636"></a>	public boolean equals(Object obj) { . . . }
<a name="51637"></a>	public int hashCode() { . . . }
<a name="51638"></a>	protected Object clone()
<a name="86088"></a>		throws CloneNotSupportedException { . . . }
<a name="87378"></a>	public final void wait()
		throws IllegalMonitorStateException,
			InterruptedException { . . . }
<a name="51641"></a>	public final void wait(long millis)
<a name="87381"></a>		throws IllegalMonitorStateException,
<a name="87383"></a>			InterruptedException { . . . }
<a name="51642"></a>	public final void wait(long millis, int nanos) { . . . }
<a name="87385"></a>		throws IllegalMonitorStateException,
<a name="87386"></a>			InterruptedException { . . . }
<a name="87373"></a>	public final void notify() { . . . }
<a name="87374"></a>		throws IllegalMonitorStateException
<a name="87387"></a>	public final void notifyAll() { . . . }
<a name="87389"></a>		throws IllegalMonitorStateException
<a name="51644"></a>	protected void finalize()
<a name="86090"></a>		throws Throwable { . . . }
<a name="51645"></a>}
</pre></blockquote><a name="45610"></a>
The members of <code>Object</code> are as follows:<p>
<ul><a name="12048"></a>
<li>The method <code>getClass</code> returns the <code>Class</code> object that represents the class of the object. A <code>Class</code> object exists for each reference type. It can be used, for example, to discover the fully qualified name of a class, its members, its immediate superclass, and any interfaces that it implements. A class method that is declared <code>synchronized</code> <a href="classes.doc.html#260369">(&#167;8.4.3.6)</a> synchronizes on the lock associated with the <code>Class</code> object of the class.
<a name="12066"></a>
<li>The method <code>toString</code> returns a <code>String</code> representation of the object.
<a name="12104"></a>
<li>The methods <code>equals</code> and <code>hashCode</code> are very useful in hashtables such as <code>java.util.Hashtable</code>. The method <code>equals</code> defines a notion of object equality, which is based on value, not reference, comparison.
<a name="12115"></a>
<li>The method <code>clone</code> is used to make a duplicate of an object.
<a name="12116"></a>
<li>The methods <code>wait</code>, <code>notify</code>, and <code>notifyAll</code> are used in concurrent programming using threads, as described in <a href="memory.doc.html#26250">&#167;17</a>.
<a name="12117"></a>
<li>The method <code>finalize</code> is run just before an object is destroyed and is described in <a href="execution.doc.html#44748">&#167;12.6</a>.
</ul><a name="26992"></a>
<h3>4.3.3    The Class String</h3>
<a name="27000"></a>
Instances of class <code>String</code> represent sequences of Unicode characters. A &#32;<code>String</code> object has a constant (unchanging) value. String literals <a href="lexical.doc.html#101083">(&#167;3.10.5)</a> are references to instances of class <code>String</code>.<p>
<a name="52188"></a>
The string concatenation operator <code>+</code> <a href="expressions.doc.html#39990">(&#167;15.18.1)</a> implicitly creates a new <code>String</code> object.<p>
<a name="97058"></a>
<h3>4.3.4    When Reference Types Are the Same</h3>
<a name="96897"></a>
Two reference types are the <em>same compile-time type</em> if they have the same binary name <a href="binaryComp.doc.html#44909">(&#167;13.1)</a>, in which case they are sometimes said to be the <em>same class</em> or the <em>same interface</em>.<p>
<a name="97070"></a>
At run time, several reference types with the same binary name may be loaded simultaneously by different class loaders. These types may or may not represent the same type declaration. Even if two such types do represent the same type declaration, they are considered distinct.<p>
<a name="96917"></a>
Two reference types are the <em>same run-time type</em> if:<p>
<ul><a name="86567"></a>
<li>They are both class or both interface types, are loaded by the same class loader, and have the same binary name <a href="binaryComp.doc.html#44909">(&#167;13.1)</a>, in which case they are sometimes said to be the <em>same run-time class</em> or the <em>same run-time interface</em>.
<a name="86576"></a>
<li>They are both array types, and their component types are the same run-time type<a href="arrays.doc.html#27803">(&#167;10)</a>.
</ul><a name="25948"></a>
<h2>4.4    Where Types Are Used</h2>
<a name="52309"></a>
Types are used when they appear in declarations or in certain expressions.<p>
<a name="85893"></a>
The following code fragment contains one or more instances of most kinds of usage of a type:
<blockquote><pre>import java.util.Random;
class MiscMath {
	int divisor;
	MiscMath(int divisor) {
		this.divisor = divisor;
	}
	float ratio(long l) {
		try {
			l /= divisor;
		} catch (Exception e) {
			if (e instanceof ArithmeticException)
				l = Long.MAX_VALUE;
			else
				l = 0;
		}
		return (float)l;
	}
	double gausser() {
		Random r = new Random();
		double[] val = new double[2];
		val[0] = r.nextGaussian();
		val[1] = r.nextGaussian();
		return (val[0] + val[1]) / 2;
	}
}
</pre></blockquote><a name="53860"></a>
In this example, types are used in declarations of the following:<p>
<ul><a name="53864"></a>
<li>Imported types <a href="packages.doc.html#70209">(&#167;7.5)</a>; here the type <code>Random</code>, imported from the type<code> java.util.Random</code> of the package <code>java.util</code>, is declared
<a name="49983"></a>
<li>Fields, which are the class variables and instance variables of classes <a href="classes.doc.html#40898">(&#167;8.3)</a>, and constants of interfaces <a href="interfaces.doc.html#78642">(&#167;9.3)</a>; here the field <code>divisor</code> in the class <code>MiscMath</code> &#32;is declared to be of type <code>int</code>
<a name="49990"></a>
<li>Method parameters <a href="classes.doc.html#38698">(&#167;8.4.1)</a>; here the parameter <code>l</code> of the method <code>ratio</code> is declared to be of type <code>long</code>
<a name="52378"></a>
<li>Method results <a href="classes.doc.html#40420">(&#167;8.4)</a>; here the result of the method <code>ratio</code> is declared to be of type <code>float</code>, and the result of the method <code>gausser</code> is declared to be of type <code>double</code>
<a name="38145"></a>
<li>Constructor parameters <a href="classes.doc.html#29488">(&#167;8.8.1)</a>; here the parameter of the constructor for<code> MiscMath</code> is declared to be of type <code>int</code>
<a name="12250"></a>
<li>Local variables (<a href="statements.doc.html#5920">&#167;14.4</a>, <a href="statements.doc.html#24588">&#167;14.13</a>); the local variables <code>r</code> and <code>val</code> of the method <code>gausser</code> are declared to be of types <code>Random</code> and <code>double[]</code> (array of <code>double</code>)
<a name="52411"></a>
<li>Exception handler parameters <a href="statements.doc.html#79311">(&#167;14.19)</a>; here the exception handler parameter <code>e</code> of the <code>catch</code> clause is declared to be of type <code>Exception</code>
</ul><a name="25979"></a>
and in expressions of the following kinds:<p>
<ul><a name="52468"></a>
<li>Class instance creations <a href="expressions.doc.html#41147">(&#167;15.9)</a>; here a local variable <code>r</code> of method <code>gausser</code> is initialized by a class instance creation expression that uses the type <code>Random </code>
<a name="96936"></a>
<li>Array creations <a href="expressions.doc.html#46168">(&#167;15.10)</a>; here the local variable <code>val</code> of method <code>gausser</code> is initialized by an array creation expression that creates an array of <code>double</code> with size 2
<a name="52427"></a>
<li>Casts <a href="expressions.doc.html#238146">(&#167;15.16)</a>; here the <code>return</code> statement of the method <code>ratio</code> uses the <code>float</code> type in a cast
<a name="25987"></a>
<li>The <code>instanceof</code> operator <a href="expressions.doc.html#80289">(&#167;15.20.2)</a>; here the <code>instanceof</code> operator tests whether <code>e</code> is assignment compatible with the type <code>ArithmeticException</code>
</ul><a name="18470"></a>
<h2>4.5    Variables</h2>
<a name="10872"></a>
A variable is a storage location and has an associated type, sometimes called its <em>compile-time type</em>, that is either a primitive type <a href="typesValues.doc.html#85587">(&#167;4.2)</a> or a reference type <a href="typesValues.doc.html#9317">(&#167;4.3)</a>. A variable always contains a value that is assignment compatible <a href="conversions.doc.html#184206">(&#167;5.2)</a> with its type. A variable's value is changed by an assignment <a href="expressions.doc.html#5281">(&#167;15.26)</a> or by a prefix or postfix <code>++</code> (increment) or <code>--</code> (decrement) operator (<a href="expressions.doc.html#39438">&#167;15.14.1</a>, <a href="expressions.doc.html#4987">&#167;15.14.2</a>, <a href="expressions.doc.html#39547">&#167;15.15.1</a>, <a href="expressions.doc.html#239136">&#167;15.15.2</a>).<p>
<a name="24555"></a>
Compatibility of the value of a variable with its type is guaranteed by the design of the Java programming language. Default values are compatible <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a> and all assignments to a variable are checked for assignment compatibility <a href="conversions.doc.html#184206">(&#167;5.2)</a>, usually at compile time, but, in a single case involving arrays, a run-time check is made <a href="arrays.doc.html#11430">(&#167;10.10)</a>.<p>
<a name="28344"></a>
<h3>4.5.1    Variables of Primitive Type</h3>
<a name="17088"></a>
A variable of a primitive type always holds a value of that exact primitive type.<p>
<a name="28345"></a>
<h3>4.5.2    Variables of Reference Type</h3>
<a name="10877"></a>
A variable of reference type can hold either of the following:<p>
<ul><a name="52494"></a>
<li>A null reference
<a name="52496"></a>
<li>A reference to any object <a href="typesValues.doc.html#9317">(&#167;4.3)</a> whose class <a href="typesValues.doc.html#24887">(&#167;4.5.6)</a> is assignment compatible <a href="conversions.doc.html#184206">(&#167;5.2)</a> with the type of the variable
</ul><a name="28536"></a>
<h3>4.5.3    Kinds of Variables</h3>
<a name="10883"></a>
There are seven kinds of variables:<p>
<ol>
<a name="10884"></a>
<li>A <em>class variable</em> is a field declared using the keyword <code>static</code> within a class declaration <a href="classes.doc.html#37544">(&#167;8.3.1.1)</a>, or with or without the keyword <code>static</code> within an interface declaration <a href="interfaces.doc.html#78642">(&#167;9.3)</a>. A class variable is created when its class or interface is prepared <a href="execution.doc.html#47979">(&#167;12.3.2)</a> and is initialized to a default value <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a>. The class variable effectively ceases to exist when its class or interface is unloaded <a href="execution.doc.html#74294">(&#167;12.7)</a>.
<a name="51516"></a>
<li>An <em>instance variable</em> is a field declared within a class declaration without using the keyword <code>static</code> <a href="classes.doc.html#37544">(&#167;8.3.1.1)</a>. If a class <i>T</i> has a field <i>a</i> that is an instance variable, then a new instance variable <i>a</i> is created and initialized to a default value <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a> as part of each newly created object of class <i>T</i> or of any class that is a subclass of <i>T</i> <a href="classes.doc.html#262560">(&#167;8.1.3)</a>. The instance variable effectively ceases to exist when the object of which it is a field is no longer referenced, after any necessary finalization of the object <a href="execution.doc.html#44748">(&#167;12.6)</a> has been completed.
<a name="10895"></a>
<li><em>Array components</em> are unnamed variables that are created and initialized to default values <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a> whenever a new object that is an array is created <a href="expressions.doc.html#46168">(&#167;15.10)</a>. The array components effectively cease to exist when the array is no longer referenced. See <a href="arrays.doc.html#27803">&#167;10</a> for a description of arrays.
<a name="24632"></a>
<li><em>Method parameters</em> <a href="classes.doc.html#38698">(&#167;8.4.1)</a> name argument values passed to a method. For every parameter declared in a method declaration, a new parameter variable is created each time that method is invoked <a href="expressions.doc.html#20448">(&#167;15.12)</a>. The new variable is initialized with the corresponding argument value from the method invocation. The method parameter effectively ceases to exist when the execution of the body of the method is complete.
<a name="24657"></a>
<li><em>Constructor parameters</em> <a href="classes.doc.html#29488">(&#167;8.8.1)</a> name argument values passed to a constructor. For every parameter declared in a constructor declaration, a new parameter variable is created each time a class instance creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a> or explicit constructor invocation <a href="classes.doc.html#78435">(&#167;8.8.5)</a> invokes that constructor. The new variable is initialized with the corresponding argument value from the creation expression or constructor invocation. The constructor parameter effectively ceases to exist when the execution of the body of the constructor is complete.
<a name="10903"></a>
<li>An <em>exception-handler parameter</em> is created each time an exception is caught by a <code>catch</code> clause of a <code>try</code> statement <a href="statements.doc.html#79311">(&#167;14.19)</a>. The new variable is initialized with the actual object associated with the exception (<a href="exceptions.doc.html#44153">&#167;11.3</a>, <a href="statements.doc.html#237350">&#167;14.17</a>). The exception-handler parameter effectively ceases to exist when execution of the block associated with the <code>catch</code> clause is complete.
<a name="24801"></a>
<li><em>Local variables</em> are declared by local variable declaration statements <a href="statements.doc.html#5920">(&#167;14.4)</a>. Whenever the flow of control enters a block <a href="statements.doc.html#246838">(&#167;14.2)</a> or <code>for</code> statement <a href="statements.doc.html#24588">(&#167;14.13)</a>, a new variable is created for each local variable declared in a local variable declaration statement immediately contained within that block or <code>for</code> statement. A local variable declaration statement may contain an expression which initializes the variable. The local variable with an initializing expression is not initialized, however, until the local variable declaration statement that declares it is executed. (The rules of definite assignment <a href="defAssign.doc.html#25979">(&#167;16)</a> prevent the value of a local variable from being used before it has been initialized or otherwise assigned a value.) The local variable effectively ceases to exist when the execution of the block or <code>for</code> statement is complete.
</ol>
Were it not for one exceptional situation, a local variable could always be regarded as being created when its local variable declaration statement is executed. The exceptional situation involves the <code>switch</code> statement <a href="statements.doc.html#35518">(&#167;14.10)</a>, where it is possible for control to enter a block but bypass execution of a local variable declaration statement. Because of the restrictions imposed by the rules of definite assignment <a href="defAssign.doc.html#">(&#167;16)</a>, however, the local variable declared by such a bypassed local variable declaration statement cannot be used before it has been definitely assigned a value by an assignment expression <a href="expressions.doc.html#5281">(&#167;15.26)</a>. 
<a name="24836"></a>
The following example contains several different kinds of variables:
<blockquote><pre>
class Point {
	static int numPoints;		// numPoints is a class variable
	int x, y;			// x and y are instance variables
	int[] w = new int[10];		// w[0] is an array component
	int setX(int x) {		// x is a method parameter
		int oldx = this.x;	// oldx is a local variable
		this.x = x;
		return oldx;
	}
}
</pre></blockquote><a name="10931"></a>
<h3>4.5.4    final Variables</h3>
<a name="96639"></a>
A variable can be declared <code>final</code>. A final variable may only be assigned to once. It is a compile time error if a final variable is assigned to unless it is definitely unassigned <a href="defAssign.doc.html#25979">(&#167;16)</a> immediately prior to the assignment.<p>
<a name="96971"></a>
A <em>blank final</em> is a final variable whose declaration lacks an initializer. <p>
<a name="96975"></a>
Once a <code>final</code> variable has been assigned, it always contains the same value. If a <code>final</code> variable holds a reference to an object, then the state of the object may be changed by operations on the object, but the variable will always refer to the same object. This applies also to arrays, because arrays are objects; if a <code>final</code> variable holds a reference to an array, then the components of the array may be changed by operations on the array, but the variable will always refer to the same array.<p>
<a name="103462"></a>
Declaring a variable <code>final</code> can serve as useful documentation that its value will not change and can help avoid programming errors.
<a name="96976"></a>
<p>In the example:
<blockquote><pre>class Point {
	int x, y;
	int useCount;
	Point(int x, int y) { this.x = x; this.y = y; }
	final static Point origin = new Point(0, 0);
}
</pre></blockquote><a name="96596"></a>
the class <code>Point</code> declares a <code>final</code> class variable <code>origin</code>. The <code>origin</code> variable holds a reference to an object that is an instance of class <code>Point</code> whose coordinates are (0, 0). The value of the variable <code>Point.origin</code> can never change, so it always refers to the same <code>Point</code> object, the one created by its initializer. However, an operation on this <code>Point</code> object might change its state-for example, modifying its <code>useCount</code> or even, misleadingly, its <code>x</code> or <code>y</code> coordinate.<p>
<a name="96595"></a>
<h3>4.5.5    Initial Values of Variables</h3>
<a name="10935"></a>
Every variable in a program must have a value before its value is used:<p>
<ul><a name="10946"></a>
<li>Each class variable, instance variable, or array component is initialized with a <em>default value</em> when it is created (<a href="expressions.doc.html#41147">&#167;15.9</a>, <a href="expressions.doc.html#46168">&#167;15.10</a>):
<ul>
<a name="10947"></a>
<li>For type <code>byte</code>, the default value is zero, that is, the value of <code>(byte)0</code>.
<a name="10948"></a>
<li>For type <code>short</code>, the default value is zero, that is, the value of <code>(short)0</code>.
<a name="10949"></a>
<li>For type <code>int</code>, the default value is zero, that is, <code>0</code>.
<a name="10950"></a>
<li>For type <code>long</code>, the default value is zero, that is, <code>0L</code>.
<a name="10951"></a>
<li>For type <code>float</code>, the default value is positive zero, that is, <code>0.0f</code>.
<a name="46977"></a>
<li>For type <code>double</code>, the default value is positive zero, that is, <code>0.0d</code>.
<a name="46978"></a>
<li>For type <code>char</code>, the default value is the null character, that is, <code>'\u0000'</code>.
<a name="46979"></a>
<li>For type <code>boolean</code>, the default value is <code>false</code>.
<a name="10955"></a>
<li>For all reference types <a href="typesValues.doc.html#9317">(&#167;4.3)</a>, the default value is <code>null</code>.
</ul>
<a name="11353"></a>
<li>Each method parameter <a href="classes.doc.html#38698">(&#167;8.4.1)</a> is initialized to the corresponding argument value provided by the invoker of the method <a href="expressions.doc.html#20448">(&#167;15.12)</a>.
<a name="38160"></a>
<li>Each constructor parameter <a href="classes.doc.html#29488">(&#167;8.8.1)</a> is initialized to the corresponding argument value provided by a class instance creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a> or explicit constructor invocation <a href="classes.doc.html#78435">(&#167;8.8.5)</a>.
<a name="11354"></a>
<li>An exception-handler parameter <a href="statements.doc.html#79311">(&#167;14.19)</a> is initialized to the thrown object representing the exception (<a href="exceptions.doc.html#44153">&#167;11.3</a>, <a href="statements.doc.html#237350">&#167;14.17</a>). 
<a name="11569"></a>
<li>A local variable (<a href="statements.doc.html#5920">&#167;14.4</a>, <a href="statements.doc.html#24588">&#167;14.13</a>) must be explicitly given a value before it is used, by either initialization <a href="statements.doc.html#5920">(&#167;14.4)</a> or assignment <a href="expressions.doc.html#5281">(&#167;15.26)</a>, in a way that can be verified by the compiler using the rules for definite assignment <a href="defAssign.doc.html#25979">(&#167;16)</a>.
</ul><a name="30962"></a>
The example program:<p>
<blockquote><pre>class Point {
	static int npoints;
	int x, y;
	Point root;
}
class Test {
	public static void main(String[] args) {
		System.out.println("npoints=" + Point.npoints);
		Point p = new Point();
		System.out.println("p.x=" + p.x + ", p.y=" + p.y);
		System.out.println("p.root=" + p.root);
	}
}
</pre></blockquote><a name="12324"></a>
prints:<p>
<blockquote><pre>npoints=0
p.x=0, p.y=0
p.root=null
</pre></blockquote><a name="24882"></a>
illustrating the default initialization of <code>npoints</code>, which occurs when the class <code>Point</code> is prepared <a href="execution.doc.html#47979">(&#167;12.3.2)</a>, and the default initialization of <code>x</code>, <code>y</code>, and <code>root</code>, which occurs when a new <code>Point</code> is instantiated. See <a href="execution.doc.html#44410">&#167;12</a> for a full description of all aspects of loading, linking, and initialization of classes and interfaces, plus a description of the instantiation of classes to make new class instances.<p>
<a name="24887"></a>
<h3>4.5.6    Types, Classes, and Interfaces</h3>
<a name="24888"></a>
In the Java programming language, every variable and every expression has a type that can be determined at compile time. The type may be a primitive type or a reference type. Reference types include class types and interface types. Reference types are introduced by type declarations, which include class declarations <a href="classes.doc.html#15372">(&#167;8.1)</a> and interface declarations <a href="interfaces.doc.html#35470">(&#167;9.1)</a>. We often use the term <em>type</em> to refer to either a class or an interface.<p>
<a name="97724"></a>
Every object belongs to some particular class: the class that was mentioned in the creation expression that produced the object, the class whose <code>Class</code> object was used to invoke a reflective method to produce the object, or the <code>String</code> class for objects implicitly created by the string concatenation operator <code>+</code> <a href="expressions.doc.html#39990">(&#167;15.18.1)</a>. This class is called the <em>class of the object</em>. (Arrays also have a class, as described at the end of this section.) An object is said to be an instance of its class and of all superclasses of its class.<p>
<a name="96875"></a>
Sometimes a variable or expression is said to have a "run-time type". This refers to the class of the object referred to by the value of the variable or expression at run time, assuming that the value is not <code>null</code>. <p>
<a name="96880"></a>
The compile time type of a variable is always declared, and the compile time type of an expression can be deduced at compile time. The compile time type limits the possible values that the variable can hold or the expression can produce at run time. If a run-time value is a reference that is not <code>null</code>, it refers to an object or array that has a class, and that class will necessarily be compatible with the compile-time type.<p>
<a name="24895"></a>
Even though a variable or expression may have a compile-time type that is an interface type, there are no instances of interfaces. A variable or expression whose type is an interface type can reference any object whose class implements <a href="classes.doc.html#34031">(&#167;8.1.4)</a> that interface.<p>
<a name="24918"></a>
Here is an example of creating new objects and of the distinction between the type of a variable and the class of an object:
<blockquote><pre>public interface Colorable {
	void setColor(byte r, byte g, byte b);
}
class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {
	byte r, g, b;
	public void setColor(byte rv, byte gv, byte bv) {
		r = rv; g = gv; b = bv;
	}
}
class Test {
	public static void main(String[] args) {
		Point p = new Point();
		ColoredPoint cp = new ColoredPoint();
		p = cp;
		Colorable c = cp;
	}
}
</pre></blockquote><a name="52612"></a>
In this example:<p>
<ul><a name="52613"></a>
<li>The local variable <code>p</code> of the method <code>main</code> of class <code>Test</code> has type <code>Point</code> and is initially assigned a reference to a new instance of class <code>Point</code>.
<a name="52614"></a>
<li>The local variable <code>cp</code> similarly has as its type <code>ColoredPoint</code>, and is initially assigned a reference to a new instance of class <code>ColoredPoint</code>.
<a name="52615"></a>
<li>The assignment of the value of <code>cp</code> to the variable <code>p</code> causes <code>p</code> to hold a reference to a <code>ColoredPoint</code> object. This is permitted because <code>ColoredPoint</code> is a subclass of <code>Point</code>, so the class <code>ColoredPoint</code> is assignment compatible <a href="conversions.doc.html#184206">(&#167;5.2)</a> with the type <code>Point</code>. A <code>ColoredPoint</code> object includes support for all the methods of a <code>Point</code>. In addition to its particular fields <code>r</code>, <code>g</code>, and <code>b</code>, it has the fields of class <code>Point</code>, namely <code>x</code> and <code>y</code>.
<a name="52586"></a>
<li>The local variable <code>c</code> has as its type the interface type <code>Colorable</code>, so it can hold a reference to any object whose class implements <code>Colorable</code>; specifically, it can hold a reference to a <code>ColoredPoint</code>.
<a name="24972"></a>
<li>Note that an expression such as "<code>new Colorable()</code>" is not valid because it is not possible to create an instance of an interface, only of a class.
</ul><a name="24976"></a>
Every array also has a class; the method <code>getClass</code>, when invoked for an array object, will return a class object (of class <code>Class</code>) that represents the class of the array. <p>
<a name="103397"></a>
The classes for arrays have strange names that are not valid identifiers; for example, the class for an array of <code>int</code> components has the name "<code>[I</code>" and so the value of the expression:
<blockquote><pre>new int[10].getClass().getName()
</pre></blockquote><a name="103415"></a>
is the string <code>"[I"</code>; see the specification of <code>Class.getName</code> for details.<p>


<hr>
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="lexical.doc.html">Prev</a> | <a href="conversions.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<i><a href="jcopyright.doc.html">Copyright</a> &#169 2000 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jls@java.sun.com">jls@java.sun.com</a>
</font>
</body></html>
