<html>
<head>
<title> Threads and Locks</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="defAssign.doc.html">Prev</a> | <a href="syntax.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<hr><br>
 
<a name="26250"></a>
<p><strong>
CHAPTER
 17 </strong></p>
<a name="30206"></a>
<h1>Threads and Locks</h1>
<hr><p>
<a name="44127"></a>
While most of the discussion in the preceding chapters is concerned only with the behavior of code as executed a single statement or expression at a time, that is, by a single <em>thread</em>, each Java virtual machine can support many threads of execution at once. These threads independently execute code that operates on values and objects residing in a shared main memory. Threads may be supported by having many hardware processors, by time-slicing a single hardware processor, or by time-slicing many hardware processors.<p>
<a name="28270"></a>
The Java programming language supports the coding of programs that, though concurrent, still exhibit deterministic behavior, by providing mechanisms for <em>synchronizing</em> the concurrent activity of threads. To synchronize threads, the Java programming language uses <em>monitors</em>, which are a high-level mechanism for allowing only one thread at a time to execute a region of code protected by the monitor. The behavior of monitors is explained in terms of <em>locks</em>; there is a lock associated with each object.<p>
<a name="29608"></a>
The <code>synchronized</code> statement <a href="statements.doc.html#255769">(&#167;14.18)</a> performs two special actions relevant only to multithreaded operation: (1) after computing a reference to an object but before executing its body, it <em>locks</em> a lock associated with the object, and (2) after execution of the body has completed, either normally or abruptly, it <em>unlocks</em> that same lock. As a convenience, a method may be declared <code>synchronized</code>; such a method behaves as if its body were contained in a <code>synchronized</code> statement.<p>
<a name="29615"></a>
The methods <code>wait</code>, <code>notify</code>, and <code>notifyAll</code> of class <code>Object</code> support an efficient transfer of control from one thread to another. Rather than simply "spinning" (repeatedly locking and unlocking an object to see whether some internal state has changed), which consumes &#32;computational effort, a thread can suspend itself using <code>wait</code> until such time as another thread awakens it using <code>notify</code>. This is especially appropriate in situations where threads have a producer-consumer relationship (actively cooperating on a common goal) rather than a mutual exclusion relationship (trying to avoid conflicts while sharing a common resource).<p>
<a name="28284"></a>
As a thread executes code, it carries out a sequence of actions. A thread may <em>use</em> the value of a variable or <em>assign</em> it a new value. (Other actions include arithmetic operations, conditional tests, and method invocations, but these do not involve variables directly.) If two or more concurrent threads act on a shared variable, there is a possibility that the actions on the variable will produce timing-dependent results. This dependence on timing is inherent in concurrent programming, producing one of the few places in the language where the result of executing a program is not determined solely by this specification.<p>
<a name="28285"></a>
Each thread has a working memory, in which it may keep copies of the values of variables from the main memory that is shared between all threads. To access a shared variable, a thread usually first obtains a lock and flushes its working memory. This guarantees that shared values will thereafter be loaded from the shared main memory to the threads working memory. When a thread unlocks a lock it guarantees the values it holds in its working memory will be written back to the main memory.<p>
<a name="28524"></a>
This chapter explains the interaction of threads with the main memory, and thus with each other, in terms of certain low-level actions. There are rules about the order in which these actions may occur. These rules impose constraints on any implementation of the Java programming language, and a programmer may rely on the rules to predict the possible behaviors of a concurrent program. The rules do, however, intentionally give the implementor certain freedoms; the intent is to permit certain standard hardware and software techniques that can greatly improve the speed and efficiency of concurrent code.<p>
<a name="28527"></a>
Briefly put, these are the important consequences of the rules:<p>
<ul><a name="28549"></a>
<li>Proper use of synchronization constructs will allow reliable transmission of values or sets of values from one thread to another through shared variables.
<a name="28553"></a>
<li>When a thread uses the value of a variable, the value it obtains is in fact a value stored into the variable by that thread or by some other thread. This is true even if the program does not contain code for proper synchronization. For example, if two threads store references to different objects into the same reference value, the variable will subsequently contain a reference to one object or the other, not a reference to some other object or a corrupted reference value. (There is a special exception for <code>long</code> and <code>double</code> values; see <a href="memory.doc.html#28733">&#167;17.4</a>.)
<a name="28556"></a>
<li>In the absence of explicit synchronization, an implementation is free to update the main memory in an order that may be surprising. Therefore the programmer who prefers to avoid surprises should use explicit synchronization.
</ul><a name="28287"></a>
<h2>17.1    Terminology and Framework</h2>
<a name="28288"></a>
A <em>variable</em> is any location within a program that may be stored into. This includes not only class variables and instance variables but also components of arrays. Variables are kept in a <em>main memory</em> that is shared by all threads. Because it is impossible for one thread to access parameters or local variables of another thread, it doesn't matter whether parameters and local variables are thought of as residing in the shared main memory or in the working memory of the thread that owns them.<p>
<a name="45672"></a>
Every thread has a <em>working memory</em> in which it keeps its own <em>working copy</em> of variables that it must use or assign. As the thread executes a program, it operates on these working copies. The main memory contains the <em>master copy</em> of every variable. There are rules about when a thread is permitted or required to transfer the contents of its working copy of a variable into the master copy or vice versa.<p>
<a name="28291"></a>
The main memory also contains <em>locks</em>; there is one lock associated with each object. Threads may compete to acquire a lock.<p>
<a name="28292"></a>
For the purposes of this chapter, the verbs <em>use</em>, <em>assign</em>, <em>load</em>, <em>store</em>, <em>lock</em>, and <em>unlock</em> name <em>actions</em> that a thread can perform. The verbs <em>read</em>, <em>write</em>, <em>lock</em>, and <em>unlock</em> name actions that the main memory subsystem can perform. Each of these actions is <em>atomic</em> (indivisible). <p>
<a name="28293"></a>
A <em>use</em> or <em>assign</em> action is a tightly coupled interaction between a thread's execution engine and the thread's working memory. A <em>lock</em> or <em>unlock</em> action is a tightly coupled interaction between a thread's execution engine and the main memory. But the transfer of data between the main memory and a thread's working memory is loosely coupled. When data is copied from the main memory to a working memory, two actions must occur: a <em>read</em> action performed by the main memory followed some time later by a corresponding <em>load</em> action performed by the working memory. When data is copied from a working memory to the main memory, two actions must occur: a <em>store</em> action performed by the working memory followed some time later by a corresponding <em>write</em> action performed by the main memory. There may be some transit time between main memory and a working memory, and the transit time may be different for each transaction; thus actions initiated by a thread on different variables may viewed by another thread as occurring in a different order. For each variable, however, the actions in main memory on behalf of any one thread are performed in the same order as the corresponding actions by that thread. (This is explained in greater detail below.)<p>
<a name="28294"></a>
A single thread issues a stream of <em>use</em>, <em>assign</em>, <em>lock</em>, and <em>unlock</em> actions as dictated by the semantics of the program it is executing. The underlying implementation is then required additionally to perform appropriate <em>load</em>, <em>store</em>, <em>read</em>, and <em>write</em> actions so as to obey a certain set of constraints, explained below. If the implementation correctly follows these rules and the application programmer follows certain other rules of programming, then data can be reliably transferred between threads through shared variables. The rules are designed to be "tight" enough to make this possible but "loose" enough to allow hardware and software designers considerable freedom to improve speed and throughput through such mechanisms as registers, queues, and caches.<p>
<a name="28295"></a>
Here are the detailed definitions of each of the actions:<p>
<ul><a name="28296"></a>
<li>A <em>use</em> action (by a thread) transfers the contents of the thread's working copy of a variable to the thread's execution engine. This action is performed whenever a thread executes a virtual machine instruction that uses the value of a variable.
<a name="28297"></a>
<li>An <em>assign</em> action (by a thread) transfers a value from the thread's execution engine into the thread's working copy of a variable. This action is performed whenever a thread executes a virtual machine instruction that assigns to a variable.
<a name="28298"></a>
<li>A <em>read</em> action (by the main memory) transmits the contents of the master copy of a variable to a thread's working memory for use by a later <em>load</em> action.
<a name="28299"></a>
<li>A <em>load </em>action (by a thread) puts a value transmitted from main memory by a <em>read</em> action into the thread's working copy of a variable.
<a name="28300"></a>
<li>A <em>store </em>action (by a thread) transmits the contents of the thread's working copy of a variable to main memory for use by a later <em>write</em> action.
<a name="28301"></a>
<li>A <em>write</em> action (by the main memory) puts a value transmitted from the thread's working memory by a <em>store</em> action into the master copy of a variable in main memory.
<a name="28303"></a>
<li>A <em>lock</em> action (by a thread tightly synchronized with main memory) causes a thread to acquire one claim on a particular lock.
<a name="28304"></a>
<li>An <em>unlock</em> action (by a thread tightly synchronized with main memory) causes a thread to release one claim on a particular lock.
</ul><a name="28305"></a>
Thus the interaction of a thread with a variable over time consists of a sequence of <em>use</em>, <em>assign</em>, <em>load</em>, and <em>store</em> actions. Main memory performs a <em>read</em> action for every <em>load</em> and a <em>write</em> action for every <em>store</em>. A thread's interactions with a lock over time consists of a sequence of <em>lock</em> and <em>unlock</em> actions. All the globally visible behavior of a thread thus comprises all the thread's actions on variables and locks.<p>
<a name="28920"></a>
<h2>17.2    Execution Order</h2>
<a name="28957"></a>
The rules of execution order constrain the order in which certain events may occur. There are four general constraints on the relationships among actions:<p>
<ul><a name="28958"></a>
<li>The actions performed by any one thread are totally ordered; that is, for any two actions performed by a thread, one action precedes the other.
<a name="28976"></a>
<li>The actions performed by the main memory for any one variable are totally ordered; that is, for any two actions performed by the main memory on the same variable, one action precedes the other.
<a name="28980"></a>
<li>The actions performed by the main memory for any one lock are totally ordered; that is, for any two actions performed by the main memory on the same lock, one action precedes the other.
<a name="28959"></a>
<li>It is not permitted for an action to follow itself.
</ul><a name="28990"></a>
The last rule may seem trivial, but it does need to be stated separately and explicitly for completeness. Without it, it would be possible to propose a set of actions by two or more threads and precedence relationships among the actions that would satisfy all the other rules but would require an action to follow itself.<p>
<a name="28951"></a>
Threads do not interact directly; they communicate only through the shared main memory. The relationships between the actions of a thread and the actions of main memory are constrained in three ways: <p>
<ul><a name="28923"></a>
<li>Each <em>lock</em> or <em>unlock</em> action is performed jointly by some thread and the main memory.
<a name="28924"></a>
<li>Each <em>load</em> action by a thread is uniquely paired with a <em>read</em> action by the main memory such that the <em>load</em> action follows the <em>read</em> action.
<a name="28925"></a>
<li>Each <em>store</em> action by a thread is uniquely paired with a <em>write</em> action by the main memory such that the <em>write</em> action follows the <em>store</em> action.
</ul><a name="45036"></a>
Most of the rules in the following sections further constrain the order in which certain actions take place. A rule may state that one action must precede or follow some other action. Note that this relationship is transitive: if action <i>A</i> must precede action <i>B</i>, and <i>B</i> must precede <i>C</i>, then <i>A</i> must precede <i>C</i>. The programmer must remember that these rules are the <em>only</em> constraints on the ordering of actions; if no rule or combination of rules implies that action <i>A</i> must precede action <i>B</i>, then an implementation is free to perform action <i>B</i> before action <i>A</i>, or to perform action <i>B</i> concurrently with action <i>A</i>. This freedom can be the key to good performance. Conversely, an implementation is not required to take advantage of all the freedoms given it.<p>
<a name="28927"></a>
In the rules that follow, the phrasing "<i>B</i> must intervene between <i>A</i> and <i>C</i>" means that action <i>B</i> must follow action <i>A</i> and precede action <i>C</i>.<p>
<a name="28654"></a>
<h2>17.3    Rules about Variables</h2>
<a name="28308"></a>
Let <i>T</i> be a thread and <i>V</i> be a variable. There are certain constraints on the actions performed by <i>T</i> with respect to <i>V</i>:<p>
<ul><a name="28309"></a>
<li>An <em>use</em> or <em>assign</em> by <i>T</i> of <i>V</i> is permitted only when dictated by execution by <i>T</i> of the program according to the Java programming language's execution model. For example, an occurrence of <i>V</i> as an operand of the <code>+</code> operator requires that a single <em>use</em> action occur on <i>V</i>; an occurrence of <i>V</i> as the left-hand operand of the assignment operator <code>=</code> requires that a single <em>assign</em> action occur. All <em>use</em> and <em>assign</em> actions by a given thread must occur in the order specified by the program being executed by the thread. If the following rules forbid <i>T</i> to perform a required <em>use</em> as its next action, it may be necessary for <i>T</i> to perform a <em>load </em>first in order to make progress.
<a name="28310"></a>
<li>A <em>store</em> action by <i>T</i> on <i>V</i> must intervene between an <em>assign</em> by <i>T</i> of <i>V</i> and a subsequent <em>load</em> by <i>T</i> of <i>V</i>. (Less formally: a thread is not permitted to lose its most recent assign.)
<a name="28312"></a>
<li>An <em>assign</em> action by <i>T</i> on <i>V</i> must intervene between a <em>load</em> or <em>store</em> by <i>T</i> of <i>V</i> and a subsequent <em>store</em> by <i>T</i> of <i>V</i>. (Less formally: a thread is not permitted to write data from its working memory back to main memory for no reason.)
<a name="28313"></a>
<li>After a thread is created, it must perform an <em>assign</em> or <em>load</em> action on a variable before performing a <em>use</em> or <em>store</em> action on that variable. (Less formally: a new thread starts with an empty working memory.)
<a name="28314"></a>
<li>After a variable is created, every thread must perform an <em>assign</em> or <em>load</em> action on that variable before performing a <em>use</em> or <em>store</em> action on that variable. (Less formally: a new variable is created only in main memory and is not initially in any thread's working memory.)
</ul><a name="28315"></a>
Provided that all the constraints above and below are obeyed, a <em>load</em> or <em>store</em> action may be issued at any time by any thread on any variable, at the whim of the implementation.<p>
<a name="28317"></a>
There are also certain constraints on the <em>read</em> and <em>write</em> actions performed by main memory:<p>
<ul><a name="28318"></a>
<li>For every <em>load</em> action performed by any thread <i>T</i> on its working copy of a variable <i>V</i>, there must be a corresponding preceding <em>read</em> action by the main memory on the master copy of <i>V</i>, and the <em>load</em> action must put into the working copy the data transmitted by the corresponding <em>read</em> action.
<a name="28319"></a>
<li>For every <em>store</em> action performed by any thread <i>T</i> on its working copy of a variable <i>V</i>, there must be a corresponding following <em>write</em> action by the main memory on the master copy of <i>V</i>, and the <em>write</em> action must put into the master copy the data transmitted by the corresponding <em>store</em> action.
<a name="28786"></a>
<li>Let action <i>A</i> be a <em>load</em> or <em>store</em> by thread <i>T</i> on variable <i>V</i>, and let action <i>P</i> be the corresponding <em>read</em> or <em>write</em> by the main memory on variable <i>V</i>. Similarly, let action <i>B</i> be some other <em>load</em> or <em>store</em> by thread <i>T</i> on that same variable <i>V</i>, and let action <i>Q</i> be the corresponding <em>read</em> or <em>write</em> by the main memory on variable <i>V</i>. If <i>A</i> precedes <i>B</i>, then <i>P</i> must precede <i>Q</i>. (Less formally: actions on the master copy of any given variable on behalf of a thread are performed by the main memory in exactly the order that the thread requested.)
</ul><a name="28817"></a>
Note that this last rule applies <em>only</em> to actions by a thread on the <em>same</em> variable. However, there is a more stringent rule for <code>volatile</code> variables <a href="memory.doc.html#28330">(&#167;17.7)</a>.<p>
<a name="28733"></a>
<h2>17.4    Nonatomic Treatment of double and long</h2>
<a name="55837"></a>
If a <code>double</code> or <code>long</code> variable is not declared <code>volatile</code>, then for the purposes of <em>load</em>, <em>store</em>, <em>read</em>, and <em>write</em> actions they are treated as if they were two variables of 32 bits each: wherever the rules require one of these actions, two such actions are performed, one for each 32-bit half. The manner in which the 64 bits of a <code>double</code> or <code>long</code> variable are encoded into two 32-bit quantities is implementation-dependent. The <em>load</em>, <em>store</em>, <em>read</em>, and <em>write</em> actions on <code>volatile</code> variables are atomic, even if the type of the variable is <code>double</code> or <code>long</code>.<p>
<a name="28747"></a>
This matters only because a <em>read</em> or <em>write</em> of a <code>double</code> or <code>long</code> variable may be handled by an actual main memory as two 32-bit <em>read</em> or <em>write</em> actions that may be separated in time, with other actions coming between them. Consequently, if two threads concurrently assign distinct values to the same shared non-<code>volatile</code> <code>double</code> or <code>long</code> variable, a subsequent use of that variable may obtain a value that is not equal to either of the assigned values, but some implementation-dependent mixture of the two values.<p>
<a name="28746"></a>
An implementation is free to implement <em>load</em>, <em>store</em>, <em>read</em>, and <em>write</em> actions for <code>double</code> and <code>long</code> values as atomic 64-bit actions; in fact, this is strongly encouraged. The model divides them into 32-bit halves for the sake of several currently popular microprocessors that fail to provide efficient atomic memory transactions on 64-bit quantities. It would have been simpler to define all memory transactions on single variables as atomic; this more complex definition is a pragmatic concession to current hardware practice. In the future this concession may be eliminated. Meanwhile, programmers are cautioned always to explicitly synchronize access to shared <code>double</code> and <code>long</code> variables.<p>
<a name="28320"></a>
<h2>17.5    Rules about Locks</h2>
<a name="28321"></a>
Let <i>T</i> be a thread and <i>L</i> be a lock. There are certain constraints on the actions performed by <i>T</i> with respect to <i>L</i>:<p>
<ul><a name="28322"></a>
<li>A <em>lock</em> action by <i>T</i> on <i>L</i> may occur only if, for every thread <i>S</i> other than <i>T</i>, the number of preceding <em>unlock</em> actions by <i>S</i> on <i>L</i> equals the number of preceding <em>lock</em> actions by <i>S</i> on <i>L</i>. (Less formally: only one thread at a time is permitted to lay claim to a lock, and moreover a thread may acquire the same lock multiple times and doesn't relinquish ownership of it until a matching number of <em>unlock</em> actions have been performed.)
<a name="28763"></a>
<li>An <em>unlock</em> action by thread <i>T</i> on lock <i>L</i> may occur only if the number of preceding <em>unlock</em> actions by <i>T</i> on <i>L</i> is strictly less than the number of preceding <em>lock</em> actions by <i>T</i> on <i>L</i>. (Less formally: a thread is not permitted to unlock a lock it doesn't own.)
</ul><a name="28324"></a>
With respect to a lock, the <em>lock</em> and <em>unlock</em> actions performed by all the threads are performed in some total sequential order. This total order must be consistent with the total order on the actions of each thread.<p>
<a name="28325"></a>
<h2>17.6    Rules about the Interaction of Locks and Variables</h2>
<a name="28326"></a>
Let <i>T</i> be any thread, let <i>V</i> be any variable, and let <i>L</i> be any lock. There are certain constraints on the actions performed by <i>T</i> with respect to <i>V</i> and <i>L</i>:<p>
<ul><a name="28327"></a>
<li>Between an <em>assign</em> action by <i>T</i> on <i>V</i> and a subsequent <em>unlock</em> action by <i>T</i> on <i>L</i>, a <em>store</em> action by <i>T</i> on <i>V</i> must intervene; moreover, the <em>write</em> action corresponding to that <em>store</em> must precede the <em>unlock</em> action, as seen by main memory. (Less formally: if a thread is to perform an <em>unlock</em> action on <em>any</em> lock, it must first copy <em>all</em> assigned values in its working memory back out to main memory.)
<a name="28328"></a>
<li>Between a <em>lock</em> action by <i>T</i> on <i>L</i> and a subsequent <em>use</em> or <em>store</em> action by <i>T</i> on a variable <i>V</i>, an <em>assign</em> or <em>load</em> action on <i>V</i> must intervene; moreover, if it is a <em>load</em> action, then the <em>read</em> action corresponding to that <em>load</em> must follow the <em>lock</em> action, as seen by main memory. (Less formally: a <em>lock</em> action acts as if it flushes <em>all</em> variables from the thread's working memory; before use they must be assigned or loaded from main memory.)
</ul><a name="28330"></a>
<h2>17.7    Rules for Volatile Variables</h2>
<a name="28331"></a>
If a variable is declared <code>volatile</code>, then additional constraints apply to the actions of each thread. <p>
<a name="55958"></a>
Let <i>T</i> be a thread and let <i>V</i> and <i>W</i> be volatile variables.<p>
<ul><a name="28332"></a>
<li>A <em>use</em> action by <i>T</i> on <i>V</i> is permitted only if the previous action by <i>T</i> on <i>V</i> was <em>load</em>, and a <em>load</em> action by <i>T</i> on <i>V</i> is permitted only if the next action by <i>T</i> on <i>V</i> is <em>use</em>. The <em>use</em> action is said to be "associated" with the <em>read</em> action that corresponds to the <em>load</em>.
<a name="28333"></a>
<li>A <em>store</em> action by <i>T</i> on <i>V</i> is permitted only if the previous action by <i>T</i> on <i>V</i> was <em>assign</em>, and an <em>assign</em> action by <i>T</i> on <i>V</i><i></i> is permitted only if the next action by <i>T</i> on <i>V</i> is <em>store</em>. The <em>assign</em> action is said to be "associated" with the <em>write</em> action that corresponds to the <em>store</em>.
<a name="45390"></a>
<li>Let action <i>A</i> be a <em>use</em> or <em>assign</em> by thread <i>T</i> on variable <i>V</i>, let action <i>F</i> be the <em>load</em> or <em>store</em> associated with <i>A</i>, and let action <i>P</i> be the <em>read</em> or <em>write</em> of <i>V</i> that corresponds to <i>F</i>. Similarly, let action <i>B</i> be a <em>use</em> or <em>assign</em> by thread <i>T</i> on variable &#32;<i>W</i>, let action <i>G</i> be the <em>load</em> or <em>store</em> associated with <i>B</i>, and let action <i>Q</i> be the <em>read</em> or <em>write</em> of <i>W</i> that corresponds to <i>G</i>. If <i>A</i> precedes <i>B</i>, then <i>P</i> must precede <i>Q</i>. (Less formally: actions on the master copies of volatile variables on behalf of a thread are performed by the main memory in exactly the order that the thread requested.)
</ul><a name="55816"></a>
The <em>load</em>, <em>store</em>, <em>read</em>, and <em>write</em> actions on <code>volatile</code> variables are atomic, even if the type of the variable is <code>double</code> or <code>long</code>.<p>
<a name="45376"></a>
<h2>17.8    Prescient Store Actions</h2>
<a name="45377"></a>
If a variable is not declared <code>volatile</code>, then the rules in the previous sections are relaxed slightly to allow <em>store</em> actions to occur earlier than would otherwise be permitted. The purpose of this relaxation is to allow optimizing Java compilers to perform certain kinds of code rearrangement that preserve the semantics of properly synchronized programs but might be caught in the act of performing memory actions out of order by programs that are not properly synchronized.<p>
<a name="45378"></a>
Suppose that a <em>store</em> by <i>T</i> of <i>V</i> would follow a particular <em>assign</em> by <i>T</i> of <i>V</i> according to the rules of the previous sections, with no intervening <em>load</em> or <em>assign</em> by <i>T</i> of <i>V</i>. Then that <em>store</em> action would send to the main memory the value that the <em>assign</em> action put into the working memory of thread <i>T</i>. The special rule allows the <em>store</em> action to instead occur before the <em>assign</em> action, if the following restrictions are obeyed:<p>
<ul><a name="45379"></a>
<li>If the <em>store</em> action occurs, the <em>assign</em> is bound to occur. (Remember, these are restrictions on what actually happens, not on what a thread plans to do. No fair performing a <em>store</em> and then throwing an exception before the <em>assign</em> occurs!)
<a name="45380"></a>
<li>No <em>lock</em> action intervenes between the relocated <em>store</em> and the <em>assign</em>.
<a name="45381"></a>
<li>No <em>load</em> of <i>V</i> intervenes between the relocated <em>store</em> and the <em>assign</em>.
<a name="45382"></a>
<li>No other <em>store</em> of <i>V</i> intervenes between the relocated <em>store</em> and the <em>assign</em>.
<a name="45383"></a>
<li>The <em>store</em> action sends to the main memory the value that the <em>assign</em> action will put into the working memory of thread <i>T</i>. 
</ul><a name="45384"></a>
This last property inspires us to call such an early <em>store</em> action <em>prescient</em>: it has to know ahead of time, somehow, what value will be stored by the <em>assign</em> that it should have followed. In practice, optimized compiled code will compute such values early (which is permitted if, for example, the computation has no side effects and throws no exceptions), store them early (before entering a loop, for example), and keep them in working registers for later use within the loop.<p>
<a name="28341"></a>
<h2>17.9    Discussion</h2>
<a name="28342"></a>
Any association between locks and variables is purely conventional. Locking any lock conceptually flushes <em>all</em> variables from a thread's working memory, and unlocking any lock forces the writing out to main memory of <em>all</em> variables that the thread has assigned. That a lock may be associated with a particular object or a class is purely a convention. In some applications, it may be appropriate always to lock an object before accessing any of its instance variables, for example; synchronized methods are a convenient way to follow this convention. In other applications, it may suffice to use a single lock to synchronize access to a large collection of objects.<p>
<a name="28343"></a>
If a thread uses a particular shared variable only after locking a particular lock and before the corresponding unlocking of that same lock, then the thread will read the shared value of that variable from main memory after the <em>lock</em> action, if necessary, and will copy back to main memory the value most recently assigned to that variable before the <em>unlock</em> action. This, in conjunction with the mutual exclusion rules for locks, suffices to guarantee that values are correctly transmitted from one thread to another through shared variables.<p>
<a name="28344"></a>
The rules for <code>volatile</code> variables effectively require that main memory be touched exactly once for each <em>use</em> or <em>assign</em> of a <code>volatile</code> variable by a thread, and that main memory be touched in exactly the order dictated by the thread execution semantics. However, such memory actions are not ordered with respect to <em>read</em> and <em>write</em> actions on nonvolatile variables.<p>
<a name="28345"></a>
<h2>17.10    Example: Possible Swap</h2>
<a name="28346"></a>
Consider a class that has class variables <code>a</code> and <code>b</code> and methods <code>hither</code> and <code>yon</code>:<p>
<blockquote><pre>class Sample {
	int a = 1, b = 2;
	void hither() {
		a = b;
	}
	void yon() {
		b = a;
	}
}
</pre></blockquote><a name="28356"></a>
Now suppose that two threads are created, and that one thread calls <code>hither</code> while the other thread calls <code>yon</code>. What is the required set of actions and what are the ordering constraints?<p>
<a name="28357"></a>
Let us consider the thread that calls <code>hither</code>. According to the rules, this thread must perform an <em>use</em> of <code>b</code> followed by an <em>assign</em> of <code>a</code>. That is the bare minimum required to execute a call to the method <code>hither</code>.<p>
<a name="28358"></a>
Now, the first action on variable <code>b</code> by the thread cannot be <em>use</em>. But it may be <em>assign</em> or <em>load</em>. An <em>assign</em> to <code>b</code> cannot occur because the program text does not call for such an <em>assign</em> action, so a <em>load</em> of <code>b</code> is required. This <em>load</em> action by the thread in turn requires a preceding <em>read</em> action for <code>b</code> by the main memory.<p>
<a name="28359"></a>
The thread may optionally <em>store</em> the value of <code>a</code> after the <em>assign</em> has occurred. If it does, then the <em>store</em> action in turn requires a following <em>write</em> action for <code>a</code> by the main memory.<p>
<a name="28360"></a>
The situation for the thread that calls <code>yon</code> is similar, but with the roles of <code>a</code> and <code>b</code> exchanged.<p>
<a name="28388"></a>
The total set of actions may be pictured as follows:<p>
<center><img src="17.doc.anc.gif"><p></center>
<a name="29084"></a>
Here an arrow from action <em>A</em> to action <em>B</em> indicates that <em>A</em> must precede <em>B</em>.<p>
<a name="28389"></a>
In what order may the actions by the main memory occur? The only constraint is that it is not possible both for the <em>write</em> of <code>a</code> to precede the <em>read</em> of <code>a</code> and for the <em>write</em> of <code>b</code> to precede the <em>read</em> of <code>b</code>, because the causality arrows in the diagram would form a loop so that an action would have to precede itself, which is not allowed. Assuming that the optional <em>store</em> and <em>write</em> actions are to occur, there are three possible orderings in which the main memory might legitimately perform its actions. Let <code>ha</code> and <code>hb</code> be the working copies of <code>a</code> and <code>b</code> for the <code>hither</code> thread, let <code>ya</code> and <code>yb</code> be the working copies for the <code>yon</code> thread, and let <code>ma</code> and <code>mb</code> be the master copies in main memory. Initially <code>ma=1</code> and <code>mb=2</code>. Then the three possible orderings of actions and the resulting states are as follows:<p>
<ul><a name="28390"></a>
<li><em>write</em> <code>a</code><img src="chars/arrwrite.gif">read <code>a</code>, <em>read</em> <code>b</code><img src="chars/arrwrite.gif">write <code>b</code> (then <code>ha=2</code>, <code>hb=2</code>, <code>ma=2</code>, <code>mb=2</code>, <code>ya=2</code>, <code>yb=2</code>)
<a name="29157"></a>
<li><em>read</em> <code>a</code><img src="chars/arrwrite.gif">write <code>a</code>, <em>write</em> <code>b</code><img src="chars/arrwrite.gif">read <code>b</code> (then <code>ha=1</code>, <code>hb=1</code>, <code>ma=1</code>, <code>mb=1</code>, <code>ya=1</code>, <code>yb=1</code>)
<a name="28391"></a>
<li><em>read</em> <code>a</code><img src="chars/arrwrite.gif">write <code>a</code>, <em>read</em> <code>b</code><img src="chars/arrwrite.gif">write <code>b</code> (then <code>ha=2</code>, <code>hb=2</code>, <code>ma=2</code>, <code>mb=1</code>, <code>ya=1</code>, <code>yb=1</code>)
</ul><a name="29137"></a>
Thus the net result might be that, in main memory, <code>b</code> is copied into <code>a</code>, <code>a</code> is copied into <code>b</code>, or the values of <code>a</code> and <code>b</code> are swapped; moreover, the working copies of the variables might or might not agree. It would be incorrect, of course, to assume that any one of these outcomes is more likely than another. This is one place in which the behavior of a program is necessarily timing-dependent.<p>
<a name="29184"></a>
Of course, an implementation might also choose not to perform the <em>store</em> and <em>write</em> actions, or only one of the two pairs, leading to yet other possible results.<p>
<a name="29185"></a>
Now suppose that we modify the example to use <code>synchronized</code> methods:<p>
<blockquote><pre>class SynchSample {
	int a = 1, b = 2;
	synchronized void hither() {
		a = b;
	}
	synchronized void yon() {
		b = a;
	}
}
</pre></blockquote><a name="28408"></a>
Let us again consider the thread that calls <code>hither</code>. According to the rules, this thread must perform a <em>lock</em> action (on the instance of class <code>SynchSample</code> on which the <code>hither</code> method is being called) before the body of method <code>hither</code> is executed. This is followed by a <em>use</em> of <code>b</code> and then an <em>assign</em> of <code>a</code>. Finally, an <em>unlock</em> action on that same instance of <code>SynchSample</code> must be performed after the body of method <code>hither</code> completes. That is the bare minimum required to execute a call to the method <code>hither</code>.<p>
<a name="28409"></a>
As before, a <em>load</em> of <code>b</code> is required, which in turn requires a preceding <em>read</em> action for <code>b</code> by the main memory. Because the <em>load</em> follows the <em>lock</em> action, the corresponding <em>read</em> must also follow the <em>lock</em> action.<p>
<a name="28410"></a>
Because an <em>unlock</em> action follows the <em>assign</em> of <code>a</code>, a <em>store</em> action on <code>a</code> is mandatory, which in turn requires a following <em>write</em> action for <code>a</code> by the main memory. The <em>write</em> must precede the <em>unlock</em> action.<p>
<a name="28411"></a>
The situation for the thread that calls <code>yon</code> is similar, but with the roles of <code>a</code> and <code>b</code> exchanged.<p>
<a name="28451"></a>
The total set of actions may be pictured as follows:<p>
<center><img src="17.doc.anc1.gif"><p></center>
<a name="29170"></a>
The <em>lock</em> and <em>unlock</em> actions provide further constraints on the order of actions by the main memory; the <em>lock</em> action by one thread cannot occur between the <em>lock</em> and <em>unlock</em> actions of the other thread. Moreover, the <em>unlock</em> actions require that the <em>store</em> and <em>write</em> actions occur. It follows that only two sequences are possible:<p>
<ul><a name="29161"></a>
<li><em>write</em> <code>a</code><img src="chars/arrwrite.gif">read <code>a</code>, <em>read</em> <code>b</code><img src="chars/arrwrite.gif">write <code>b</code> (then <code>ha=2</code>, <code>hb=2</code>, <code>ma=2</code>, <code>mb=2</code>, <code>ya=2</code>, <code>yb=2</code>)
<a name="29162"></a>
<li><em>read</em> <code>a</code><img src="chars/arrwrite.gif">write <code>a</code>, <em>write</em> <code>b</code><img src="chars/arrwrite.gif">read <code>b</code> (then <code>ha=1</code>, <code>hb=1</code>, <code>ma=1</code>, <code>mb=1</code>, <code>ya=1</code>, <code>yb=1</code>)
</ul><a name="28455"></a>
While the resulting state is timing-dependent, it can be seen that the two threads will necessarily agree on the values of <code>a</code> and <code>b</code>.<p>
<a name="29188"></a>
<h2>17.11    Example: Out-of-Order Writes</h2>
<a name="29191"></a>
This example is similar to that in the preceding section, except that one method assigns to both variables and the other method reads both variables. Consider a class that has class variables <code>a</code> and <code>b</code> and methods <code>to</code> and <code>fro</code>:<p>
<blockquote><pre>class Simple {
	int a = 1, b = 2;
	void to() {
		a = 3;
		b = 4;
	}
	void fro() {
		System.out.println("a= " + a + ", b=" + b);
	}
}
</pre></blockquote><a name="29201"></a>
Now suppose that two threads are created, and that one thread calls <code>to</code> while the other thread calls <code>fro</code>. What is the required set of actions and what are the ordering constraints?<p>
<a name="29202"></a>
Let us consider the thread that calls <code>to</code>. According to the rules, this thread must perform an <em>assign</em> of <code>a</code> followed by an <em>assign</em> of <code>b</code>. That is the bare minimum required to execute a call to the method <code>to</code>. Because there is no synchronization, it is at the option of the implementation whether or not to <em>store</em> the assigned values back to main memory! Therefore the thread that calls <code>fro</code> may obtain either <code>1</code> or <code>3</code> for the value of <code>a</code>, and independently may obtain either <code>2</code> or <code>4</code> for the value of <code>b</code>.<p>
<a name="29315"></a>
Now suppose that <code>to</code> is <code>synchronized</code> but <code>fro</code> is not:<p>
<blockquote><pre>class SynchSimple {
	int a = 1, b = 2;
	synchronized void to() {
		a = 3;
		b = 4;
	}
	void fro() {
		System.out.println("a= " + a + ", b=" + b);
	}
}
</pre></blockquote><a name="29316"></a>
In this case the method <code>to</code> will be forced to <em>store</em> the assigned values back to main memory before the <em>unlock</em> action at the end of the method. The method <code>fro</code> must, of course, <em>use</em> <code>a</code> and <code>b</code> (in that order) and so must <em>load</em> values for <code>a</code> and <code>b</code> from main memory.<p>
<a name="29336"></a>
The total set of actions may be pictured as follows:<p><center>
<img src="17.doc.anc2.gif"><p>
</center>
<a name="29234"></a>
Here an arrow from action <em>A</em> to action <em>B</em> indicates that <em>A</em> must precede <em>B</em>.<p>
<a name="29235"></a>
In what order may the actions by the main memory occur? Note that the rules do not require that <em>write</em> <code>a</code> occur before <em>write</em> <code>b</code>; neither do they require that <em>read</em> <code>a</code> occur before <em>read</em> <code>b</code>. Also, even though method <code>to</code> is <code>synchronized</code>, method <code>fro</code> is not <code>synchronized</code>, so there is nothing to prevent the <em>read</em> actions from occurring between the <em>lock</em> and <em>unlock</em> actions. (The point is that declaring one method <code>synchronized</code> does not of itself make that method behave as if it were atomic.)<p>
<a name="29398"></a>
As a result, the method <code>fro</code> could still obtain either <code>1</code> or <code>3</code> for the value of <code>a</code>, and independently could obtain either <code>2</code> or <code>4</code> for the value of <code>b</code>. In particular, <code>fro</code> might observe the value <code>1</code> for <code>a</code> and <code>4</code> for <code>b</code>. Thus, even though <code>to</code> does an <em>assign</em> to <code>a</code> and then an <em>assign</em> to <code>b</code>, the <em>write</em> actions to main memory may be observed by another thread to occur as if in the opposite order.<p>
<a name="55976"></a>
<p>
<a name="55977"></a>
<p>
<a name="55978"></a>
<p>
<a name="55979"></a>
<p>
<a name="55980"></a>
<p>
<a name="55985"></a>
<p>
<a name="29431"></a>
Finally, suppose that <code>to</code> and <code>fro</code> are both <code>synchronized</code>:<p>
<blockquote><pre>class SynchSynchSimple {
	int a = 1, b = 2;
	synchronized void to() {
		a = 3;
		b = 4;
	}
	synchronized void fro() {
		System.out.println("a= " + a + ", b=" + b);
	}
}
<a name="29386"></a>
In this case, the actions of method <code>fro</code> cannot be interleaved with the actions of method <code>to</code>, and so <code>fro</code> will print either "<code>a=1, b=2</code>" or "<code>a=3, b=4</code>".<p>
</pre></blockquote><a name="28457"></a>
<h2>17.12    Threads</h2>
<a name="28458"></a>
Threads are created and managed by the built-in classes <code>Thread</code> and <code>ThreadGroup</code>. Creating a <code>Thread</code> object creates a thread and that is the only way to create a thread. When the thread is created, it is not yet active; it begins to run when its <code>start</code> method is called.<p>
<a name="44439"></a>
Every thread has a <em>priority</em>. When there is competition for processing resources, threads with higher priority are generally executed in preference to threads with lower priority. Such preference is not, however, a guarantee that the highest priority thread will always be running, and thread priorities cannot be used to reliably implement mutual exclusion.<p>
<a name="28460"></a>
<h2>17.13    Locks and Synchronization</h2>
<a name="28461"></a>
There is a lock associated with every object. The Java programming language does not provide a way to perform separate <em>lock</em> and <em>unlock</em> actions; instead, they are implicitly performed by high-level constructs that arrange always to pair such actions correctly. <p>
<a name="55516"></a>
Note, however, that the Java virtual machine provides separate <em>monitorenter</em> and <em>monitorexit</em> instructions that implement the <em>lock</em> and <em>unlock</em> actions.<p>
<a name="28465"></a>
The <code>synchronized</code> statement <a href="statements.doc.html#255769">(&#167;14.18)</a> computes a reference to an object; it then attempts to perform a <em>lock</em> action on that object and does not proceed further until the <em>lock</em> action has successfully completed. (A <em>lock</em> action may be delayed because the rules about locks can prevent the main memory from participating until some other thread is ready to perform one or more <em>unlock</em> actions.) After the lock action has been performed, the body of the <code>synchronized</code> statement is executed. If execution of the body is ever completed, either normally or abruptly, an <em>unlock</em> action is automatically performed on that same lock.<p>
<a name="28469"></a>
A <code>synchronized</code> method <a href="classes.doc.html#260369">(&#167;8.4.3.6)</a> automatically performs a <em>lock</em> action when it is invoked; its body is not executed until the <em>lock</em> action has successfully completed. If the method is an instance method, it locks the lock associated with the instance for which it was invoked (that is, the object that will be known as <code>this</code> during execution of the body of the method). If the method is <code>static</code>, it locks the lock associated with the <code>Class</code> object that represents the class in which the method is defined. If execution of the method's body is ever completed, either normally or abruptly, an <em>unlock</em> action is automatically performed on that same lock.<p>
<a name="28470"></a>
Best practice is that if a variable is ever to be assigned by one thread and used or assigned by another, then all accesses to that variable should be enclosed in <code>synchronized</code> methods or <code>synchronized</code> statements.<p>
<a name="45472"></a>
The Java programming language does not prevent, nor require detection of, deadlock conditions. Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that don't deadlock, if necessary.<p>
<a name="28471"></a>
<h2>17.14    Wait Sets and Notification</h2>
<a name="29596"></a>
Every object, in addition to having an associated lock, has an associated <em>wait set</em>, which is a set of threads. When an object is first created, its wait set is empty.<p>
<a name="29597"></a>
Wait sets are used by the methods <code>wait</code>, <code>notify</code>, and <code>notifyAll</code> of class <code>Object</code>. These methods also interact with the scheduling mechanism for threads.<p>
<a name="29731"></a>
The method <code>wait</code> should be called for an object only when the current thread (call it <i>T</i>) has already locked the object's lock. Suppose that thread <i>T</i> has in fact performed <em>N lock</em> actions that have not been matched by <em>unlock</em> actions. The <code>wait</code> method then adds the current thread to the wait set for the object, disables the current thread for thread scheduling purposes, and performs <em>N</em> <em>unlock</em> actions to relinquish the lock. The thread <i>T</i> then lies dormant until one of three things happens:<p>
<ul><a name="29732"></a>
<li>Some other thread invokes the <code>notify</code> method for that object and thread <i>T</i> happens to be the one arbitrarily chosen as the one to notify.
<a name="29721"></a>
<li>Some other thread invokes the <code>notifyAll</code> method for that object.
<a name="29664"></a>
<li>If the call by thread <i>T</i> to the <code>wait</code> method specified a timeout interval, the specified amount of real time has elapsed.
</ul><a name="29669"></a>
The thread <i>T</i> is then removed from the wait set and re-enabled for thread scheduling. It then locks the object again (which may involve competing in the usual manner with other threads); once it has gained control of the lock, it performs <img src="17.doc.anc3.gif"> additional <em>lock</em> actions and then returns from the invocation of the <code>wait</code> method. Thus, on return from the <code>wait</code> method, the state of the object's lock is exactly as it was when the <code>wait</code> method was invoked.<p>
<a name="29772"></a>
The <code>notify</code> method should be called for an object only when the current thread has already locked the object's lock. If the wait set for the object is not empty, then some arbitrarily chosen thread is removed from the wait set and re-enabled for thread scheduling. (Of course, that thread will not be able to proceed until the current thread relinquishes the object's lock.)<p>
<a name="29776"></a>
The <code>notifyAll</code> method should be called for an object only when the current thread has already locked the object's lock. Every thread in the wait set for the object is removed from the wait set and re-enabled for thread scheduling. (Of course, those threads will not be able to proceed until the current thread relinquishes the object's lock.)
<a name="48076"></a>
<p>


<hr>
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="defAssign.doc.html">Prev</a> | <a href="syntax.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<i><a href="jcopyright.doc.html">Copyright</a> &#169 2000 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jls@java.sun.com">jls@java.sun.com</a>
</font>
</body></html>
