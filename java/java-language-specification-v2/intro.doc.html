<html>
<head>
<title> Introduction</title>
</head>
<body BGCOLOR=#ffffff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="j.preface2.html">Prev</a> | <a href="grammars.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<hr><br>
 
<a name="250270"></a>
<p><strong>
CHAPTER
 1 </strong></p>
<a name="22191"></a>
<h1>Introduction</h1>
<hr><p>
<a name="51863"></a>
The Java<font size="-1"><sup>TM</sup></font> programming language is a general-purpose, concurrent, class-based, object-oriented language. It is designed to be simple enough that many programmers can achieve fluency in the language. The Java programming language is related to C and C++ but is organized rather differently, with a number of aspects of C and C++ omitted and a few ideas from other languages included. It is intended to be a production language, not a research language, and so, as C. A. R. Hoare suggested in his classic paper on language design, the design has avoided including new and untested features.<p>
<a name="51872"></a>
The Java programming language is strongly typed. This specification clearly distinguishes between the <em>compile-time errors</em> that can and must be detected at compile time, and those that occur at run time. Compile time normally consists of translating programs into a machine-independent byte code representation. Run-time activities include loading and linking of the classes needed to execute a program, optional machine code generation and dynamic optimization of the program, and actual program execution.<p>
<a name="27438"></a>
The Java programming language is a relatively high-level language, in that details of the machine representation are not available through the language. It includes automatic storage management, typically using a garbage collector, to avoid the safety problems of explicit deallocation (as in C's <code>free</code> or C++'s <code>delete</code>). High-performance garbage-collected implementations can have bound----ed pauses to support systems programming and real-time applications. The language does not include any unsafe constructs, such as array accesses without index checking, since such unsafe constructs would cause a program to behave in an unspecified way.<p>
<a name="51852"></a>
The Java programming language is normally compiled to the bytecoded instruction set and binary format defined in <em>The Java</em><em> Virtual Machine Specification, Second Edition </em>(Addison-Wesley, 1999).<p>
<a name="26287"></a>
This specification is organized as follows:
<p><a name="26288"></a>
Chapter 2 describes grammars and the notation used to present the lexical and syntactic grammars for the language.<p>
<a name="228682"></a>
Chapter 3 describes the lexical structure of the Java programming language, which is based on C and C++. The language is written in the Unicode character set. It supports the writing of Unicode characters on systems that support only ASCII.<p>
<a name="26538"></a>
Chapter 4 describes types, values, and variables. Types are subdivided into primitive types and reference types.<p>
<a name="18945"></a>
The primitive types are defined to be the same on all machines and in all implementations, and are various sizes of two's-complement integers, single- and double-precision IEEE 754 standard floating-point numbers, a <code>boolean</code> type, and a Unicode character <code>char</code> type. Values of the primitive types do not share state.<p>
<a name="18946"></a>
Reference types are the class types, the interface types, and the array types. The reference types are implemented by dynamically created objects that are either instances of classes or arrays. Many references to each object can exist. All objects (including arrays) support the methods of the class <code>Object</code>, which is the (single) root of the class hierarchy. A predefined <code>String</code> class supports Unicode character strings. Classes exist for wrapping primitive values inside of objects.<p>
<a name="18948"></a>
Variables are typed storage locations. A variable of a primitive type holds a value of that exact primitive type. A variable of a class type can hold a null reference or a reference to an object whose type is that class type or any subclass of that class type. A variable of an interface type can hold a null reference or a reference to an instance of any class that implements the interface. A variable of an array type can hold a null reference or a reference to an array. A variable of class type <code>Object</code> can hold a null reference or a reference to any object, whether class instance or array.<p>
<a name="228680"></a>
Chapter 5 describes conversions and numeric promotions. Conversions change the compile-time type and, sometimes, the value of an expression. Numeric promotions are used to convert the operands of a numeric operator to a common type where an operation can be performed. There are no loopholes in the language; casts on reference types are checked at run time to ensure type safety.<p>
<a name="228720"></a>
Chapter 6 describes declarations and names, and how to determine what names mean (denote). The language does not require types or their members to be declared before they are used. Declaration order is significant only for local variables, local classes, and the order of initializers of fields in a class or interface.<p>
<a name="46378"></a>
The Java programming language provides control over the scope of names and supports limitations on external access to members of packages, classes, and interfaces. This helps in writing large programs by distinguishing the implementation of a type from its users and those who extend it. Recommended naming conventions that make for more readable programs are described here.<p>
<a name="26857"></a>
Chapter 7 describes the structure of a program, which is organized into packages similar to the modules of Modula. The members of a package are classes, interfaces, and subpackages. Packages are divided into compilation units. Compilation units contain type declarations and can import types from other packages to give them short names. Packages have names in a hierarchical name space, and the Internet domain name system can usually be used to form unique package names.<p>
<a name="26599"></a>
Chapter 8 describes classes. The members of classes are classes, interfaces, fields (variables) and methods. Class variables exist once per class. Class methods operate without reference to a specific object. Instance variables are dynamically created in objects that are instances of classes. Instance methods are invoked on instances of classes; such instances become the current object <code>this</code> during their execution, supporting the object-oriented programming style.<p>
<a name="236326"></a>
Classes support single implementation inheritance, in which the implementation of each class is derived from that of a single superclass, and ultimately from the class <code>Object</code>. Variables of a class type can reference an instance of that class or of any subclass of that class, allowing new types to be used with existing methods, polymorphically.<p>
<a name="236327"></a>
Classes support concurrent programming with <code>synchronized</code> methods. Methods declare the checked exceptions that can arise from their execution, which allows compile-time checking to ensure that exceptional conditions are handled. Objects can declare a <code>finalize</code> method that will be invoked before the objects are discarded by the garbage collector, allowing the objects to clean up their state.<p>
<a name="46499"></a>
For simplicity, the language has neither declaration "headers" separate from the implementation of a class nor separate type and class hierarchies.<p>
<a name="46502"></a>
Although the language does not include parameterized classes, the semantics of arrays are those of a parameterized class with some syntactic sugar. Like the programming language Beta, the Java programming language uses a run-time type check when storing references in arrays to ensure complete type safety.<p>
<a name="46505"></a>
Chapter 9 describes interface types, which declare a set of abstract methods, member types, and constants. Classes that are otherwise unrelated can implement the same interface type. A variable of an interface type can contain a reference to any object that implements the interface. Multiple interface inheritance is supported.<p>
<a name="25607"></a>
Chapter 10 describes arrays. Array accesses include bounds checking. Arrays are dynamically created objects and may be assigned to variables of type <code>Object</code>. The language supports arrays of arrays, rather than multidimensional arrays.<p>
<a name="27520"></a>
Chapter 11 describes exceptions, which are nonresuming and fully integrated with the language semantics and concurrency mechanisms. There are three kinds of exceptions: checked exceptions, run-time exceptions, and errors. The compiler ensures that checked exceptions are properly handled by requiring that a method or constructor can result in a checked exception only if the method or constructor declares it. This provides compile-time checking that exception handlers exist, and aids programming &#32;in the large. Most user-defined exceptions should be checked exceptions. Invalid operations in the program detected by the Java virtual machine result in run-time exceptions, such as <code>NullPointerException</code>. Errors result from failures detected by the virtual machine, such as <code>OutOfMemoryError</code>. Most simple programs do not try to handle errors.<p>
<a name="27521"></a>
Chapter 12 describes activities that occur during execution of a program. A program is normally stored as binary files representing compiled classes and interfaces. These binary files can be loaded into a Java virtual machine, linked to other classes and interfaces, and initialized.<p>
<a name="22863"></a>
After initialization, class methods and class variables may be used. Some classes may be instantiated to create new objects of the class type. Objects that are class instances also contain an instance of each superclass of the class, and object creation involves recursive creation of these superclass instances.<p>
<a name="248790"></a>
When an object is no longer referenced, it may be reclaimed by the garbage collector. If an object declares a finalizer, the finalizer is executed before the object is reclaimed to give the object a last chance to clean up resources that would not otherwise be released. When a class is no longer needed, it may be unloaded.<p>
<a name="248793"></a>
Chapter 13 describes binary compatibility, specifying the impact of changes to types on other types that use the changed types but have not been recompiled. These considerations are of interest to developers of types that are to be widely distributed, in a continuing series of versions, often through the Internet. Good program development environments automatically recompile dependent code whenever a type is changed, so most programmers need not be concerned about these details.<p>
<a name="228758"></a>
Chapter 14 describes blocks and statements, which are based on C and C++. The language has no <code>goto</code> statement, but includes labeled <code>break</code> and <code>continue</code> statements. Unlike C, the Java programming language requires <code>bool--ean</code> &#32; expressions in control-flow statements, and does not convert types to <code>boolean</code> implicitly, in the hope of catching more errors at compile time. A <code>synchronized</code> &#32; statement provides basic object-level monitor locking. A <code>try</code> statement can include <code>catch</code> and <code>finally</code> clauses to protect against non-local control transfers.<p>
<a name="237589"></a>
Chapter 15 describes expressions. This document fully specifies the (apparent) order of evaluation of expressions, for increased determinism and portability. Overloaded methods and constructors are resolved at compile time by picking the most specific method or constructor from those which are applicable.<p>
<a name="237592"></a>
Chapter 16 describes the precise way in which the language ensures that local variables are definitely set before use. While all other variables are automatically initialized to a default value, the Java programming language does not automatically initialize local variables in order to avoid masking programming errors.<p>
<a name="237601"></a>
Chapter 17 describes the semantics of threads and locks, which are based on the monitor-based concurrency originally introduced with the Mesa programming language. The Java programming language specifies a memory model for shared-memory multiprocessors that supports high-performance implementations.<p>
<a name="21133"></a>
Chapter 18 presents a syntactic grammar for the language.<p>
<a name="247825"></a>
The book concludes with an index, credits for quotations used in the book, and a colophon describing how the book was created.<p>
<a name="11484"></a>
<h2>1.1    Example Programs</h2>
<a name="11485"></a>
Most of the example programs given in the text are ready to be executed and are similar in form to:<p>
<blockquote><pre><a name="11486"></a>
class Test {
<a name="44465"></a>	public static void main(String[] args) {
<a name="44467"></a>		for (int i = 0; i &lt; args.length; i++)
<a name="19064"></a>			System.out.print(i == 0 ? args[i] : " " + args[i]);
<a name="19080"></a>		System.out.println();
<a name="44477"></a>	}
<a name="44257"></a>}
</pre></blockquote><a name="44479"></a>
On a Sun workstation using Sun's JDK or Java 2 SDK software, this class, stored in the file <code>Test.java</code>, can be compiled and executed by giving the commands:<p>
<blockquote><pre><a name="11509"></a>
javac Test.java
<a name="11511"></a>java Test Hello, world.
</pre></blockquote><a name="11515"></a>
producing the output:<p>
<blockquote><pre>Hello, world.
</pre></blockquote><a name="11506"></a>
<h2>1.2    Notation</h2>
<a name="247983"></a>
Throughout this book we refer to classes and interfaces drawn from the Java and Java 2 platforms. Whenever we refer to a class or interface which is not defined in an example in this book using a single identifier N, the intended reference is to the class or interface named N in the package <code>java.lang</code>. We use the canonical name <a href="names.doc.html#25430">(&#167;6.7)</a> for classes or interfaces from packages other than <code>java.lang</code>.<p>
<a name="248104"></a>
<h2>1.3    Relationship to Predefined Classes and Interfaces</h2>
<a name="248127"></a>
As noted above, this specification often refers to classes of the Java and Java 2 platforms. In particular, some classes have a special relationship with the Java programming language. Examples include classes such as <code>Object</code>, <code>Class</code>, <code>ClassLoader</code>, <code>String</code>, <code>Thread</code>, and the classes and interfaces in package <code>java.lang.reflect</code>, among others. The language definition constrains the behavior of these classes and interfaces, but this document does not provide a complete specification for them. The reader is referred to other parts of the Java platform specification for such detailed API specifications.<p>
<a name="248140"></a>
Thus this document does not describe reflection in any detail. Many linguistic constructs have analogues in the reflection API, but these are generally not discussed here. So, for example, when we list the ways in which an object can be created, we generally do not include the ways in which the reflective API can accomplish this. Readers should be aware of these additional mechanisms even though they are not mentioned in this text.<p>
<a name="248138"></a>
<p>
<a name="247980"></a>
<h2>1.4    References</h2>
<a name="247839"></a>
Apple Computer. Dylan<em> Reference Manual. </em>Apple Computer Inc., Cupertino, California. September 29, 1995. See also <code>http://www.cambridge.apple.com</code>.<p>
<a name="247844"></a>
Bobrow, Daniel G., Linda G. DeMichiel, Richard P. Gabriel, Sonya E. Keene, Gregor Kiczales, &#32;and David A. Moon. <em>Common Lisp Object System Specification</em>, X3J13 Document 88-002R, June 1988; appears as Chapter 28 of Steele, Guy. Common Lisp: The Language, 2nd ed. Digital Press, 1990, ISBN 1-55558-041-6, 770-864.<p>
<a name="40207"></a>
Ellis, Margaret A., and Bjarne Stroustrup. <em>The Annotated </em>C++ Reference Manual. Addison-Wesley, Reading, Massachusetts, 1990, reprinted with corrections October 1992, ISBN 0-201-51459-1.<p>
<a name="250088"></a>
Goldberg, Adele and Robson, David.<em> Smalltalk-80: The Language</em>. Addison-Wesley, Reading, Massachusetts, 1989, ISBN 0-201-13688-0.<p>
<a name="14948"></a>
Harbison, Samuel. Modula-3. Prentice Hall, Englewood Cliffs, New Jersey, 1992, ISBN 0-13-596396.<p>
<a name="11556"></a>
Hoare, C. A. R. <em>Hints on Programming Language Design. </em>Stanford University Computer Science Department Technical Report No. CS-73-403, December 1973. Reprinted in SIGACT/SIGPLAN Symposium on Principles of Programming Languages. Association for Computing Machinery, New York, October 1973.<p>
<a name="11558"></a>
IEEE Standard for Binary Floating-Point Arithmetic. ANSI/IEEE Std. 754-1985. Available from Global Engineering Documents, 15 Inverness Way East, Englewood, Colorado 80112-5704 USA; 800-854-7179.<p>
<a name="14939"></a>
Kernighan, Brian W., and Dennis M. Ritchie. <em>The </em>C Programming Language, 2nd ed. Prentice &#32;Hall, Englewood Cliffs, New Jersey, 1988, ISBN 0-13-110362-8.<p>
<a name="235648"></a>
Madsen, Ole Lehrmann, Birger M&oslash;ller-Pedersen, and Kristen Nygaard. <em>Object-Oriented Programming in the </em>Beta Programming Language. Addison-Wesley, Reading, Massachusetts, 1993, ISBN 0-201-62430-3.<p>
<a name="159150"></a>
Mitchell, James G., William Maybury, and Richard Sweet. <em>The </em>Mesa Programming Language, &#32;Version 5.0. Xerox PARC, Palo Alto, California, CSL 79-3, April 1979.<p>
<a name="14908"></a>
Stroustrup, Bjarne. <em>The C++ Progamming Language, </em>2nd ed. Addison-Wesley, Reading, Massachusetts, 1991, reprinted with corrections January 1994, ISBN 0-201-53992-6.<p>
<a name="247947"></a>
Unicode Consortium, The. <em>The Unicode Standard: Worldwide Character Encoding</em>, Version 1.0, Volume 1, ISBN 0-201-56788-1, and Volume 2, ISBN 0-201-60845-6. Updates and additions necessary to bring the Unicode Standard up to version 1.1 may be found at -<code>http://www.unicode.org</code>.<p>
<a name="247948"></a>
Unicode Consortium, The. <em>The Unicode Standard, Version 2.0</em>, ISBN 0-201-48345-9. Updates and additions necessary to bring the Unicode Standard up to version 2.1 may be found at <code>http://www.unicode.org</code>.<p>
<a name="235748"></a>
<p>


<hr>
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="j.preface2.html">Prev</a> | <a href="grammars.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<i><a href="jcopyright.doc.html">Copyright</a> &#169 2000 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jls@java.sun.com">jls@java.sun.com</a>
</font>
</body></html>
